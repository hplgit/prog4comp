
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Computing integrals</title>
    
    <link rel="stylesheet" href="_static/default.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '1.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/javascript" src="_static/sidebar.js"></script>

        <script src="http://sagecell.sagemath.org/static/jquery.min.js"></script>
        <script src="http://sagecell.sagemath.org/static/embedded_sagecell.js"></script>

        <script>sagecell.makeSagecell({inputLocation: ".sage"});</script>

        <style type="text/css">
                .sagecell .CodeMirror-scroll {
                        overflow-y: hidden;
                        overflow-x: auto;
                }
                .sagecell .CodeMirror {
                        height: auto;
                }
        </style>

    
    <link rel="top" title="Programming for Computations (Python version)" href="index.html" />
    <link rel="next" title="Solving ordinary differential equations" href="._pylight005.html" />
    <link rel="prev" title="Basic constructions" href="._pylight003.html" />
 
  
       <style type="text/css">
         div.admonition {
           background-color: whiteSmoke;
           border: 1px solid #bababa;
         }
       </style>
      </head>
    
  <body role="document">
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="._pylight005.html" title="Solving ordinary differential equations"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="._pylight003.html" title="Basic constructions"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">Programming for Computations (Python version)</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="computing-integrals">
<span id="sec-integrals"></span><h1>Computing integrals<a class="headerlink" href="#computing-integrals" title="Permalink to this headline">¶</a></h1>
<span class="target" id="index-0"></span><span class="target" id="index-1"></span><span class="target" id="index-2"></span><div class="figure" id="index-3">
<a class="reference internal image-reference" href="_images/integral_comic_strip.png"><img alt="_images/integral_comic_strip.png" src="_images/integral_comic_strip.png" style="width: 800px;" /></a>
</div>
<div class="line-block">
<div class="line"><br /></div>
<div class="line"><br /></div>
</div>
<p>We now turn our attention to solving mathematical problems through
computer programming. There are many reasons to choose integration as
our first application. Integration is well known already from high
school mathematics. Most integrals are not tractable by pen and paper,
and a computerized solution approach is both very much simpler and
much more powerful - you can essentially treat all integrals
<span class="math">\(\int_a^bf(x)dx\)</span> in 10 lines of computer code (!). Integration also
demonstrates the difference between exact mathematics by pen and paper
and <em>numerical mathematics</em> on a computer. The latter approaches
the result of the former without any worries about rounding errors
due to finite precision arithmetics in computers (in contrast to
differentiation, where such errors prevent us from getting a result as accurate
as we desire on the computer). Finally, integration is thought of
as a somewhat difficult mathematical concept to grasp, and programming
integration should greatly help with the understanding of what
integration is and how it works. Not only shall we understand how to
use the computer to integrate, but we shall also learn a series of
good habits to ensure your computer work is of the highest scientific
quality. In particular, we have a strong focus on how to write
Python code that is free of programming mistakes.</p>
<p>Calculating an integral is traditionally done by</p>
<div class="math" id="eq-eqn-fbfa">
\[\tag{2}
\int_a^b f(x)\,dx = F(b) - F(a),\]</div>
<p>where</p>
<div class="math">
\[f(x) = \frac{dF}{dx} \thinspace .\]</div>
<p>The major problem with this procedure is that we need to find
the <em>anti-derivative</em> <span class="math">\(F(x)\)</span> corresponding to a given <span class="math">\(f(x)\)</span>.
For some relatively simple integrands <span class="math">\(f(x)\)</span>,
finding <span class="math">\(F(x)\)</span> is a doable task, but it can very quickly become challenging,
even impossible!</p>
<p>The method <a class="reference internal" href="#eq-eqn-fbfa"><span class="std std-ref">(2)</span></a> provides an <em>exact</em> or <em>analytical</em> value
of the integral. If we relax the requirement of the integral being
exact, and instead look for <em>approximate</em> values, produced by
<em>numerical methods</em>, integration becomes a very straightforward task
for any given <span class="math">\(f(x)\)</span> (!).</p>
<p>The downside of a numerical method is that it can only find an
approximate answer. Leaving the exact for the approximate is a mental
barrier in the beginning, but remember that most real applications of
integration will involve an <span class="math">\(f(x)\)</span> function that contains physical
parameters, which are measured with some error. That is, <span class="math">\(f(x)\)</span> is
very seldom exact, and then it does not make sense to compute the
integral with a smaller error than the one already present in <span class="math">\(f(x)\)</span>.</p>
<p>Another advantage of numerical methods is that we can easily integrate
a function <span class="math">\(f(x)\)</span> that is only known as <em>samples</em>, i.e., discrete
values at some <span class="math">\(x\)</span> points, and not as a continuous function of <span class="math">\(x\)</span>
expressed through a formula.  This is highly relevant when <span class="math">\(f\)</span> is
measured in a physical experiment.</p>
<div class="section" id="basic-ideas-of-numerical-integration">
<span id="sec-integrals-basic"></span><h2>Basic ideas of numerical integration<a class="headerlink" href="#basic-ideas-of-numerical-integration" title="Permalink to this headline">¶</a></h2>
<p>We consider the integral</p>
<div class="math" id="eq-sec-integr-fofx">
\[\tag{3}
\int_a^b f(x)dx\thinspace .\]</div>
<p>Most numerical methods for computing this integral split
up the original integral into a sum of several integrals, each
covering a smaller part of the original integration interval
<span class="math">\([a,b]\)</span>. This re-writing of the integral is based on a selection of
<em>integration points</em> <span class="math">\(x_i\)</span>, <span class="math">\(i = 0,1,\ldots,n\)</span> that are distributed on
the interval <span class="math">\([a,b]\)</span>. Integration points may,
or may not, be evenly distributed. An even distribution simplifies
expressions and is often sufficient, so we will mostly restrict ourselves to
that choice. The integration points are then computed as</p>
<div class="math" id="eq-sec-integr-points">
\[\tag{4}
x_i = a + ih,\quad i = 0,1,\ldots,n,\]</div>
<p>where</p>
<div class="math" id="eq-sec-h-intgr-step">
\[\tag{5}
h = \frac{b-a}{n}\thinspace .\]</div>
<p>Given the integration points, the original
integral is re-written as a sum of integrals, each integral being
computed over the sub-interval between two consecutive integration
points. The integral in <a class="reference internal" href="#eq-sec-integr-fofx"><span class="std std-ref">(3)</span></a> is thus expressed as</p>
<div class="math" id="eq-eqfdx">
\[\tag{6}
\int_a^b f(x)dx =
    \int_{x_0}^{x_1} f(x)dx + \int_{x_1}^{x_2} f(x)dx + \ldots +
    \int_{x_{n-1}}^{x_n} f(x)dx\thinspace .\]</div>
<p>Note that <span class="math">\(x_0 = a\)</span> and <span class="math">\(x_n = b\)</span>.</p>
<p>Proceeding from <a class="reference internal" href="#eq-eqfdx"><span class="std std-ref">(6)</span></a>, the different integration methods will
differ in the way they approximate each integral on the right hand
side.  The fundamental idea is that each term is an integral over a
small interval <span class="math">\([x_i,x_{i+1}]\)</span>, and over this small interval, it makes
sense to approximate <span class="math">\(f\)</span> by a simple shape, say a constant, a straight
line, or a parabola, which we can easily integrate by hand. The
details will become clear in the coming examples.</p>
<div class="section" id="computational-example">
<h3>Computational example<a class="headerlink" href="#computational-example" title="Permalink to this headline">¶</a></h3>
<p>To understand and compare the numerical integration methods, it is
advantageous to use a specific integral for computations and graphical
illustrations. In particular, we want to use an integral that we can
calculate by hand such that the accuracy of the approximation methods
can easily be assessed.  Our specific integral is taken from basic
physics.  Assume that you speed up your car from rest and wonder how
far you go in <span class="math">\(T\)</span> seconds. The distance is given by the integral
<span class="math">\(\int_0^T v(t)dt\)</span>, where <span class="math">\(v(t)\)</span> is the velocity as a function of
time. A rapidly increasing velocity function might be</p>
<div class="math" id="eq-sec-vcar-foft">
\[\tag{7}
v\left(t\right) = 3t^{2}e^{t^3}\thinspace .\]</div>
<p>The distance after one second is</p>
<div class="math" id="eq-sec-dcar-intgr">
\[\tag{8}
\int_0^1 v(t)dt,\]</div>
<p>which is the integral we aim to compute by numerical methods.
Fortunately, the chosen expression of the velocity has a form that makes it
easy to calculate the anti-derivative as</p>
<div class="math" id="eq-sec-pcar-foft">
\[\tag{9}
V(t) = e^{t^3}-1\thinspace .\]</div>
<p>We can therefore compute the exact value of the integral as
<span class="math">\(V(1)-V(0)\approx 1.718\)</span> (rounded to 3 decimals for convenience).</p>
</div>
</div>
<div class="section" id="the-composite-trapezoidal-rule">
<span id="sec-integrals-trap"></span><h2>The composite trapezoidal rule<a class="headerlink" href="#the-composite-trapezoidal-rule" title="Permalink to this headline">¶</a></h2>
<span class="target" id="index-4"></span><p id="index-5">The integral <span class="math">\(\int_a^b f(x)dx\)</span> may be interpreted as the
area between the <span class="math">\(x\)</span> axis and the graph <span class="math">\(y=f(x)\)</span> of the integrand.
Figure <a class="reference internal" href="#fig-vcar"><span class="std std-ref">The integral of  interpreted as the area under the graph of </span></a> illustrates this area for the choice
<a class="reference internal" href="#eq-sec-dcar-intgr"><span class="std std-ref">(8)</span></a>. Computing the integral <span class="math">\(\int_0^1f(t)dt\)</span>
amounts to computing the area of the hatched region.</p>
<div class="figure" id="id3">
<span id="fig-vcar"></span><a class="reference internal image-reference" href="_images/integral_of_f.png"><img alt="_images/integral_of_f.png" src="_images/integral_of_f.png" style="width: 400px;" /></a>
<p class="caption"><span class="caption-text">The integral of <span class="math">\(v(t)\)</span> interpreted as the area under the graph of <span class="math">\(v\)</span></span></p>
</div>
<p id="index-6">If we <em>replace</em> the true graph in Figure <a class="reference internal" href="#fig-vcar"><span class="std std-ref">The integral of  interpreted as the area under the graph of </span></a> by a set of
straight line segments, we may view the area rather as composed of
trapezoids, the areas of which are easy to compute. This is
illustrated in Figure <a class="reference internal" href="#fig-vcartrapeze"><span class="std std-ref">Computing approximately the integral of a function as the sum of the areas of the trapezoids</span></a>, where 4 straight line
segments give rise to 4 trapezoids, covering the time intervals
<span class="math">\([0,0.2)\)</span>, <span class="math">\([0.2,0.6)\)</span>, <span class="math">\([0.6,0.8)\)</span> and <span class="math">\([0.8,1.0]\)</span>. Note that we have
taken the opportunity here to demonstrate the computations with time
intervals that differ in size.</p>
<div class="figure" id="id4">
<span id="fig-vcartrapeze"></span><a class="reference internal image-reference" href="_images/viz_trapezoidal.png"><img alt="_images/viz_trapezoidal.png" src="_images/viz_trapezoidal.png" style="width: 400px;" /></a>
<p class="caption"><span class="caption-text"><em>Computing approximately the integral of a function as the sum of the areas of the trapezoids</em></span></p>
</div>
<p>The areas of the 4 trapezoids shown in Figure <a class="reference internal" href="#fig-vcartrapeze"><span class="std std-ref">Computing approximately the integral of a function as the sum of the areas of the trapezoids</span></a>
now constitute our approximation to the integral
<a class="reference internal" href="#eq-sec-dcar-intgr"><span class="std std-ref">(8)</span></a>:</p>
<div class="math">
\[\int_0^1 v(t)dt \approx
h_1 (\frac{v(0)+v(0.2)}{2}) + h_2 (\frac{v(0.2)+v(0.6)}{2}) \nonumber\]</div>
<div class="math" id="eq-sec-integr-trap-split">
\[\tag{10}
+ h_3 (\frac{v(0.6)+v(0.8)}{2}) + h_4 (\frac{v(0.8)+v(1.0)}{2}),\]</div>
<p>where</p>
<div class="math" id="eq-sec-integr-h1">
\[\tag{11}
h_1 = (0.2 - 0.0),\]</div>
<div class="math" id="eq-sec-integr-h2">
\[\tag{12}
h_2 = (0.6 - 0.2),\]</div>
<div class="math" id="eq-sec-integr-h3">
\[\tag{13}
h_3 = (0.8 - 0.6),\]</div>
<div class="math" id="eq-sec-integr-h4">
\[\tag{14}
h_4 = (1.0 - 0.8)\thinspace\]</div>
<p>With <span class="math">\(v(t) = 3t^{2}e^{t^3}\)</span>, each term in <a class="reference internal" href="#eq-sec-integr-trap-split"><span class="std std-ref">(10)</span></a> is readily computed and our approximate computation gives</p>
<div class="math" id="eq-sec-integr-trap-answer">
\[\tag{15}
\int_0^1 v(t)dt \approx 1.895\thinspace .\]</div>
<p>Compared to the true answer of <span class="math">\(1.718\)</span>, this is off by about
10%. However, note that we used just 4 trapezoids to approximate the
area. With more trapezoids, the approximation would have become
better, since the straight line segments in the upper trapezoid side
then would follow the graph more closely. Doing another hand
calculation with more trapezoids is not too tempting for a lazy human,
though, but it is a perfect job for a computer! Let us therefore
derive the expressions for approximating the integral
by an arbitrary number of trapezoids.</p>
<p>For a given function <span class="math">\(f(x)\)</span>, we want to approximate the
integral <span class="math">\(\int_a^bf(x)dx\)</span> by <span class="math">\(n\)</span> trapezoids (of equal width). We start out with
<a class="reference internal" href="#eq-eqfdx"><span class="std std-ref">(6)</span></a> and approximate each integral on the right hand side
with a single trapezoid. In detail,</p>
<div class="math">
\[\int_a^b f(x)\,dx = \int_{x_0}^{x_1} f(x) dx + \int_{x_1}^{x_2} f(x) dx + \ldots + \int_{x_{n-1}}^{x_n} f(x) dx,     \nonumber\]</div>
<div class="math">
\[\approx h \frac{f(x_0) + f(x_1)}{2} +
h \frac{f(x_1) + f(x_2)}{2} + \ldots + \nonumber\]</div>
<div class="math" id="eq-eqfdelta">
\[\tag{16}
\quad h \frac{f(x_{n-1}) + f(x_n)}{2}\]</div>
<p>By simplifying the right hand side of <a class="reference internal" href="#eq-eqfdelta"><span class="std std-ref">(16)</span></a> we get</p>
<div class="math" id="eq-eqn-314">
\[\tag{17}
\int_a^b f(x)\,dx \approx \\
    \frac{h}{2}\left[f(x_0) + 2 f(x_1) + 2 f(x_2) + \ldots + 2 f(x_{n-1}) + f(x_n)\right]\]</div>
<p>which is more compactly written as</p>
<div class="math" id="eq-eqn-315">
\[\tag{18}
\int_a^b f(x)\,dx \approx h \left[\frac{1}{2}f(x_0) + \sum_{i=1}^{n-1}f(x_i) + \frac{1}{2}f(x_n) \right] \thinspace .\]</div>
<div class="admonition-composite-integration-rules admonition">
<p class="first admonition-title">Composite integration rules</p>
<p class="last">The word <em>composite</em> is often used when a numerical integration method
is applied with more than one sub-interval. Strictly speaking then,
writing, e.g., &#8220;the trapezoidal method&#8221;, should imply the use of
only a single trapezoid, while &#8220;the composite trapezoidal method&#8221; is
the most correct name when several trapezoids are used.  However, this
naming convention is not always followed, so saying just &#8220;the
trapezoidal method&#8221; may point to a single trapezoid as well as the
composite rule with many trapezoids.</p>
</div>
<div class="section" id="specific-or-general-implementation">
<h3>Specific or general implementation?<a class="headerlink" href="#specific-or-general-implementation" title="Permalink to this headline">¶</a></h3>
<span class="target" id="index-7"></span><p id="index-8">Suppose our primary goal was to compute the specific integral
<span class="math">\(\int_0^1 v(t)dt\)</span> with <span class="math">\(v(t)=3t^2e^{t^3}\)</span>. First we played around with
a simple hand calculation to see what the method was about, before we
(as one often does in mathematics) developed a general formula
<a class="reference internal" href="#eq-eqn-315"><span class="std std-ref">(18)</span></a> for the general or &#8220;abstract&#8221; integral
<span class="math">\(\int_a^bf(x)dx\)</span>.  To solve our specific problem <span class="math">\(\int_0^1 v(t)dt\)</span> we
must then apply the general formula <a class="reference internal" href="#eq-eqn-315"><span class="std std-ref">(18)</span></a> to the given data
(function and integral limits) in our problem.  Although simple in
principle, the practical steps are confusing for many because the
notation in the abstract problem in <a class="reference internal" href="#eq-eqn-315"><span class="std std-ref">(18)</span></a> differs from the
notation in our special problem.  Clearly, the <span class="math">\(f\)</span>, <span class="math">\(x\)</span>, and <span class="math">\(h\)</span> in
<a class="reference internal" href="#eq-eqn-315"><span class="std std-ref">(18)</span></a> correspond to <span class="math">\(v\)</span>, <span class="math">\(t\)</span>, and perhaps <span class="math">\(\Delta t\)</span> for the
trapezoid width in our special problem.</p>
<div class="admonition-the-programmer-s-dilemma admonition">
<p class="first admonition-title">The programmer&#8217;s dilemma</p>
<ol class="arabic simple">
<li>Should we write a special program for the special integral,
using the ideas from the general rule <a class="reference internal" href="#eq-eqn-315"><span class="std std-ref">(18)</span></a>, but
replacing <span class="math">\(f\)</span> by <span class="math">\(v\)</span>, <span class="math">\(x\)</span> by <span class="math">\(t\)</span>, and <span class="math">\(h\)</span> by <span class="math">\(\Delta t\)</span>?</li>
<li>Should we implement the general method <a class="reference internal" href="#eq-eqn-315"><span class="std std-ref">(18)</span></a> as it stands in a
general function <code class="docutils literal"><span class="pre">trapezoid(f,</span> <span class="pre">a,</span> <span class="pre">b,</span> <span class="pre">n)</span></code> and solve the specific
problem at hand by a specialized call to this function?</li>
</ol>
<p class="last"><strong>Alternative 2 is always the best choice!</strong></p>
</div>
<p>The first alternative in the box above sounds less abstract and
therefore more attractive to many. Nevertheless, as we hope will be
evident from the examples, the second alternative is actually the
simplest <em>and</em> most reliable from both a mathematical and programming
point of view. These authors will claim that the second alternative
is the essence of the power of mathematics, while the first alternative
is the source of much confusion about mathematics!</p>
</div>
<div class="section" id="implementation-with-functions">
<h3>Implementation with functions<a class="headerlink" href="#implementation-with-functions" title="Permalink to this headline">¶</a></h3>
<p>For the integral <span class="math">\(\int_a^bf(x)dx\)</span> computed by the formula
<a class="reference internal" href="#eq-eqn-315"><span class="std std-ref">(18)</span></a> we want the corresponding Python function <code class="docutils literal"><span class="pre">trapezoid</span></code>
to take any <span class="math">\(f\)</span>, <span class="math">\(a\)</span>, <span class="math">\(b\)</span>, and <span class="math">\(n\)</span> as input and return the
approximation to the integral.</p>
<p>We write a Python function <code class="docutils literal"><span class="pre">trapezoidal</span></code>
in a file <a class="reference external" href="https://github.com/hplgit/prog4comp/tree/master/src/py/trapezoidal.py">trapezoidal.py</a>
as close as possible
to the formula <a class="reference internal" href="#eq-eqn-315"><span class="std std-ref">(18)</span></a>, making sure variable names correspond
to the mathematical notation:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">trapezoidal</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
    <span class="n">h</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">b</span><span class="o">-</span><span class="n">a</span><span class="p">)</span><span class="o">/</span><span class="n">n</span>
    <span class="n">result</span> <span class="o">=</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">+</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
        <span class="n">result</span> <span class="o">+=</span> <span class="n">f</span><span class="p">(</span><span class="n">a</span> <span class="o">+</span> <span class="n">i</span><span class="o">*</span><span class="n">h</span><span class="p">)</span>
    <span class="n">result</span> <span class="o">*=</span> <span class="n">h</span>
    <span class="k">return</span> <span class="n">result</span>
</pre></div>
</div>
</div>
<div class="section" id="solving-our-specific-problem-in-a-session">
<h3>Solving our specific problem in a session<a class="headerlink" href="#solving-our-specific-problem-in-a-session" title="Permalink to this headline">¶</a></h3>
<p>Just having the <code class="docutils literal"><span class="pre">trapezoidal</span></code> function as the only content
of a file <code class="docutils literal"><span class="pre">trapezoidal.py</span></code> automatically
makes that file a module that we can import and test in an
interactive session:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">trapezoidal</span> <span class="kn">import</span> <span class="n">trapezoidal</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">math</span> <span class="kn">import</span> <span class="n">exp</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">t</span><span class="p">:</span> <span class="mi">3</span><span class="o">*</span><span class="p">(</span><span class="n">t</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="n">exp</span><span class="p">(</span><span class="n">t</span><span class="o">**</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="mi">4</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">numerical</span> <span class="o">=</span> <span class="n">trapezoidal</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">numerical</span>
<span class="go">1.9227167504675762</span>
</pre></div>
</div>
<p>Let us compute the exact expression and the error in the approximation:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">V</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">t</span><span class="p">:</span> <span class="n">exp</span><span class="p">(</span><span class="n">t</span><span class="o">**</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">exact</span> <span class="o">=</span> <span class="n">V</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="n">V</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">exact</span> <span class="o">-</span> <span class="n">numerical</span>
<span class="go">-0.20443492200853108</span>
</pre></div>
</div>
<p>Is this error convincing? We can try a larger <span class="math">\(n\)</span>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">numerical</span> <span class="o">=</span> <span class="n">trapezoidal</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="mi">400</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">exact</span> <span class="o">-</span> <span class="n">numerical</span>
<span class="go">-2.1236490512777095e-05</span>
</pre></div>
</div>
<p>Fortunately, many more trapezoids give a much smaller error.</p>
</div>
<div class="section" id="solving-our-specific-problem-in-a-program">
<h3>Solving our specific problem in a program<a class="headerlink" href="#solving-our-specific-problem-in-a-program" title="Permalink to this headline">¶</a></h3>
<p>Instead of computing our special problem in an interactive session,
we can do it in a program. As always, a chunk of code doing a
particular thing is best isolated as a function even if we do
not see any future reason to call the function several times and
even if we have no need for arguments to parameterize what goes
on inside the function. In the present case, we just put the
statements we otherwise would have put in a main program, inside
a function:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">application</span><span class="p">():</span>
    <span class="kn">from</span> <span class="nn">math</span> <span class="kn">import</span> <span class="n">exp</span>
    <span class="n">v</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">t</span><span class="p">:</span> <span class="mi">3</span><span class="o">*</span><span class="p">(</span><span class="n">t</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="n">exp</span><span class="p">(</span><span class="n">t</span><span class="o">**</span><span class="mi">3</span><span class="p">)</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">input</span><span class="p">(</span><span class="s">&#39;n: &#39;</span><span class="p">)</span>
    <span class="n">numerical</span> <span class="o">=</span> <span class="n">trapezoidal</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>

    <span class="c"># Compare with exact result</span>
    <span class="n">V</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">t</span><span class="p">:</span> <span class="n">exp</span><span class="p">(</span><span class="n">t</span><span class="o">**</span><span class="mi">3</span><span class="p">)</span>
    <span class="n">exact</span> <span class="o">=</span> <span class="n">V</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="n">V</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">error</span> <span class="o">=</span> <span class="n">exact</span> <span class="o">-</span> <span class="n">numerical</span>
    <span class="k">print</span> <span class="s">&#39;n=</span><span class="si">%d</span><span class="s">: </span><span class="si">%.16f</span><span class="s">, error: </span><span class="si">%g</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">numerical</span><span class="p">,</span> <span class="n">error</span><span class="p">)</span>
</pre></div>
</div>
<p>Now we compute our special problem by calling <code class="docutils literal"><span class="pre">application()</span></code> as
the only statement in the main program.
Both the <code class="docutils literal"><span class="pre">trapezoidal</span></code> and <code class="docutils literal"><span class="pre">application</span></code> functions reside in the
file <code class="docutils literal"><span class="pre">trapezoidal.py</span></code>, which can be run as</p>
<div class="highlight-text"><div class="highlight"><pre>Terminal&gt; python trapezoidal.py
n: 4
n=4: 1.9227167504675762, error: -0.204435
</pre></div>
</div>
<div class="section" id="making-a-module">
<h4>Making a module<a class="headerlink" href="#making-a-module" title="Permalink to this headline">¶</a></h4>
<span class="target" id="index-9"></span><span class="target" id="index-10"></span><p id="index-11">When we have the different pieces of our program as a collection of
functions, it is very straightforward to create a <em>module</em> that can be
imported in other programs. That is, having our code as a module,
means that the <code class="docutils literal"><span class="pre">trapezoidal</span></code> function can easily be reused by other
programs to solve other problems. The requirements of a module are
simple: put everything inside functions and let function calls in the
main program be in the so-called <em>test block</em>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">application</span><span class="p">()</span>
</pre></div>
</div>
<p>The <code class="docutils literal"><span class="pre">if</span></code> test is true if the module file, <code class="docutils literal"><span class="pre">trapezoidal.py</span></code>, is run
as a program and false if the module is imported in another program.
Consequently, when we do an import <code class="docutils literal"><span class="pre">from</span> <span class="pre">trapezoidal</span> <span class="pre">import</span> <span class="pre">trapezoidal</span></code>
in some file, the test fails and <code class="docutils literal"><span class="pre">application()</span></code> is not called, i.e.,
our special problem is not solved and will not print anything on
the screen. On the other hand, if we run <code class="docutils literal"><span class="pre">trapezoidal.py</span></code> in the
terminal window, the test condition is positive, <code class="docutils literal"><span class="pre">application()</span></code>
is called, and we get output in the window:</p>
<div class="highlight-text"><div class="highlight"><pre>Terminal&gt; python trapezoidal.py
n: 400
n=400: 1.7183030649495579, error: -2.12365e-05
</pre></div>
</div>
</div>
<div class="section" id="alternative-flat-special-purpose-implementation">
<h4>Alternative flat special-purpose implementation<a class="headerlink" href="#alternative-flat-special-purpose-implementation" title="Permalink to this headline">¶</a></h4>
<span class="target" id="index-12"></span><span class="target" id="index-13"></span><p id="index-14">Let us illustrate the implementation implied by alternative 1
in the <em>Programmer&#8217;s dilemma</em> box in the section <span class="xref std std-ref">sec:integrals:trap:impl</span>.
That is, we make a special-purpose code where we adapt the
general formula <a class="reference internal" href="#eq-eqn-315"><span class="std std-ref">(18)</span></a>
to the specific problem <span class="math">\(\int_0^1 3t^2e^{t^3}dt\)</span>.</p>
<p>Basically, we use a <code class="docutils literal"><span class="pre">for</span></code> loop to compute the sum. Each term with <span class="math">\(f(x)\)</span> in
the formula <a class="reference internal" href="#eq-eqn-315"><span class="std std-ref">(18)</span></a> is replaced by <span class="math">\(3t^2e^{t^3}\)</span>, <span class="math">\(x\)</span> by <span class="math">\(t\)</span>,
and <span class="math">\(h\)</span> by <span class="math">\(\Delta t\)</span> <a class="footnote-reference" href="#deltat-replacement" id="id1">[1]</a>. A first try at writing a plain,
flat program doing the special calculation is</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">math</span> <span class="kn">import</span> <span class="n">exp</span>

<span class="n">a</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">;</span>  <span class="n">b</span> <span class="o">=</span> <span class="mf">1.0</span>
<span class="n">n</span> <span class="o">=</span> <span class="nb">input</span><span class="p">(</span><span class="s">&#39;n: &#39;</span><span class="p">)</span>
<span class="n">dt</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">b</span> <span class="o">-</span> <span class="n">a</span><span class="p">)</span><span class="o">/</span><span class="n">n</span>

<span class="c"># Integral by the trapezoidal method</span>
<span class="n">numerical</span> <span class="o">=</span> <span class="mf">0.5</span><span class="o">*</span><span class="mi">3</span><span class="o">*</span><span class="p">(</span><span class="n">a</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="n">exp</span><span class="p">(</span><span class="n">a</span><span class="o">**</span><span class="mi">3</span><span class="p">)</span> <span class="o">+</span> <span class="mf">0.5</span><span class="o">*</span><span class="mi">3</span><span class="o">*</span><span class="p">(</span><span class="n">b</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="n">exp</span><span class="p">(</span><span class="n">b</span><span class="o">**</span><span class="mi">3</span><span class="p">)</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
    <span class="n">numerical</span> <span class="o">+=</span> <span class="mi">3</span><span class="o">*</span><span class="p">((</span><span class="n">a</span> <span class="o">+</span> <span class="n">i</span><span class="o">*</span><span class="n">dt</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="n">exp</span><span class="p">((</span><span class="n">a</span> <span class="o">+</span> <span class="n">i</span><span class="o">*</span><span class="n">dt</span><span class="p">)</span><span class="o">**</span><span class="mi">3</span><span class="p">)</span>
<span class="n">numerical</span> <span class="o">*=</span> <span class="n">dt</span>

<span class="n">exact_value</span> <span class="o">=</span> <span class="n">exp</span><span class="p">(</span><span class="mi">1</span><span class="o">**</span><span class="mi">3</span><span class="p">)</span> <span class="o">-</span> <span class="n">exp</span><span class="p">(</span><span class="mi">0</span><span class="o">**</span><span class="mi">3</span><span class="p">)</span>
<span class="n">error</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">exact_value</span> <span class="o">-</span> <span class="n">numerical</span><span class="p">)</span>
<span class="n">rel_error</span> <span class="o">=</span> <span class="p">(</span><span class="n">error</span><span class="o">/</span><span class="n">exact_value</span><span class="p">)</span><span class="o">*</span><span class="mi">100</span>
<span class="k">print</span> <span class="s">&#39;n=</span><span class="si">%d</span><span class="s">: </span><span class="si">%.16f</span><span class="s">, error: </span><span class="si">%g</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">numerical</span><span class="p">,</span> <span class="n">error</span><span class="p">)</span>
</pre></div>
</div>
<table class="docutils footnote" frame="void" id="deltat-replacement" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[1]</a></td><td>Replacing <span class="math">\(h\)</span> by <span class="math">\(\Delta t\)</span> is not strictly
required as many use <span class="math">\(h\)</span> as interval also along the time axis.
Nevertheless, <span class="math">\(\Delta t\)</span> is an even more popular notation for
a small time interval, so we adopt that common notation.</td></tr>
</tbody>
</table>
<p>The problem with the above code is at least three-fold:</p>
<ol class="arabic simple">
<li>We need to reformulate <a class="reference internal" href="#eq-eqn-315"><span class="std std-ref">(18)</span></a> for our special
problem with a different notation.</li>
<li>The integrand <span class="math">\(3t^2e^{t^3}\)</span> is inserted many times in the
code, which quickly leads to errors.</li>
<li>A lot of edits are necessary to use the code to compute a different
integral - these edits are likely to introduce errors.</li>
</ol>
<p>The potential errors involved in point 2 serve to illustrate how important it is to use Python functions as mathematical functions. Here we have chosen to use the lambda function to define the integrand as the variable <code class="docutils literal"><span class="pre">v</span></code>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">math</span> <span class="kn">import</span> <span class="n">exp</span>

<span class="n">v</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">t</span><span class="p">:</span> <span class="mi">3</span><span class="o">*</span><span class="p">(</span><span class="n">t</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="n">exp</span><span class="p">(</span><span class="n">t</span><span class="o">**</span><span class="mi">3</span><span class="p">)</span>  <span class="c"># Function to be integrated</span>
<span class="n">a</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">;</span>  <span class="n">b</span> <span class="o">=</span> <span class="mf">1.0</span>
<span class="n">n</span> <span class="o">=</span> <span class="nb">input</span><span class="p">(</span><span class="s">&#39;n: &#39;</span><span class="p">)</span>
<span class="n">dt</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">b</span> <span class="o">-</span> <span class="n">a</span><span class="p">)</span><span class="o">/</span><span class="n">n</span>

<span class="c"># Integral by the trapezoidal method</span>
<span class="n">numerical</span> <span class="o">=</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">v</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">+</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">v</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
    <span class="n">numerical</span> <span class="o">+=</span> <span class="n">v</span><span class="p">(</span><span class="n">a</span> <span class="o">+</span> <span class="n">i</span><span class="o">*</span><span class="n">dt</span><span class="p">)</span>
<span class="n">numerical</span> <span class="o">*=</span> <span class="n">dt</span>

<span class="n">F</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">t</span><span class="p">:</span> <span class="n">exp</span><span class="p">(</span><span class="n">t</span><span class="o">**</span><span class="mi">3</span><span class="p">)</span>
<span class="n">exact_value</span> <span class="o">=</span> <span class="n">F</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="o">-</span> <span class="n">F</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="n">error</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">exact_value</span> <span class="o">-</span> <span class="n">numerical</span><span class="p">)</span>
<span class="n">rel_error</span> <span class="o">=</span> <span class="p">(</span><span class="n">error</span><span class="o">/</span><span class="n">exact_value</span><span class="p">)</span><span class="o">*</span><span class="mi">100</span>
<span class="k">print</span> <span class="s">&#39;n=</span><span class="si">%d</span><span class="s">: </span><span class="si">%.16f</span><span class="s">, error: </span><span class="si">%g</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">numerical</span><span class="p">,</span> <span class="n">error</span><span class="p">)</span>
</pre></div>
</div>
<p>Unfortunately, the two other problems remain and they are fundamental.</p>
<p>Suppose you want to compute another integral, say <span class="math">\(\int_{-1}^{1.1}e^{-x^2}dx\)</span>.
How much do we need to change in the previous code
to compute the new integral? Not so much:</p>
<blockquote>
<div><ul class="simple">
<li>the formula for <code class="docutils literal"><span class="pre">v</span></code> must be replaced by a new formula</li>
<li>the limits <code class="docutils literal"><span class="pre">a</span></code> and <code class="docutils literal"><span class="pre">b</span></code></li>
<li>the anti-derivative <span class="math">\(V\)</span> is not easily known <a class="footnote-reference" href="#erf" id="id2">[2]</a> and can be omitted,
and therefore we cannot write out the error</li>
<li>the notation should be changed to be aligned with the new problem, i.e.,
<code class="docutils literal"><span class="pre">t</span></code> and <code class="docutils literal"><span class="pre">dt</span></code> changed to <code class="docutils literal"><span class="pre">x</span></code> and <code class="docutils literal"><span class="pre">h</span></code></li>
</ul>
</div></blockquote>
<table class="docutils footnote" frame="void" id="erf" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id2">[2]</a></td><td>You cannot integrate <span class="math">\(e^{-x^2}\)</span> by hand, but this particular
integral is appearing so often in so many contexts that the integral
is a special function, called the <a class="reference external" href="http://en.wikipedia.org/wiki/Error_function">Error function</a> and written <span class="math">\(\mbox{erf}(x)\)</span>. In a code, you can
call <code class="docutils literal"><span class="pre">erf(x)</span></code>.
The <code class="docutils literal"><span class="pre">erf</span></code> function is found in the <code class="docutils literal"><span class="pre">math</span></code> module.</td></tr>
</tbody>
</table>
<p id="index-15">These changes are straightforward to implement, but <em>they are scattered
around in the program</em>, a fact that requires us to be very careful so
we do not introduce new programming errors while we modify the code.
It is also very easy to forget to make a required change.</p>
<p>With the previous code in <code class="docutils literal"><span class="pre">trapezoidal.py</span></code>, we can compute
the new integral <span class="math">\(\int_{-1}^{1.1}e^{-x^2}dx\)</span> <em>without touching
the mathematical algorithm</em>. In an interactive session (or
in a program) we can just do</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">trapezoidal</span> <span class="kn">import</span> <span class="n">trapezoidal</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">math</span> <span class="kn">import</span> <span class="n">exp</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">trapezoidal</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span><span class="p">),</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mf">1.1</span><span class="p">,</span> <span class="mi">400</span><span class="p">)</span>
<span class="go">1.5268823686123285</span>
</pre></div>
</div>
<p>When you now look back at the two solutions, the flat special-purpose
program and the function-based program with the general-purpose
function <code class="docutils literal"><span class="pre">trapezoidal</span></code>, you hopefully realize that <em>implementing
a general mathematical algorithm in a general function</em> requires
somewhat more abstract thinking, but the resulting code can be
used over and over again. Essentially, if you apply the flat
special-purpose style, you have to retest the implementation of
the algorithm after every change of the program.</p>
<p>The present integral problems result in short code.
In more challenging engineering problems the code quickly grows
to hundreds and thousands of line. Without abstractions in terms
of general algorithms in general reusable functions, the complexity
of the program grows so fast that it will be extremely difficult
to make sure that the program works properly.</p>
<p>Another advantage of packaging mathematical algorithms in functions
is that a function can be reused by anyone to solve
a problem by just calling the function with a proper set of arguments.
Understanding the function&#8217;s
inner details is not necessary to compute a new integral. Similarly,
you can find libraries of functions on the Internet and use these
functions to solve your problems without specific knowledge of
every mathematical detail in the functions.</p>
<p>This desirable feature has its downside, of course: the user of a
function may misuse it, and the function may contain programming
errors and lead to wrong answers. Testing the output of downloaded
functions is therefore extremely important before relying on the
results.</p>
</div>
</div>
</div>
<div class="section" id="the-composite-midpoint-method">
<span id="sec-integrals-midpoint"></span><h2>The composite midpoint method<a class="headerlink" href="#the-composite-midpoint-method" title="Permalink to this headline">¶</a></h2>
<span class="target" id="index-16"></span><div class="section" id="the-idea">
<span id="index-17"></span><h3>The idea<a class="headerlink" href="#the-idea" title="Permalink to this headline">¶</a></h3>
<p>Rather than approximating the area under a curve by trapezoids, we can
use plain rectangles. It may sound less accurate to use horizontal lines
and not skew lines following the function to be integrated, but
an integration method based on rectangles (the <em>midpoint method</em>) is in fact slightly more
accurate than the one based on trapezoids!</p>
<p>In the midpoint method, we construct a rectangle for every sub-interval
where the height equals <span class="math">\(f\)</span> at the midpoint of the sub-interval.
Let us do this for four rectangles, using the same sub-intervals as we
had for hand calculations with the trapezoidal method:
<span class="math">\([0,0.2)\)</span>, <span class="math">\([0.2,0.6)\)</span>, <span class="math">\([0.6,0.8)\)</span>, and <span class="math">\([0.8,1.0]\)</span>. We get</p>
<div class="math">
\[\int_0^1 f(t)dt \approx
   h_1 f\left(\frac{0 + 0.2}{2}\right) +
   h_2 f\left(\frac{0.2 + 0.6}{2}\right) \nonumber\]</div>
<div class="math" id="eq-sec-integr-midp-split">
\[\tag{19}
+ h_3 f\left(\frac{0.6 + 0.8}{2}\right) +
       h_4 f\left(\frac{0.8 + 1.0}{2}\right),\]</div>
<p>where <span class="math">\(h_1\)</span>, <span class="math">\(h_2\)</span>, <span class="math">\(h_3\)</span>, and <span class="math">\(h_4\)</span> are the widths of the sub-intervals,
used previously with the trapezoidal method and defined in
<a class="reference internal" href="#eq-sec-integr-h1"><span class="std std-ref">(11)</span></a>-<a class="reference internal" href="#eq-sec-integr-h4"><span class="std std-ref">(14)</span></a>.</p>
<div class="figure" id="id5">
<span id="fig-vcarmidpoint"></span><a class="reference internal image-reference" href="_images/viz_midpoint.png"><img alt="_images/viz_midpoint.png" src="_images/viz_midpoint.png" style="width: 400px;" /></a>
<p class="caption"><span class="caption-text"><em>Computing approximately the integral of a function as the sum of the areas of the rectangles</em></span></p>
</div>
<p>With <span class="math">\(f(t) = 3t^{2}e^{t^3}\)</span>, the approximation becomes <span class="math">\(1.632\)</span>.
Compared with the true answer (<span class="math">\(1.718\)</span>), this is about <span class="math">\(5\%\)</span> too
small, but it is better than what we got with the trapezoidal method
(<span class="math">\(10\%\)</span>) with the same sub-intervals. More rectangles give a
better approximation.</p>
<div class="section" id="the-general-formula-2">
<h4>The general formula<a class="headerlink" href="#the-general-formula-2" title="Permalink to this headline">¶</a></h4>
<p>Let us derive a formula for the midpoint method based on <span class="math">\(n\)</span> rectangles of equal width:</p>
<div class="math">
\[\int_a^b f(x)\,dx = \int_{x_0}^{x_1} f(x)dx + \int_{x_1}^{x_2} f(x)dx +
                     \ldots + \int_{x_{n-1}}^{x_n} f(x)dx,     \nonumber\]</div>
<div class="math" id="eq-sec-midp-general1">
\[\tag{20}
\approx h f\left(\frac{x_0 + x_1}{2}\right) +
                       h f\left(\frac{x_1 + x_2}{2}\right) + \ldots +
                       h f\left(\frac{x_{n-1} + x_n}{2}\right) ,\]</div>
<div class="math" id="eq-sec-midp-general2">
\[\tag{21}
\approx h \left(f\left(\frac{x_0 + x_1}{2}\right) +
                      f\left(\frac{x_1 + x_2}{2}\right) + \ldots +
                      f\left(\frac{x_{n-1} + x_n}{2}\right)\right)\thinspace .\]</div>
<p>This sum may be written more compactly as</p>
<div class="math" id="eq-sec-midpointformula">
\[\tag{22}
\int_a^b f(x) dx \approx h \sum_{i=0}^{n-1}f(x_i) ,\]</div>
<p>where <span class="math">\(x_i = \left(a + \frac{h}{2}\right) + ih\)</span>.</p>
</div>
<div class="section" id="implementation-2">
<span id="sec-midpoint-code"></span><h4>Implementation<a class="headerlink" href="#implementation-2" title="Permalink to this headline">¶</a></h4>
<p>We follow the advice and lessons learned from the implementation of
the trapezoidal method and make a function <code class="docutils literal"><span class="pre">midpoint(f,</span> <span class="pre">a,</span> <span class="pre">b,</span> <span class="pre">n)</span></code>
(in a file <a class="reference external" href="https://github.com/hplgit/prog4comp/tree/master/src/py/midpoint.py">midpoint.py</a>)
for implementing the general formula <a class="reference internal" href="#eq-sec-midpointformula"><span class="std std-ref">(22)</span></a>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">midpoint</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
    <span class="n">h</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">b</span><span class="o">-</span><span class="n">a</span><span class="p">)</span><span class="o">/</span><span class="n">n</span>
    <span class="n">result</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
        <span class="n">result</span> <span class="o">+=</span> <span class="n">f</span><span class="p">((</span><span class="n">a</span> <span class="o">+</span> <span class="n">h</span><span class="o">/</span><span class="mf">2.0</span><span class="p">)</span> <span class="o">+</span> <span class="n">i</span><span class="o">*</span><span class="n">h</span><span class="p">)</span>
    <span class="n">result</span> <span class="o">*=</span> <span class="n">h</span>
    <span class="k">return</span> <span class="n">result</span>
</pre></div>
</div>
<p>We can test the function as we explained for the similar <code class="docutils literal"><span class="pre">trapezoidal</span></code>
method. The error in our particular problem <span class="math">\(\int_0^1 3t^2e^{t^3}dt\)</span>
with four intervals is now about 0.1 in contrast to 0.2 for the
trapezoidal rule.  This is in fact not accidental: one can show
mathematically that the error of the midpoint method is a bit smaller
than for the trapezoidal method. The differences are seldom of any
practical importance, and on a laptop we can easily use <span class="math">\(n=10^6\)</span> and
get the answer with an error about <span class="math">\(10^{-12}\)</span> in a couple of seconds.</p>
</div>
<div class="section" id="comparing-the-trapezoidal-and-the-midpoint-methods">
<h4>Comparing the trapezoidal and the midpoint methods<a class="headerlink" href="#comparing-the-trapezoidal-and-the-midpoint-methods" title="Permalink to this headline">¶</a></h4>
<p>The next example shows how easy we can combine the <code class="docutils literal"><span class="pre">trapezoidal</span></code> and <code class="docutils literal"><span class="pre">midpoint</span></code>
functions to make a comparison of the two methods in the
file
<a class="reference external" href="https://github.com/hplgit/prog4comp/tree/master/src/py/compare_integration_methods.py">compare_integration_methods.py</a>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">trapezoidal</span> <span class="kn">import</span> <span class="n">trapezoidal</span>
<span class="kn">from</span> <span class="nn">midpoint</span> <span class="kn">import</span> <span class="n">midpoint</span>
<span class="kn">from</span> <span class="nn">math</span> <span class="kn">import</span> <span class="n">exp</span>

<span class="n">g</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">y</span><span class="p">:</span> <span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">y</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
<span class="n">a</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">b</span> <span class="o">=</span> <span class="mi">2</span>
<span class="k">print</span> <span class="s">&#39;    n        midpoint          trapezoidal&#39;</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">21</span><span class="p">):</span>
    <span class="n">n</span> <span class="o">=</span> <span class="mi">2</span><span class="o">**</span><span class="n">i</span>
    <span class="n">m</span> <span class="o">=</span> <span class="n">midpoint</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
    <span class="n">t</span> <span class="o">=</span> <span class="n">trapezoidal</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
    <span class="k">print</span> <span class="s">&#39;</span><span class="si">%7d</span><span class="s"> </span><span class="si">%.16f</span><span class="s"> </span><span class="si">%.16f</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span>
</pre></div>
</div>
<p>Note the efforts put into nice formatting - the output becomes</p>
<div class="highlight-text"><div class="highlight"><pre>    n        midpoint          trapezoidal
      2 0.8842000076332692 0.8770372606158094
      4 0.8827889485397279 0.8806186341245393
      8 0.8822686991994210 0.8817037913321336
     16 0.8821288703366458 0.8819862452657772
     32 0.8820933014203766 0.8820575578012112
     64 0.8820843709743319 0.8820754296107942
    128 0.8820821359746071 0.8820799002925637
    256 0.8820815770754198 0.8820810181335849
    512 0.8820814373412922 0.8820812976045025
   1024 0.8820814024071774 0.8820813674728968
   2048 0.8820813936736116 0.8820813849400392
   4096 0.8820813914902204 0.8820813893068272
   8192 0.8820813909443684 0.8820813903985197
  16384 0.8820813908079066 0.8820813906714446
  32768 0.8820813907737911 0.8820813907396778
  65536 0.8820813907652575 0.8820813907567422
 131072 0.8820813907631487 0.8820813907610036
 262144 0.8820813907625702 0.8820813907620528
 524288 0.8820813907624605 0.8820813907623183
1048576 0.8820813907624268 0.8820813907623890
</pre></div>
</div>
<p>A visual inspection of the numbers shows how fast the digits
stabilize in both methods. It appears that 13 digits have stabilized
in the last two rows.</p>
<span class="target" id="index-18"></span><div class="admonition-remark admonition" id="index-19">
<p class="first admonition-title">Remark</p>
<p>The trapezoidal and midpoint methods are just two examples in a jungle
of numerical integration rules. Other famous methods are
Simpson&#8217;s rule and Gauss quadrature. They all work in the same way:</p>
<div class="math">
\[\int_a^b f(x)dx \approx \sum_{i=0}^{n-1} w_if(x_i)\thinspace .\]</div>
<p class="last">That is, the integral is approximated by a sum of function
evaluations, where each evaluation <span class="math">\(f(x_i)\)</span> is given a weight <span class="math">\(w_i\)</span>.
The different methods differ in the way they construct the
evaluation points <span class="math">\(x_i\)</span> and the weights <span class="math">\(w_i\)</span>.
We have used equally spaced points <span class="math">\(x_i\)</span>, but higher accuracy can be
obtained by optimizing the location of <span class="math">\(x_i\)</span>.</p>
</div>
</div>
</div>
</div>
<div class="section" id="testing">
<h2>Testing<a class="headerlink" href="#testing" title="Permalink to this headline">¶</a></h2>
<p>Testing of the programs for numerical integration has so far employed
two strategies. If we have an exact answer, we compute the error and
see that increasing <span class="math">\(n\)</span> decreases the error. When the exact answer is
not available, we can (as in the comparison example in the previous
section) look at the integral values and see that they stabilize as
<span class="math">\(n\)</span> grows. Unfortunately, these are very weak test procedures and not
at all satisfactory for claiming that the software we have produced is
correctly implemented.</p>
<p id="index-20">To see this, we can introduce a bug in the
<code class="docutils literal"><span class="pre">application</span></code> function that calls <code class="docutils literal"><span class="pre">trapezoidal</span></code>: instead of
integrating <span class="math">\(3t^2e^{t^3}\)</span>, we write &#8220;accidentally&#8221; <span class="math">\(3t^3e^{t^3}\)</span>,
but keep the same anti-derivative <span class="math">\(V(t)e^{t^3}\)</span> for computing the
error.  With the bug and <span class="math">\(n=4\)</span>, the error is 0.1, but without the bug
the error is 0.2!  It is of course completely impossible to tell if
0.1 is the right value of the error. Fortunately, increasing <span class="math">\(n\)</span> shows
that the error stays about 0.3 in the program with the bug, so
the test procedure with increasing <span class="math">\(n\)</span> and checking that the error
decreases points to a problem in the code.</p>
<p>Let us look at another bug, this time in the mathematical algorithm:
instead of computing <span class="math">\(\frac{1}{2}(f(a) + f(b))\)</span> as we should, we
forget the second <span class="math">\(\frac{1}{2}\)</span> and write <code class="docutils literal"><span class="pre">0.5*f(a)</span> <span class="pre">+</span> <span class="pre">f(b)</span></code>.  The error for
<span class="math">\(n=4,40,400\)</span> when computing
<span class="math">\(\int_{1.1}^{1.9} 3t^2e^{t^3}dt\)</span> goes like <span class="math">\(1400\)</span>, <span class="math">\(107\)</span>, <span class="math">\(10\)</span>,
respectively, which looks promising.  The problem is that
the right errors should be <span class="math">\(369\)</span>, <span class="math">\(4.08\)</span>, and
<span class="math">\(0.04\)</span>. That is, the error should be reduced faster in the
correct than in the buggy code. The problem, however, is that it is
reduced in both codes, and we may stop further testing and believe
everything is correctly implemented.</p>
<div class="admonition-unit-testing admonition" id="index-21">
<p class="first admonition-title">Unit testing</p>
<p class="last">A good habit is to test small pieces of a larger code individually, one at a time.
This is known as <em>unit testing</em>. One identifies a (small) unit of
the code, and then one makes a separate test for this unit. The unit test
should be stand-alone in the sense that it can be run without the
outcome of other tests. Typically, one algorithm
in scientific programs is considered as a unit. The challenge
with unit tests in numerical computing is to deal with numerical
approximation errors. A fortunate side effect of unit testing is that
the programmer is forced to use functions to modularize the code into smaller,
logical pieces.</p>
</div>
<p id="index-22">There are three serious ways to test the implementation of
numerical methods via unit tests:</p>
<ol class="arabic simple">
<li><em>Comparing with hand-computed results</em> in a problem with
few arithmetic operations, i.e., small <span class="math">\(n\)</span>.</li>
<li><em>Solving a problem without numerical errors</em>. We know that the trapezoidal
rule must be exact for linear functions. The error produced
by the program must then be zero (to machine precision).</li>
<li><em>Demonstrating correct convergence rates</em>. A strong test when we can
compute exact errors, is to see how fast the error goes
to zero as <span class="math">\(n\)</span> grows. In the trapezoidal and midpoint rules
it is known that the error depends on <span class="math">\(n\)</span> as <span class="math">\(n^{-2}\)</span> as
<span class="math">\(n\rightarrow\infty\)</span>.</li>
</ol>
<div class="section" id="hand-computed-results">
<h3>Hand-computed results<a class="headerlink" href="#hand-computed-results" title="Permalink to this headline">¶</a></h3>
<p>Let us use two trapezoids and compute the integral <span class="math">\(\int_0^1v(t)\)</span>,
<span class="math">\(v(t)=3t^2e^{t^3}\)</span>:</p>
<div class="math">
\[\frac{1}{2}h(v(0) + v(0.5)) + \frac{1}{2}h(v(0.5)+v(1)) = 2.463642041244344,\]</div>
<p>when <span class="math">\(h=0.5\)</span> is the width of the two trapezoids. Running the program
gives exactly the same results.</p>
</div>
<div class="section" id="solving-a-problem-without-numerical-errors-1">
<h3>Solving a problem without numerical errors<a class="headerlink" href="#solving-a-problem-without-numerical-errors-1" title="Permalink to this headline">¶</a></h3>
<p>The best unit tests for numerical algorithms involve mathematical
problems where we know the numerical result beforehand. Usually,
numerical results contain unknown approximation errors, so knowing the
numerical result implies that we have a problem where the
approximation errors vanish. This feature may be present in very
simple mathematical problems. For example, the trapezoidal method is
exact for integration of linear functions <span class="math">\(f(x)=ax+b\)</span>. We can
therefore pick some linear function and construct a test function that
checks equality between the exact analytical expression for the
integral and the number computed by the implementation of the
trapezoidal method.</p>
<p>A specific test case can be <span class="math">\(\int_{1.2}^{4.4} (6x-4)dx\)</span>. This
integral involves an &#8220;arbitrary&#8221; interval  <span class="math">\([1.2, 4.4]\)</span> and
an &#8220;arbitrary&#8221; linear function <span class="math">\(f(x) = 6x-4\)</span>. By &#8220;arbitrary&#8221;
we mean expressions where we avoid the special numbers 0 and 1 since
these have special properties in arithmetic operations (e.g.,
forgetting to multiply is equivalent to multiplying by 1, and
forgetting to add is equivalent to adding 0).</p>
</div>
<div class="section" id="demonstrating-correct-convergence-rates-1">
<h3>Demonstrating correct convergence rates<a class="headerlink" href="#demonstrating-correct-convergence-rates-1" title="Permalink to this headline">¶</a></h3>
<span class="target" id="index-23"></span><span class="target" id="index-24"></span><p id="index-25">Normally, unit tests must be based on problems where the numerical
approximation errors in our implementation remain unknown. However, we
often know or may assume a certain <em>asymptotic</em> behavior of the error.
We can do some experimental runs with the test problem <span class="math">\(\int_0^1
3t^2e^{t^3}dt\)</span> where <span class="math">\(n\)</span> is doubled in each run: <span class="math">\(n=4,8,16\)</span>. The
corresponding errors are then 12%, 3% and 0.77%, respectively. These
numbers indicate that the error is roughly reduced by a factor of 4
when doubling <span class="math">\(n\)</span>. Thus, the error converges to zero as <span class="math">\(n^{-2}\)</span> and
we say that the <em>convergence rate</em> is 2. In
fact, this result can also be shown mathematically for the trapezoidal
and midpoint method.  Numerical integration methods usually have an error
that converge to zero as <span class="math">\(n^{-p}\)</span> for some <span class="math">\(p\)</span> that depends on the
method. With such a result, it does not matter if we do not know what
the actual approximation error is: we know at what rate it is
<em>reduced</em>, so running the implementation for two or more different <span class="math">\(n\)</span>
values will put us in a position to measure the expected rate and see if
it is achieved.</p>
<p>The idea of a corresponding unit test is then to run the algorithm for some <span class="math">\(n\)</span> values,
compute the error (the absolute value of the difference between the
exact analytical result and the one produced by the numerical method),
and check that the error has <em>approximately</em> correct asymptotic
behavior, i.e., that the error is proportional to <span class="math">\(n^{-2}\)</span> in case of
the trapezoidal and midpoint method.</p>
<p>Let us develop a more precise method for such unit tests based on
convergence rates.  We assume that the error <span class="math">\(E\)</span> depends on <span class="math">\(n\)</span>
according to</p>
<div class="math">
\[E = Cn^r,\]</div>
<p>where <span class="math">\(C\)</span> is an unknown constant and <span class="math">\(r\)</span> is the convergence rate.
Consider a set of experiments with various <span class="math">\(n\)</span>:
<span class="math">\(n_0, n_1, n_2, \ldots,n_q\)</span>.
We compute the corresponding errors
<span class="math">\(E_0,\ldots,E_q\)</span>.
For two consecutive experiments, number <span class="math">\(i\)</span> and <span class="math">\(i-1\)</span>,
we have the error model</p>
<div class="math" id="eq-auto2">
\[\tag{23}
E_{i} = Cn_{i}^r,\]</div>
<div class="math" id="eq-auto3">
\[\tag{24}
E_{i-1} = Cn_{i-1}^r\thinspace .\]</div>
<p>These are two equations for two unknowns <span class="math">\(C\)</span> and <span class="math">\(r\)</span>.
We can easily eliminate <span class="math">\(C\)</span> by dividing the equations by each other.
Then solving for <span class="math">\(r\)</span> gives</p>
<div class="math" id="eq-sec-integrals-testprocs-req">
\[\tag{25}
r_{i-1} = \frac{\ln (E_i/E_{i-1})}{\ln (n_i/n_{i-1})}\thinspace .\]</div>
<p>We have introduced a subscript <span class="math">\(i-1\)</span> in <span class="math">\(r\)</span>
since the estimated
value for <span class="math">\(r\)</span> varies with <span class="math">\(i\)</span>. Hopefully,
<span class="math">\(r_{i-1}\)</span> approaches
the correct convergence rate as the number of intervals increases
and <span class="math">\(i\rightarrow q\)</span>.</p>
<div class="section" id="finite-precision-of-floating-point-numbers">
<span id="sec-integrals-finite-prec"></span><h4>Finite precision of floating-point numbers<a class="headerlink" href="#finite-precision-of-floating-point-numbers" title="Permalink to this headline">¶</a></h4>
<p id="index-26">The test procedures above lead to comparison of numbers for checking that
calculations were correct.
Such comparison is more complicated than what a newcomer might think.
Suppose we have a calculation <code class="docutils literal"><span class="pre">a</span> <span class="pre">+</span> <span class="pre">b</span></code> and want to check that the
result is what we expect. We start with 1 + 2:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span> <span class="n">expected</span> <span class="o">=</span> <span class="mi">3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">+</span> <span class="n">b</span> <span class="o">==</span> <span class="n">expected</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Then we proceed with 0.1 + 0.2:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="mf">0.1</span><span class="p">;</span> <span class="n">b</span> <span class="o">=</span> <span class="mf">0.2</span><span class="p">;</span> <span class="n">expected</span> <span class="o">=</span> <span class="mf">0.3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">+</span> <span class="n">b</span> <span class="o">==</span> <span class="n">expected</span>
<span class="go">False</span>
</pre></div>
</div>
<p id="index-27">So why is <span class="math">\(0.1 + 0.2 \neq 0.3\)</span>? The reason is that real numbers cannot in
general be exactly represented on a computer. They must instead be
approximated by a <a class="reference external" href="https://en.wikipedia.org/wiki/Floating_point">floating-point number</a> that can only store a finite amount of information, usually about
17 digits of a real number. Let us print 0.1, 0.2, 0.1 + 0.2, and 0.3
with 17 decimals:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="s">&#39;</span><span class="si">%.17f</span><span class="se">\n</span><span class="si">%.17f</span><span class="se">\n</span><span class="si">%.17f</span><span class="se">\n</span><span class="si">%.17f</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.1</span> <span class="o">+</span> <span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">)</span>
<span class="go">0.10000000000000001</span>
<span class="go">0.20000000000000001</span>
<span class="go">0.30000000000000004</span>
<span class="go">0.29999999999999999</span>
</pre></div>
</div>
<p>We see that all of the numbers have an inaccurate digit in the 17th
decimal place. Because 0.1 + 0.2 evaluates to 0.30000000000000004
and 0.3 is represented as 0.29999999999999999, these two numbers
are not equal. In general, real numbers in Python have (at most)
16 correct decimals.</p>
<span class="target" id="index-28"></span><p id="index-29">When we compute with real numbers, these numbers are inaccurately
represented on the computer, and arithmetic operations with inaccurate
numbers lead to small rounding errors in the final results. Depending on
the type of numerical algorithm, the rounding errors may or may not
accumulate.</p>
<p>If we cannot make tests like <code class="docutils literal"><span class="pre">0.1</span> <span class="pre">+</span> <span class="pre">0.2</span> <span class="pre">==</span> <span class="pre">0.3</span></code>, what should we then do?
The answer is that we must accept some small inaccuracy and make
a test with a <em>tolerance</em>. Here is the recipe:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="mf">0.1</span><span class="p">;</span> <span class="n">b</span> <span class="o">=</span> <span class="mf">0.2</span><span class="p">;</span> <span class="n">expected</span> <span class="o">=</span> <span class="mf">0.3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">computed</span> <span class="o">=</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">diff</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">expected</span> <span class="o">-</span> <span class="n">computed</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">tol</span> <span class="o">=</span> <span class="mf">1E-15</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">diff</span> <span class="o">&lt;</span> <span class="n">tol</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Here we have set the tolerance for comparison to <span class="math">\(10^{-15}\)</span>, but
calculating <code class="docutils literal"><span class="pre">0.3</span> <span class="pre">-</span> <span class="pre">(0.1</span> <span class="pre">+</span> <span class="pre">0.2)</span></code> shows that it equals
<code class="docutils literal"><span class="pre">-5.55e-17</span></code>, so a lower tolerance
could be used in this particular example. However, in other calculations
we have little idea about how accurate the answer is (there could be
accumulation of rounding errors in more complicated algorithms),
so <span class="math">\(10^{-15}\)</span> or <span class="math">\(10^{-14}\)</span> are robust values.
As we demonstrate below, these tolerances depend on the magnitude of
the numbers in the calculations.</p>
<span class="target" id="index-30"></span><p id="index-31">Doing an experiment with <span class="math">\(10^k + 0.3 - (10^k + 0.1 + 0.2)\)</span> for
<span class="math">\(k=1,\ldots,10\)</span> shows that the answer (which should be zero)
is around <span class="math">\(10^{16-k}\)</span>. This means that the tolerance must be larger
if we compute with larger numbers. Setting a proper tolerance therefore
requires some experiments to see what level of accuracy one can expect.
A way out of this difficulty is to work with <em>relative</em> instead of
<em>absolute</em> differences. In a relative difference we divide by one of
the operands, e.g.,</p>
<div class="math">
\[a = 10^k + 0.3,\quad b = (10^k + 0.1 + 0.2),\quad c = \frac{a - b}{a}\thinspace .\]</div>
<p>Computing this <span class="math">\(c\)</span> for various <span class="math">\(k\)</span> shows a value around <span class="math">\(10^{-16}\)</span>.
A safer procedure is thus to use <em>relative differences</em>.</p>
</div>
<div class="section" id="constructing-unit-tests-and-writing-test-functions">
<span id="sec-integrals-test-functions"></span><h4>Constructing unit tests and writing test functions<a class="headerlink" href="#constructing-unit-tests-and-writing-test-functions" title="Permalink to this headline">¶</a></h4>
<span class="target" id="index-32"></span><p id="index-33">Python has several frameworks for automatically running and checking a
potentially very large number of tests for parts of your software by
one command.
This is an extremely useful feature during program
development: whenever you have done some changes to one or more files,
launch the test command and make sure nothing is broken because of
your edits.</p>
<span class="target" id="index-34"></span><span class="target" id="index-35"></span><p id="index-36">The test frameworks <code class="docutils literal"><span class="pre">nose</span></code> and <code class="docutils literal"><span class="pre">py.test</span></code> are particularly attractive
as they are very easy to use.
Tests are placed in special <em>test functions</em>
that the frameworks can recognize and run for you. The requirements
to a test function are simple:</p>
<blockquote>
<div><ul class="simple">
<li>the name must start with <code class="docutils literal"><span class="pre">test_</span></code></li>
<li>the test function cannot have any arguments</li>
<li>the tests inside test functions must be boolean expressions</li>
<li>a boolean expression <code class="docutils literal"><span class="pre">b</span></code> must be tested with <code class="docutils literal"><span class="pre">assert</span> <span class="pre">b,</span> <span class="pre">msg</span></code>,
where <code class="docutils literal"><span class="pre">msg</span></code> is an optional object (string or number) to be written out
when <code class="docutils literal"><span class="pre">b</span></code> is false</li>
</ul>
</div></blockquote>
<p>Suppose we have written a function</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">add</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span>
</pre></div>
</div>
<p>A corresponding test function can then be</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">test_add</span><span class="p">()</span>
    <span class="n">expected</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="n">computed</span> <span class="o">=</span> <span class="n">add</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">computed</span> <span class="o">==</span> <span class="n">expected</span><span class="p">,</span> <span class="s">&#39;1+1=</span><span class="si">%g</span><span class="s">&#39;</span> <span class="o">%</span> <span class="n">computed</span>
</pre></div>
</div>
<p>Test functions can be in any program file or in separate files,
typically with names starting with <code class="docutils literal"><span class="pre">test</span></code>. You can also collect
tests in subdirectories: running <code class="docutils literal"><span class="pre">py.test</span> <span class="pre">-s</span> <span class="pre">-v</span></code> will actually
run all tests in all <code class="docutils literal"><span class="pre">test*.py</span></code> files in all subdirectories, while
<code class="docutils literal"><span class="pre">nosetests</span> <span class="pre">-s</span> <span class="pre">-v</span></code> restricts the attention to subdirectories whose
names start with <code class="docutils literal"><span class="pre">test</span></code> or end with <code class="docutils literal"><span class="pre">_test</span></code> or <code class="docutils literal"><span class="pre">_tests</span></code>.</p>
<p>As long as we add integers, the equality test in the <code class="docutils literal"><span class="pre">test_add</span></code>
function is appropriate, but if we try to call <code class="docutils literal"><span class="pre">add(0.1,</span> <span class="pre">0.2)</span></code>
instead, we will face the rounding error problems explained in
the section <a class="reference internal" href="#sec-integrals-finite-prec"><span class="std std-ref">Finite precision of floating-point numbers</span></a>, and we must use a test
with tolerance instead:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">test_add</span><span class="p">()</span>
    <span class="n">expected</span> <span class="o">=</span> <span class="mf">0.3</span>
    <span class="n">computed</span> <span class="o">=</span> <span class="n">add</span><span class="p">(</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">)</span>
    <span class="n">tol</span> <span class="o">=</span> <span class="mf">1E-14</span>
    <span class="n">diff</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">expected</span> <span class="o">-</span> <span class="n">computed</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">diff</span> <span class="o">&lt;</span> <span class="n">tol</span><span class="p">,</span> <span class="s">&#39;diff=</span><span class="si">%g</span><span class="s">&#39;</span> <span class="o">%</span> <span class="n">diff</span>
</pre></div>
</div>
<p>Below we shall write test functions for each of the three test
procedures we suggested: comparison with hand calculations,
checking problems that can be exactly solved, and checking convergence
rates. We stick to testing the trapezoidal integration code and collect all
test functions in one common file by the name <code class="docutils literal"><span class="pre">test_trapezoidal.py</span></code>.</p>
</div>
</div>
<div class="section" id="hand-computed-numerical-results">
<h3>Hand-computed numerical results<a class="headerlink" href="#hand-computed-numerical-results" title="Permalink to this headline">¶</a></h3>
<p>Our previous hand calculations for two trapezoids can be checked against
the <code class="docutils literal"><span class="pre">trapezoidal</span></code> function inside a test function
(in a file <a class="reference external" href="https://github.com/hplgit/prog4comp/tree/master/src/py/test_trapezoidal.py">test_trapezoidal.py</a>):</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">trapezoidal</span> <span class="kn">import</span> <span class="n">trapezoidal</span>

<span class="k">def</span> <span class="nf">test_trapezoidal_one_exact_result</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;Compare one hand-computed result.&quot;&quot;&quot;</span>
    <span class="kn">from</span> <span class="nn">math</span> <span class="kn">import</span> <span class="n">exp</span>
    <span class="n">v</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">t</span><span class="p">:</span> <span class="mi">3</span><span class="o">*</span><span class="p">(</span><span class="n">t</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="n">exp</span><span class="p">(</span><span class="n">t</span><span class="o">**</span><span class="mi">3</span><span class="p">)</span>
    <span class="n">n</span> <span class="o">=</span> <span class="mi">2</span>
    <span class="n">computed</span> <span class="o">=</span> <span class="n">trapezoidal</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
    <span class="n">expected</span> <span class="o">=</span> <span class="mf">2.463642041244344</span>
    <span class="n">error</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">expected</span> <span class="o">-</span> <span class="n">computed</span><span class="p">)</span>
    <span class="n">tol</span> <span class="o">=</span> <span class="mf">1E-14</span>
    <span class="n">success</span> <span class="o">=</span> <span class="n">error</span> <span class="o">&lt;</span> <span class="n">tol</span>
    <span class="n">msg</span> <span class="o">=</span> <span class="s">&#39;error=</span><span class="si">%g</span><span class="s"> &gt; tol=</span><span class="si">%g</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">errror</span><span class="p">,</span> <span class="n">tol</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">success</span><span class="p">,</span> <span class="n">msg</span>
</pre></div>
</div>
<p>Note the importance of checking <code class="docutils literal"><span class="pre">err</span></code> against <code class="docutils literal"><span class="pre">exact</span></code> with a tolerance:
rounding errors from the arithmetics inside <code class="docutils literal"><span class="pre">trapezoidal</span></code> will not
make the result exactly like the hand-computed one. The size of
the tolerance is here set to <span class="math">\(10^{-14}\)</span>, which is a kind of all-round
value for computations with numbers not deviating much from unity.</p>
</div>
<div class="section" id="solving-a-problem-without-numerical-errors-2">
<h3>Solving a problem without numerical errors<a class="headerlink" href="#solving-a-problem-without-numerical-errors-2" title="Permalink to this headline">¶</a></h3>
<p>We know that the trapezoidal rule is exact for linear integrands.
Choosing the integral <span class="math">\(\int_{1.2}^{4.4} (6x-4)dx\)</span> as test case,
the corresponding
test function for this unit test may look like</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">test_trapezoidal_linear</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;Check that linear functions are integrated exactly.&quot;&quot;&quot;</span>
    <span class="n">f</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="mi">6</span><span class="o">*</span><span class="n">x</span> <span class="o">-</span> <span class="mi">4</span>
    <span class="n">F</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="mi">3</span><span class="o">*</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="mi">4</span><span class="o">*</span><span class="n">x</span>  <span class="c"># Anti-derivative</span>
    <span class="n">a</span> <span class="o">=</span> <span class="mf">1.2</span><span class="p">;</span> <span class="n">b</span> <span class="o">=</span> <span class="mf">4.4</span>
    <span class="n">expected</span> <span class="o">=</span> <span class="n">F</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="o">-</span> <span class="n">F</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="n">tol</span> <span class="o">=</span> <span class="mf">1E-14</span>
    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">21</span><span class="p">:</span>
        <span class="n">computed</span> <span class="o">=</span> <span class="n">trapezoidal</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
        <span class="n">error</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">expected</span> <span class="o">-</span> <span class="n">computed</span><span class="p">)</span>
        <span class="n">success</span> <span class="o">=</span> <span class="n">error</span> <span class="o">&lt;</span> <span class="n">tol</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="s">&#39;n=</span><span class="si">%d</span><span class="s">, err=</span><span class="si">%g</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">error</span><span class="p">)</span>
        <span class="k">assert</span> <span class="n">success</span><span class="p">,</span> <span class="n">msg</span>
</pre></div>
</div>
</div>
<div class="section" id="demonstrating-correct-convergence-rates-2">
<h3>Demonstrating correct convergence rates<a class="headerlink" href="#demonstrating-correct-convergence-rates-2" title="Permalink to this headline">¶</a></h3>
<p>In the present example with integration, it is known that the
approximation errors in the trapezoidal rule are proportional to
<span class="math">\(n^{-2}\)</span>, <span class="math">\(n\)</span> being the number of subintervals used in the composite
rule.</p>
<p>Computing convergence rates requires somewhat more tedious programming than
the previous tests, but can be applied to more general integrands.
The algorithm typically goes like</p>
<blockquote>
<div><ul class="simple">
<li>for <span class="math">\(i=0,1,2,\ldots,q\)</span><ul>
<li><span class="math">\(n_i = 2^{i+1}\)</span></li>
<li>Compute integral with <span class="math">\(n_i\)</span> intervals</li>
<li>Compute the error <span class="math">\(E_i\)</span></li>
<li>Estimate <span class="math">\(r_i\)</span> from <a class="reference internal" href="#eq-sec-integrals-testprocs-req"><span class="std std-ref">(25)</span></a>
if <span class="math">\(i&gt;0\)</span></li>
</ul>
</li>
</ul>
</div></blockquote>
<p>The corresponding code may look like</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">convergence_rates</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">F</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">num_experiments</span><span class="o">=</span><span class="mi">14</span><span class="p">):</span>
    <span class="kn">from</span> <span class="nn">math</span> <span class="kn">import</span> <span class="n">log</span>
    <span class="kn">from</span> <span class="nn">numpy</span> <span class="kn">import</span> <span class="n">zeros</span>
    <span class="n">expected</span> <span class="o">=</span> <span class="n">F</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="o">-</span> <span class="n">F</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">(</span><span class="n">num_experiments</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
    <span class="n">E</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">(</span><span class="n">num_experiments</span><span class="p">)</span>
    <span class="n">r</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">(</span><span class="n">num_experiments</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_experiments</span><span class="p">):</span>
        <span class="n">n</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span><span class="o">**</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">computed</span> <span class="o">=</span> <span class="n">trapezoidal</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">n</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="n">E</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">expected</span> <span class="o">-</span> <span class="n">computed</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">r_im1</span> <span class="o">=</span> <span class="n">log</span><span class="p">(</span><span class="n">E</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">/</span><span class="n">E</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span><span class="o">/</span><span class="n">log</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">n</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="o">/</span><span class="n">n</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">r</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="s">&#39;</span><span class="si">%.2f</span><span class="s">&#39;</span> <span class="o">%</span> <span class="n">r_im1</span><span class="p">)</span> <span class="c"># Truncate to two decimals</span>
    <span class="k">return</span> <span class="n">r</span>
</pre></div>
</div>
<p>Making a test function is a matter of choosing <code class="docutils literal"><span class="pre">f</span></code>, <code class="docutils literal"><span class="pre">F</span></code>, <code class="docutils literal"><span class="pre">a</span></code>, and <code class="docutils literal"><span class="pre">b</span></code>,
and then checking the value of <span class="math">\(r_i\)</span> for the largest <span class="math">\(i\)</span>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">test_trapezoidal_conv_rate</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;Check empirical convergence rates against the expected -2.&quot;&quot;&quot;</span>
    <span class="kn">from</span> <span class="nn">math</span> <span class="kn">import</span> <span class="n">exp</span>
    <span class="n">v</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">t</span><span class="p">:</span> <span class="mi">3</span><span class="o">*</span><span class="p">(</span><span class="n">t</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="n">exp</span><span class="p">(</span><span class="n">t</span><span class="o">**</span><span class="mi">3</span><span class="p">)</span>
    <span class="n">V</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">t</span><span class="p">:</span> <span class="n">exp</span><span class="p">(</span><span class="n">t</span><span class="o">**</span><span class="mi">3</span><span class="p">)</span>
    <span class="n">a</span> <span class="o">=</span> <span class="mf">1.1</span><span class="p">;</span> <span class="n">b</span> <span class="o">=</span> <span class="mf">1.9</span>
    <span class="n">r</span> <span class="o">=</span> <span class="n">convergence_rates</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="mi">14</span><span class="p">)</span>
    <span class="k">print</span> <span class="n">r</span>
    <span class="n">tol</span> <span class="o">=</span> <span class="mf">0.01</span>
    <span class="n">msg</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">r</span><span class="p">[</span><span class="o">-</span><span class="mi">4</span><span class="p">:])</span>  <span class="c"># show last 4 estimated rates</span>
    <span class="k">assert</span> <span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">r</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">tol</span><span class="p">,</span> <span class="n">msg</span>
</pre></div>
</div>
<p>Running the test shows that all <span class="math">\(r_i\)</span>, except the first one, equal
the target limit 2 within two decimals. This observation suggest a
tolerance of <span class="math">\(10^{-2}\)</span>.</p>
<div class="admonition-remark-about-version-control-of-files admonition">
<p class="first admonition-title">Remark about version control of files</p>
<p>Having a suite of test functions for automatically checking that your
software works is considered as a fundamental requirement for reliable
computing. Equally important is a system that can keep track of
different versions of the files and the tests, known as a <em>version control
system</em>. Today&#8217;s most popular version control system is <a class="reference external" href="https://en.wikipedia.org/wiki/Git_(software)">Git</a>, which the
authors strongly recommend the reader to use for programming and writing
reports. The combination of Git and cloud storage such as GitHub is a
very common way of organizing scientific or engineering work.
We have a <a class="reference external" href="http://hplgit.github.io/teamods/bitgit/Langtangen_bitgit-bootstrap.html">quick intro</a> to Git and GitHub that gets you up and running within
minutes.</p>
<p>The typical workflow with Git goes as follows.</p>
<ol class="arabic simple">
<li>Before you start working with files, make sure you have the latest
version of them by running <code class="docutils literal"><span class="pre">git</span> <span class="pre">pull</span></code>.</li>
<li>Edit files, remove or create files (new files must be registered
by <code class="docutils literal"><span class="pre">git</span> <span class="pre">add</span></code>).</li>
<li>When a natural piece of work is done, <em>commit</em> your changes by the
<code class="docutils literal"><span class="pre">git</span> <span class="pre">commit</span></code> command.</li>
<li>Implement your changes also in the cloud by doing <code class="docutils literal"><span class="pre">git</span> <span class="pre">push</span></code>.</li>
</ol>
<p class="last">A nice feature of Git is that people can edit the same file at the same
time and very often Git will be able to automatically merge the changes (!).
Therefore, version control is crucial when you work with others or when
you do your work on different types of computers.
Another key feature is that anyone can at any time view the history of
a file, see who did what when, and roll back the entire file collection
to a previous commit. This feature is, of course, fundamental for
reliable work.</p>
</div>
</div>
</div>
<div class="section" id="vectorization-1">
<h2>Vectorization<a class="headerlink" href="#vectorization-1" title="Permalink to this headline">¶</a></h2>
<p id="index-37">The functions <code class="docutils literal"><span class="pre">midpoint</span></code> and <code class="docutils literal"><span class="pre">trapezoid</span></code> usually run fast in Python
and compute an integral to a satisfactory precision within a
fraction of a second. However, long loops in Python may run slowly in more
complicated implementations. To increase the speed, the loops
can be replaced by vectorized code. The integration functions constitute
a simple and good example to illustrate how to vectorize loops.</p>
<p>We have already seen simple examples on vectorization in
the section <a class="reference internal" href="._pylight002.html#st-ex3"><span class="std std-ref">A Python program with vectorization and plotting</span></a> when we could evaluate a mathematical function <span class="math">\(f(x)\)</span>
for a large number of <span class="math">\(x\)</span> values stored in an array.
Basically, we can write</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">x</span><span class="p">)</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="mi">5</span><span class="o">*</span><span class="n">x</span>

<span class="kn">from</span> <span class="nn">numpy</span> <span class="kn">import</span> <span class="n">exp</span><span class="p">,</span> <span class="n">sin</span><span class="p">,</span> <span class="n">linspace</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">101</span><span class="p">)</span>  <span class="c"># coordinates from 100 intervals on [0, 4]</span>
<span class="n">y</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>                 <span class="c"># all points evaluated at once</span>
</pre></div>
</div>
<p>The result <code class="docutils literal"><span class="pre">y</span></code> is the array that would be computed if we ran a
<code class="docutils literal"><span class="pre">for</span></code> loop over the individual
<code class="docutils literal"><span class="pre">x</span></code> values and called <code class="docutils literal"><span class="pre">f</span></code> for each value. Vectorization essentially
eliminates this loop in Python (i.e., the looping over <code class="docutils literal"><span class="pre">x</span></code> and application
of <code class="docutils literal"><span class="pre">f</span></code> to each <code class="docutils literal"><span class="pre">x</span></code> value are instead performed
in a library with fast, compiled code).</p>
<div class="section" id="vectorizing-the-midpoint-rule">
<h3>Vectorizing the midpoint rule<a class="headerlink" href="#vectorizing-the-midpoint-rule" title="Permalink to this headline">¶</a></h3>
<p>The aim of vectorizing the <code class="docutils literal"><span class="pre">midpoint</span></code> and <code class="docutils literal"><span class="pre">trapezoidal</span></code> functions is
also to remove the explicit loop in Python.
We start with vectorizing the <code class="docutils literal"><span class="pre">midpoint</span></code> function since <code class="docutils literal"><span class="pre">trapezoid</span></code>
is not equally straightforward. The fundamental ideas of the vectorized
algorithm are to</p>
<ol class="arabic simple">
<li>compute all the evaluation points in one array <code class="docutils literal"><span class="pre">x</span></code></li>
<li>call <code class="docutils literal"><span class="pre">f(x)</span></code> to produce an array of corresponding function values</li>
<li>use the <code class="docutils literal"><span class="pre">sum</span></code> function to sum the <code class="docutils literal"><span class="pre">f(x)</span></code> values</li>
</ol>
<p>The evaluation points in the midpoint method are
<span class="math">\(x_i=a+(i+\frac{1}{2})h\)</span>, <span class="math">\(i=0,\ldots,n-1\)</span>. That is, <span class="math">\(n\)</span> uniformly
distributed coordinates between <span class="math">\(a+h/2\)</span> and <span class="math">\(b-h/2\)</span>. Such coordinates
can be calculated by <code class="docutils literal"><span class="pre">x</span> <span class="pre">=</span> <span class="pre">linspace(a+h/2,</span> <span class="pre">b-h/2,</span> <span class="pre">n)</span></code>.
Given that the
Python implementation <code class="docutils literal"><span class="pre">f</span></code> of the mathematical function <span class="math">\(f\)</span> works with
an array argument,
which is very often the case in Python,
<code class="docutils literal"><span class="pre">f(x)</span></code> will produce all the function values in an
array. The array elements are then summed up by <code class="docutils literal"><span class="pre">sum</span></code>: <code class="docutils literal"><span class="pre">sum(f(x))</span></code>. This
sum is to be multiplied by the rectangle width <span class="math">\(h\)</span> to produce
the integral value. The complete function is listed below.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">numpy</span> <span class="kn">import</span> <span class="n">linspace</span><span class="p">,</span> <span class="nb">sum</span>

<span class="k">def</span> <span class="nf">midpoint</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
    <span class="n">h</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">b</span><span class="o">-</span><span class="n">a</span><span class="p">)</span><span class="o">/</span><span class="n">n</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">linspace</span><span class="p">(</span><span class="n">a</span> <span class="o">+</span> <span class="n">h</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="n">b</span> <span class="o">-</span> <span class="n">h</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">h</span><span class="o">*</span><span class="nb">sum</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
</pre></div>
</div>
<p>The code is found in the
file
<a class="reference external" href="https://github.com/hplgit/prog4comp/tree/master/src/py/integration_methods_vec.py">integration_methods_vec.py</a>.</p>
<p>Let us test the code interactively in a Python shell to compute
<span class="math">\(\int_0^1 3t^2dt\)</span>. The file with the code above has the name
<code class="docutils literal"><span class="pre">integration_methods_vec.py</span></code> and is a valid module from which we
can import the vectorized function:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">integration_methods_vec</span> <span class="kn">import</span> <span class="n">midpoint</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">numpy</span> <span class="kn">import</span> <span class="n">exp</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">t</span><span class="p">:</span> <span class="mi">3</span><span class="o">*</span><span class="n">t</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">exp</span><span class="p">(</span><span class="n">t</span><span class="o">**</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">midpoint</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
<span class="go">1.7014827690091872</span>
</pre></div>
</div>
<p>Note the necessity to use <code class="docutils literal"><span class="pre">exp</span></code> from <code class="docutils literal"><span class="pre">numpy</span></code>: our <code class="docutils literal"><span class="pre">v</span></code> function will
be called with <code class="docutils literal"><span class="pre">x</span></code> as an array, and the <code class="docutils literal"><span class="pre">exp</span></code> function must be
capable of working with an array.</p>
<p>The vectorized code performs all loops very efficiently in compiled
code, resulting in much faster execution. Moreover, many readers of
the code will also say that the algorithm looks clearer than in the
loop-based implementation.</p>
</div>
<div class="section" id="vectorizing-the-trapezoidal-rule">
<h3>Vectorizing the trapezoidal rule<a class="headerlink" href="#vectorizing-the-trapezoidal-rule" title="Permalink to this headline">¶</a></h3>
<p>We can use the same approach to vectorize the <code class="docutils literal"><span class="pre">trapezoid</span></code> function.
However, the trapezoidal rule performs a sum where the end points
have different weight. If we do <code class="docutils literal"><span class="pre">sum(f(x))</span></code>, we get the end points
<code class="docutils literal"><span class="pre">f(a)</span></code> and <code class="docutils literal"><span class="pre">f(b)</span></code> with weight unity instead of one half. A remedy
is to subtract the error from <code class="docutils literal"><span class="pre">sum(f(x))</span></code>: <code class="docutils literal"><span class="pre">sum(f(x))</span> <span class="pre">-</span> <span class="pre">0.5*f(a)</span> <span class="pre">-</span> <span class="pre">0.5*f(b)</span></code>.
The vectorized version of the trapezoidal method then becomes</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">trapezoidal</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
    <span class="n">h</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">b</span><span class="o">-</span><span class="n">a</span><span class="p">)</span><span class="o">/</span><span class="n">n</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">linspace</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">s</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">))</span> <span class="o">-</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">-</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">h</span><span class="o">*</span><span class="n">s</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="measuring-computational-speed">
<h2>Measuring computational speed<a class="headerlink" href="#measuring-computational-speed" title="Permalink to this headline">¶</a></h2>
<p id="index-38">Now that we have created faster, vectorized versions of functions in
the previous section, it is interesting to measure how much faster
they are. The purpose of the present section is therefore to
explain how we can record the CPU time consumed by a function so
we can answer this question.
There are many techniques for measuring the CPU time in Python,
and here we shall
just explain the simplest and most convenient one: the <code class="docutils literal"><span class="pre">%timeit</span></code>
command in IPython. The following interactive session should
illustrate a competition where the vectorized versions of the
functions are supposed to win:</p>
<div class="highlight-ipy"><div class="highlight"><pre><span class="gp">In [1]: </span><span class="kn">from</span> <span class="nn">integration_methods_vec</span> <span class="kn">import</span> <span class="n">midpoint</span> <span class="k">as</span> <span class="n">midpoint_vec</span>

<span class="gp">In [3]: </span><span class="kn">from</span> <span class="nn">midpoint</span> <span class="kn">import</span> <span class="n">midpoint</span>

<span class="gp">In [4]: </span><span class="kn">from</span> <span class="nn">numpy</span> <span class="kn">import</span> <span class="n">exp</span>

<span class="gp">In [5]: </span><span class="n">v</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">t</span><span class="p">:</span> <span class="mi">3</span><span class="o">*</span><span class="n">t</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">exp</span><span class="p">(</span><span class="n">t</span><span class="o">**</span><span class="mi">3</span><span class="p">)</span>

<span class="gp">In [6]: </span><span class="o">%</span><span class="k">timeit</span> midpoint_vec(v, 0, 1, 1000000)
<span class="go">1 loops, best of 3: 379 ms per loop</span>

<span class="gp">In [7]: </span><span class="o">%</span><span class="k">timeit</span> midpoint(v, 0, 1, 1000000)
<span class="go">1 loops, best of 3: 8.17 s per loop</span>

<span class="gp">In [8]: </span><span class="mf">8.17</span><span class="o">/</span><span class="p">(</span><span class="mi">379</span><span class="o">*</span><span class="mf">0.001</span><span class="p">)</span>    <span class="c"># efficiency factor</span>
<span class="gh">Out[8]: </span><span class="go">21.556728232189972</span>
</pre></div>
</div>
<p>We see that the vectorized version is about 20 times faster: 379 ms
versus 8.17 s. The results
for the trapezoidal method are very similar, and the factor of about 20
is independent of the number of intervals.</p>
</div>
<div class="section" id="double-and-triple-integrals">
<span id="sec-int-double"></span><h2>Double and triple integrals<a class="headerlink" href="#double-and-triple-integrals" title="Permalink to this headline">¶</a></h2>
<span class="target" id="index-39"></span><p id="index-40">Given a double integral over a rectangular domain <span class="math">\([a,b]\times [c,d]\)</span>,</p>
<div class="math">
\[\int_a^b \int_c^d f(x,y) dydx,\]</div>
<p>how can we approximate this integral by numerical methods?</p>
<div class="section" id="derivation-via-one-dimensional-integrals">
<h3>Derivation via one-dimensional integrals<a class="headerlink" href="#derivation-via-one-dimensional-integrals" title="Permalink to this headline">¶</a></h3>
<p>Since we know how to
deal with integrals in one variable, a fruitful approach is to view
the double integral as two integrals, each in one variable, which
can be approximated numerically by previous one-dimensional formulas.
To this end,
we introduce
a help function <span class="math">\(g(x)\)</span> and write</p>
<div class="math">
\[\int_a^b \int_c^d f(x,y) dydx = \int_a^b g(x)dx,\quad
g(x) = \int_c^d f(x,y) dy\thinspace .\]</div>
<p>Each of the integrals</p>
<div class="math">
\[\int_a^b g(x)dx,\quad
g(x) = \int_c^d f(x,y) dy\]</div>
<p>can be discretized by any numerical
integration rule for an integral in one variable. Let us use the
midpoint method
<a class="reference internal" href="#eq-sec-midpointformula"><span class="std std-ref">(22)</span></a>
and start with <span class="math">\(g(x)=\int_c^d f(x,y)dy\)</span>. We introduce
<span class="math">\(n_y\)</span> intervals on <span class="math">\([c,d]\)</span> with length <span class="math">\(h_y\)</span>. The midpoint rule
for this integral then becomes</p>
<div class="math">
\[g(x) = \int_c^d f(x,y) dy \approx  h_y \sum_{j=0}^{n_y-1} f(x,y_j),
\quad y_j = c + \frac{1}{2}{h_y} + jh_y \thinspace .\]</div>
<p>The expression looks somewhat different from <a class="reference internal" href="#eq-sec-midpointformula"><span class="std std-ref">(22)</span></a>,
but that is because of the notation: since we integrate in the <span class="math">\(y\)</span> direction
and will have to work with both <span class="math">\(x\)</span> and <span class="math">\(y\)</span> as coordinates, we must
use <span class="math">\(n_y\)</span> for <span class="math">\(n\)</span>, <span class="math">\(h_y\)</span> for <span class="math">\(h\)</span>, and the counter <span class="math">\(i\)</span> is more naturally
called <span class="math">\(j\)</span> when integrating in <span class="math">\(y\)</span>. Integrals in the <span class="math">\(x\)</span> direction will use
<span class="math">\(h_x\)</span> and <span class="math">\(n_x\)</span> for <span class="math">\(h\)</span> and <span class="math">\(n\)</span>, and <span class="math">\(i\)</span> as counter.</p>
<p>The double integral is <span class="math">\(\int_a^b g(x)dx\)</span>, which can be approximated
by the midpoint method:</p>
<div class="math">
\[\int_a^b g(x)dx \approx h_x \sum_{i=0}^{n_x-1} g(x_i),\quad x_i=a + \frac{1}{2}{h_x} + ih_x\thinspace .\]</div>
<p>Putting the formulas together, we arrive at the <em>composite midpoint method
for a double integral</em>:</p>
<div class="math">
\[\int_a^b \int_c^d f(x,y) dydx \approx
h_x \sum_{i=0}^{n_x-1} h_y \sum_{j=0}^{n_y-1} f(x_i,y_j)\nonumber\]</div>
<div class="math" id="eq-sec-int-double-midpoint-rule">
\[\tag{26}
=
    h_xh_y \sum_{i=0}^{n_x-1} \sum_{j=0}^{n_y-1} f(a + \frac{h_x}{2} + ih_x, c + \frac{h_y}{2} + jh_y)\thinspace .\]</div>
</div>
<div class="section" id="direct-derivation">
<h3>Direct derivation<a class="headerlink" href="#direct-derivation" title="Permalink to this headline">¶</a></h3>
<p>The formula <a class="reference internal" href="#eq-sec-int-double-midpoint-rule"><span class="std std-ref">(26)</span></a> can also be derived directly
in the two-dimensional case by applying the idea of the midpoint
method. We divide the rectangle <span class="math">\([a,b]\times [c,d]\)</span> into
<span class="math">\(n_x\times n_y\)</span> equal-sized cells. The idea of the midpoint method is
to approximate <span class="math">\(f\)</span> by a constant over each cell, and evaluate the constant
at the midpoint. Cell <span class="math">\((i,j)\)</span> occupies the area</p>
<div class="math">
\[[a+ih_x,a+(i+1)h_x]\times [c+jh_y, c+ (j+1)h_y],\]</div>
<p>and the midpoint is <span class="math">\((x_i,y_j)\)</span> with</p>
<div class="math">
\[x_i=a + ih_x + \frac{1}{2}{h_x} ,\quad y_j = c + jh_y + \frac{1}{2}{h_y}
\thinspace .\]</div>
<p>The integral over the cell is therefore <span class="math">\(h_xh_y f(x_i,y_j)\)</span>, and
the total double integral is the sum over all cells, which is
nothing but formula <a class="reference internal" href="#eq-sec-int-double-midpoint-rule"><span class="std std-ref">(26)</span></a>.</p>
</div>
<div class="section" id="programming-a-double-sum">
<h3>Programming a double sum<a class="headerlink" href="#programming-a-double-sum" title="Permalink to this headline">¶</a></h3>
<p id="index-41">The formula <a class="reference internal" href="#eq-sec-int-double-midpoint-rule"><span class="std std-ref">(26)</span></a> involves a double sum,
which is normally implemented as a double for loop. A Python function
implementing <a class="reference internal" href="#eq-sec-int-double-midpoint-rule"><span class="std std-ref">(26)</span></a> may look like</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">midpoint_double1</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">nx</span><span class="p">,</span> <span class="n">ny</span><span class="p">):</span>
    <span class="n">hx</span> <span class="o">=</span> <span class="p">(</span><span class="n">b</span> <span class="o">-</span> <span class="n">a</span><span class="p">)</span><span class="o">/</span><span class="nb">float</span><span class="p">(</span><span class="n">nx</span><span class="p">)</span>
    <span class="n">hy</span> <span class="o">=</span> <span class="p">(</span><span class="n">d</span> <span class="o">-</span> <span class="n">c</span><span class="p">)</span><span class="o">/</span><span class="nb">float</span><span class="p">(</span><span class="n">ny</span><span class="p">)</span>
    <span class="n">I</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nx</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ny</span><span class="p">):</span>
            <span class="n">xi</span> <span class="o">=</span> <span class="n">a</span> <span class="o">+</span> <span class="n">hx</span><span class="o">/</span><span class="mi">2</span> <span class="o">+</span> <span class="n">i</span><span class="o">*</span><span class="n">hx</span>
            <span class="n">yj</span> <span class="o">=</span> <span class="n">c</span> <span class="o">+</span> <span class="n">hy</span><span class="o">/</span><span class="mi">2</span> <span class="o">+</span> <span class="n">j</span><span class="o">*</span><span class="n">hy</span>
            <span class="n">I</span> <span class="o">+=</span> <span class="n">hx</span><span class="o">*</span><span class="n">hy</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">xi</span><span class="p">,</span> <span class="n">yj</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">I</span>
</pre></div>
</div>
<p>If this function is stored in a module file
<a class="reference external" href="https://github.com/hplgit/prog4comp/tree/master/src/py/midpoint_double.py">midpoint_double.py</a>,
we can compute some integral, e.g.,
<span class="math">\(\int_2^3\int_0^2 (2x + y)dxdy=9\)</span> in an interactive shell
and demonstrate that the function computes the right number:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">midpoint_double</span> <span class="kn">import</span> <span class="n">midpoint_double1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="mi">2</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="n">y</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">midpoint_double1</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
<span class="go">9.0</span>
</pre></div>
</div>
</div>
<div class="section" id="reusing-code-for-one-dimensional-integrals">
<h3>Reusing code for one-dimensional integrals<a class="headerlink" href="#reusing-code-for-one-dimensional-integrals" title="Permalink to this headline">¶</a></h3>
<p id="index-42">It is very natural to write a two-dimensional midpoint method as we did in
function <code class="docutils literal"><span class="pre">midpoint_double1</span></code> when we have the formula <a class="reference internal" href="#eq-sec-int-double-midpoint-rule"><span class="std std-ref">(26)</span></a>. However, we could alternatively ask, much as we did in the mathematics,
can we reuse a well-tested implementation for one-dimensional integrals
to compute double integrals? That is, can we use function <code class="docutils literal"><span class="pre">midpoint</span></code></p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">midpoint</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
    <span class="n">h</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">b</span><span class="o">-</span><span class="n">a</span><span class="p">)</span><span class="o">/</span><span class="n">n</span>
    <span class="n">result</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
        <span class="n">result</span> <span class="o">+=</span> <span class="n">f</span><span class="p">((</span><span class="n">a</span> <span class="o">+</span> <span class="n">h</span><span class="o">/</span><span class="mf">2.0</span><span class="p">)</span> <span class="o">+</span> <span class="n">i</span><span class="o">*</span><span class="n">h</span><span class="p">)</span>
    <span class="n">result</span> <span class="o">*=</span> <span class="n">h</span>
    <span class="k">return</span> <span class="n">result</span>
</pre></div>
</div>
<p>from the section <a class="reference internal" href="#sec-midpoint-code"><span class="std std-ref">Implementation</span></a> &#8220;twice&#8221;?
The answer is yes, if we think as we did in the mathematics: compute
the double integral as a midpoint rule for integrating <span class="math">\(g(x)\)</span> and define
<span class="math">\(g(x_i)\)</span> in terms of a midpoint
rule over <span class="math">\(f\)</span> in the <span class="math">\(y\)</span> coordinate. The corresponding function has very
short code:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">midpoint_double2</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">nx</span><span class="p">,</span> <span class="n">ny</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">g</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">midpoint</span><span class="p">(</span><span class="k">lambda</span> <span class="n">y</span><span class="p">:</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">),</span> <span class="n">c</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">ny</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">midpoint</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">nx</span><span class="p">)</span>
</pre></div>
</div>
<p>The important advantage of this implementation is that we reuse a well-tested
function for the standard one-dimensional midpoint rule and that we
apply the one-dimensional rule exactly as in the mathematics.</p>
</div>
<div class="section" id="verification-via-test-functions">
<h3>Verification via test functions<a class="headerlink" href="#verification-via-test-functions" title="Permalink to this headline">¶</a></h3>
<p>How can we test that our functions for the double integral work?
The best unit test is to find a problem where the numerical approximation
error vanishes because then we know exactly what the numerical
answer should be. The midpoint rule is exact for linear functions,
regardless of how many subinterval we use.
Also, any linear two-dimensional function <span class="math">\(f(x,y)=px+qy+r\)</span> will be integrated
exactly by the two-dimensional midpoint rule. We may pick
<span class="math">\(f(x,y)=2x+y\)</span> and create a proper <em>test function</em> that can automatically
verify our two alternative implementations of the two-dimensional
midpoint rule. To compute the integral of <span class="math">\(f(x,y)\)</span> we take advantage of
SymPy to eliminate the possibility of errors in hand calculations.
The test function becomes</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">test_midpoint_double</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;Test that a linear function is integrated exactly.&quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="k">return</span> <span class="mi">2</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="n">y</span>

    <span class="n">a</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>  <span class="n">b</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>  <span class="n">c</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>  <span class="n">d</span> <span class="o">=</span> <span class="mi">3</span>
    <span class="kn">import</span> <span class="nn">sympy</span>
    <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">sympy</span><span class="o">.</span><span class="n">symbols</span><span class="p">(</span><span class="s">&#39;x  y&#39;</span><span class="p">)</span>
    <span class="n">I_expected</span> <span class="o">=</span> <span class="n">sympy</span><span class="o">.</span><span class="n">integrate</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">),</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">),</span> <span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">d</span><span class="p">))</span>
    <span class="c"># Test three cases: nx &lt; ny, nx = ny, nx &gt; ny</span>
    <span class="k">for</span> <span class="n">nx</span><span class="p">,</span> <span class="n">ny</span> <span class="ow">in</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">),</span> <span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span> <span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">3</span><span class="p">):</span>
        <span class="n">I_computed1</span> <span class="o">=</span> <span class="n">midpoint_double1</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">nx</span><span class="p">,</span> <span class="n">ny</span><span class="p">)</span>
        <span class="n">I_computed2</span> <span class="o">=</span> <span class="n">midpoint_double2</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">nx</span><span class="p">,</span> <span class="n">ny</span><span class="p">)</span>
        <span class="n">tol</span> <span class="o">=</span> <span class="mf">1E-14</span>
        <span class="c">#print I_expected, I_computed1, I_computed2</span>
        <span class="k">assert</span> <span class="nb">abs</span><span class="p">(</span><span class="n">I_computed1</span> <span class="o">-</span> <span class="n">I_expected</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">tol</span>
        <span class="k">assert</span> <span class="nb">abs</span><span class="p">(</span><span class="n">I_computed2</span> <span class="o">-</span> <span class="n">I_expected</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">tol</span>
</pre></div>
</div>
<div class="admonition-let-test-functions-speak-up admonition">
<p class="first admonition-title">Let test functions speak up</p>
<p class="last">If we call the above <code class="docutils literal"><span class="pre">test_midpoint_double</span></code> function
and nothing happens, our implementations
are correct. However, it is somewhat annoying to have a function that
is completely silent when it works - are we sure all things are properly
computed? During development it is therefore highly recommended to insert
a print statement such that we can monitor the calculations and be
convinced that the test function does what we want. Since a test
function should not have any print statement, we simply comment it out as
we have done in the function listed above.</p>
</div>
<p>The trapezoidal method can be used as alternative for the midpoint
method.  The derivation of a formula for the double integral and the
implementations follow exactly the same ideas as we explained with the
midpoint method, but there are more terms to write in the
formulas. <a class="reference internal" href="#sec-exer-trapezoidal-2d"><span class="std std-ref">Exercise 42: Derive the trapezoidal rule for a double integral</span></a> asks you to carry out
the details. That exercise is a very good test on your understanding of the
mathematical and programming ideas in the present section.</p>
<div class="section" id="the-midpoint-rule-for-a-triple-integral">
<h4>The midpoint rule for a triple integral<a class="headerlink" href="#the-midpoint-rule-for-a-triple-integral" title="Permalink to this headline">¶</a></h4>
</div>
</div>
<div class="section" id="theory">
<h3>Theory<a class="headerlink" href="#theory" title="Permalink to this headline">¶</a></h3>
<p id="index-43">Once a method that works for a one-dimensional problem is generalized
to two dimensions, it is usually quite straightforward to extend the
method to three dimensions. This will now be demonstrated for
integrals. We have the triple integral</p>
<div class="math">
\[\int_{a}^{b} \int_c^d \int_e^f g(x,y,z) dzdydx\]</div>
<p>and want to approximate the integral by a midpoint rule.
Following the ideas for the double integral, we
split this integral into one-dimensional integrals:</p>
<div class="math">
\[\begin{split}p(x,y) &amp;= \int_e^f g(x,y,z) dz\\
q(x) &amp;= \int_c^d p(x,y) dy\\
\int_{a}^{b} \int_c^d \int_e^f g(x,y,z) dzdydx &amp;= \int_a^b q(x)dx\end{split}\]</div>
<p>For each of these one-dimensional integrals we apply the midpoint rule:</p>
<div class="math">
\[\begin{split}p(x,y) = \int_e^f g(x,y,z) dz
&amp;\approx \sum_{k=0}^{n_z-1} g(x,y,z_k),
\\
q(x) = \int_c^d p(x,y) dy
&amp;\approx \sum_{j=0}^{n_y-1} p(x,y_j),
\\
\int_{a}^{b} \int_c^d \int_e^f g(x,y,z) dzdydx = \int_a^b q(x)dx
&amp;\approx \sum_{i=0}^{n_x-1} q(x_i),\end{split}\]</div>
<p>where</p>
<div class="math">
\[z_k=e + \frac{1}{2}h_z + kh_z,\quad y_j=c + \frac{1}{2}h_y + jh_y \quad
x_i=a + \frac{1}{2}h_x + ih_x
\thinspace .\]</div>
<p>Starting with the formula for <span class="math">\(\int_{a}^{b} \int_c^d \int_e^f g(x,y,z) dzdydx\)</span>
and inserting the two previous formulas gives</p>
<div class="math">
\[\int_{a}^{b} \int_c^d \int_e^f g(x,y,z)\, dzdydx\approx\nonumber\]</div>
<div class="math" id="eq-sec-int-triple-midpoint">
\[\tag{27}
h_xh_yh_z
    \sum_{i=0}^{n_x-1}\sum_{j=0}^{n_y-1}\sum_{k=0}^{n_z-1}
    g(a + \frac{1}{2}h_x + ih_x,
    c + \frac{1}{2}h_y + jh_y,
    e + \frac{1}{2}h_z + kh_z)\thinspace .\]</div>
<p>Note that we may apply the ideas under <em>Direct derivation</em> at
the end of the section <span class="xref std std-ref">sec:int:double:midpoint</span> to arrive
at <a class="reference internal" href="#eq-sec-int-triple-midpoint"><span class="std std-ref">(27)</span></a> directly: divide
the domain into <span class="math">\(n_x\times n_y\times n_z\)</span> cells of volumes
<span class="math">\(h_xh_yh_z\)</span>; approximate <span class="math">\(g\)</span>
by a constant, evaluated at the midpoint <span class="math">\((x_i,y_j,z_k)\)</span>,
in each cell; and
sum the cell integrals <span class="math">\(h_xh_yh_zg(x_i,y_j,z_k)\)</span>.</p>
</div>
<div class="section" id="implementation-3">
<span id="index-44"></span><h3>Implementation<a class="headerlink" href="#implementation-3" title="Permalink to this headline">¶</a></h3>
<p>We follow the ideas for the implementations of the midpoint rule
for a double integral. The corresponding functions are shown below
and found in the file
<a class="reference external" href="https://github.com/hplgit/prog4comp/tree/master/src/py/midpoint_triple.py">midpoint_triple.py</a>.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">midpoint_triple1</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">e</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">nx</span><span class="p">,</span> <span class="n">ny</span><span class="p">,</span> <span class="n">nz</span><span class="p">):</span>
    <span class="n">hx</span> <span class="o">=</span> <span class="p">(</span><span class="n">b</span> <span class="o">-</span> <span class="n">a</span><span class="p">)</span><span class="o">/</span><span class="nb">float</span><span class="p">(</span><span class="n">nx</span><span class="p">)</span>
    <span class="n">hy</span> <span class="o">=</span> <span class="p">(</span><span class="n">d</span> <span class="o">-</span> <span class="n">c</span><span class="p">)</span><span class="o">/</span><span class="nb">float</span><span class="p">(</span><span class="n">ny</span><span class="p">)</span>
    <span class="n">hz</span> <span class="o">=</span> <span class="p">(</span><span class="n">f</span> <span class="o">-</span> <span class="n">e</span><span class="p">)</span><span class="o">/</span><span class="nb">float</span><span class="p">(</span><span class="n">nz</span><span class="p">)</span>
    <span class="n">I</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nx</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ny</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nz</span><span class="p">):</span>
                <span class="n">xi</span> <span class="o">=</span> <span class="n">a</span> <span class="o">+</span> <span class="n">hx</span><span class="o">/</span><span class="mi">2</span> <span class="o">+</span> <span class="n">i</span><span class="o">*</span><span class="n">hx</span>
                <span class="n">yj</span> <span class="o">=</span> <span class="n">c</span> <span class="o">+</span> <span class="n">hy</span><span class="o">/</span><span class="mi">2</span> <span class="o">+</span> <span class="n">j</span><span class="o">*</span><span class="n">hy</span>
                <span class="n">zk</span> <span class="o">=</span> <span class="n">e</span> <span class="o">+</span> <span class="n">hz</span><span class="o">/</span><span class="mi">2</span> <span class="o">+</span> <span class="n">k</span><span class="o">*</span><span class="n">hz</span>
                <span class="n">I</span> <span class="o">+=</span> <span class="n">hx</span><span class="o">*</span><span class="n">hy</span><span class="o">*</span><span class="n">hz</span><span class="o">*</span><span class="n">g</span><span class="p">(</span><span class="n">xi</span><span class="p">,</span> <span class="n">yj</span><span class="p">,</span> <span class="n">zk</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">I</span>

<span class="k">def</span> <span class="nf">midpoint</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
    <span class="n">h</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">b</span><span class="o">-</span><span class="n">a</span><span class="p">)</span><span class="o">/</span><span class="n">n</span>
    <span class="n">result</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
        <span class="n">result</span> <span class="o">+=</span> <span class="n">f</span><span class="p">((</span><span class="n">a</span> <span class="o">+</span> <span class="n">h</span><span class="o">/</span><span class="mf">2.0</span><span class="p">)</span> <span class="o">+</span> <span class="n">i</span><span class="o">*</span><span class="n">h</span><span class="p">)</span>
    <span class="n">result</span> <span class="o">*=</span> <span class="n">h</span>
    <span class="k">return</span> <span class="n">result</span>

<span class="k">def</span> <span class="nf">midpoint_triple2</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">e</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">nx</span><span class="p">,</span> <span class="n">ny</span><span class="p">,</span> <span class="n">nz</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">p</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">midpoint</span><span class="p">(</span><span class="k">lambda</span> <span class="n">z</span><span class="p">:</span> <span class="n">g</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">),</span> <span class="n">e</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">nz</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">q</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">midpoint</span><span class="p">(</span><span class="k">lambda</span> <span class="n">y</span><span class="p">:</span> <span class="n">p</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">),</span> <span class="n">c</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">ny</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">midpoint</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">nx</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">test_midpoint_triple</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;Test that a linear function is integrated exactly.&quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">g</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">):</span>
        <span class="k">return</span> <span class="mi">2</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="n">y</span> <span class="o">-</span> <span class="mi">4</span><span class="o">*</span><span class="n">z</span>

    <span class="n">a</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>  <span class="n">b</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>  <span class="n">c</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>  <span class="n">d</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>  <span class="n">e</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>  <span class="n">f</span> <span class="o">=</span> <span class="mi">2</span>
    <span class="kn">import</span> <span class="nn">sympy</span>
    <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span> <span class="o">=</span> <span class="n">sympy</span><span class="o">.</span><span class="n">symbols</span><span class="p">(</span><span class="s">&#39;x y z&#39;</span><span class="p">)</span>
    <span class="n">I_expected</span> <span class="o">=</span> <span class="n">sympy</span><span class="o">.</span><span class="n">integrate</span><span class="p">(</span>
        <span class="n">g</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">),</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">),</span> <span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">d</span><span class="p">),</span> <span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="n">e</span><span class="p">,</span> <span class="n">f</span><span class="p">))</span>
    <span class="k">for</span> <span class="n">nx</span><span class="p">,</span> <span class="n">ny</span><span class="p">,</span> <span class="n">nz</span> <span class="ow">in</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span> <span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">6</span><span class="p">):</span>
        <span class="n">I_computed1</span> <span class="o">=</span> <span class="n">midpoint_triple1</span><span class="p">(</span>
            <span class="n">g</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">e</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">nx</span><span class="p">,</span> <span class="n">ny</span><span class="p">,</span> <span class="n">nz</span><span class="p">)</span>
        <span class="n">I_computed2</span> <span class="o">=</span> <span class="n">midpoint_triple2</span><span class="p">(</span>
            <span class="n">g</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">e</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">nx</span><span class="p">,</span> <span class="n">ny</span><span class="p">,</span> <span class="n">nz</span><span class="p">)</span>
        <span class="n">tol</span> <span class="o">=</span> <span class="mf">1E-14</span>
        <span class="k">print</span> <span class="n">I_expected</span><span class="p">,</span> <span class="n">I_computed1</span><span class="p">,</span> <span class="n">I_computed2</span>
        <span class="k">assert</span> <span class="nb">abs</span><span class="p">(</span><span class="n">I_computed1</span> <span class="o">-</span> <span class="n">I_expected</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">tol</span>
        <span class="k">assert</span> <span class="nb">abs</span><span class="p">(</span><span class="n">I_computed2</span> <span class="o">-</span> <span class="n">I_expected</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">tol</span>

<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">test_midpoint_triple</span><span class="p">()</span>
</pre></div>
</div>
<div class="section" id="monte-carlo-integration-for-complex-shaped-domains">
<span id="sec-int-complex-domain"></span><h4>Monte Carlo integration for complex-shaped domains<a class="headerlink" href="#monte-carlo-integration-for-complex-shaped-domains" title="Permalink to this headline">¶</a></h4>
<span class="target" id="index-45"></span><span class="target" id="index-46"></span><p id="index-47">Repeated use of one-dimensional integration rules to handle double
and triple integrals constitute a working strategy only if the
integration domain is a rectangle or box. For any other shape of
domain, completely different methods must be used. A common approach
for two- and three-dimensional domains is to divide the domain into
many small triangles or tetrahedra and use numerical integration
methods for each triangle or tetrahedron. The overall algorithm and
implementation is too complicated to be addressed in this book.
Instead, we shall employ an alternative, very simple and general method,
called Monte Carlo integration. It can be implemented in half a page of
code, but requires orders of magnitude more
function evaluations in double integrals compared to the midpoint
rule.</p>
<p>However, Monte Carlo integration is much more computationally
efficient than the midpoint rule when computing
higher-dimensional integrals in more than three variables over
hypercube domains.
Our ideas for double and triple integrals can easily be generalized
to handle an integral in <span class="math">\(m\)</span> variables. A midpoint formula
then involves <span class="math">\(m\)</span> sums. With <span class="math">\(n\)</span> cells
in each coordinate direction, the formula requires <span class="math">\(n^m\)</span> function
evaluations. That is, the computational work explodes as an exponential
function of the number of space dimensions.
Monte Carlo integration, on the other hand, does not suffer from this
explosion of computational work and is the preferred method for
computing higher-dimensional integrals. So, it makes sense in a
chapter on numerical integration to address Monte Carlo methods, both
for handling complex domains and for handling integrals with many variables.</p>
</div>
</div>
<div class="section" id="the-monte-carlo-integration-algorithm">
<h3>The Monte Carlo integration algorithm<a class="headerlink" href="#the-monte-carlo-integration-algorithm" title="Permalink to this headline">¶</a></h3>
<p>The idea of Monte Carlo integration of <span class="math">\(\int_a^b f(x)dx\)</span> is to
use the mean-value theorem from calculus, which states that the
integral <span class="math">\(\int_a^b f(x)dx\)</span> equals the length of the integration
domain, here <span class="math">\(b-a\)</span>, times the <em>average</em> value of <span class="math">\(f\)</span>, <span class="math">\(\bar f\)</span>, in
<span class="math">\([a,b]\)</span>. The average value can be computed by sampling <span class="math">\(f\)</span> at
a set of <em>random</em> points inside the domain and take the mean of
the function values. In higher dimensions, an integral is estimated
as the area/volume of the domain times the average value, and again
one can evaluate the integrand at a set of random points in the domain
and compute the mean value of those evaluations.</p>
<p>Let us introduce some quantities to help us make the
specification of the integration algorithm more precise.
Suppose we have some two-dimensional integral</p>
<div class="math">
\[\int_\Omega f(x,y)dxdx,\]</div>
<p>where <span class="math">\(\Omega\)</span> is a two-dimensional domain defined via a help function
<span class="math">\(g(x,y)\)</span>:</p>
<div class="math">
\[\Omega = \{ (x,y)\,|\, g(x,y) \geq 0\}\]</div>
<p>That is, points <span class="math">\((x,y)\)</span> for which <span class="math">\(g(x,y)\geq 0\)</span> lie inside <span class="math">\(\Omega\)</span>,
and points for which <span class="math">\(g(x,y)&lt;\Omega\)</span> are outside <span class="math">\(\Omega\)</span>.  The
boundary of the domain <span class="math">\(\partial\Omega\)</span> is given by the implicit curve
<span class="math">\(g(x,y)=0\)</span>. Such formulations of geometries have been very common
during the last couple of decades, and one refers to <span class="math">\(g\)</span> as a
<em>level-set function</em> and the boundary <span class="math">\(g=0\)</span> as the zero-level contour
of the level-set function. For simple geometries one can easily construct
<span class="math">\(g\)</span> by hand, while in more complicated industrial applications one must
resort to mathematical models for constructing <span class="math">\(g\)</span>.</p>
<p>Let <span class="math">\(A(\Omega)\)</span> be the area of a domain <span class="math">\(\Omega\)</span>.
We can estimate the integral by this Monte Carlo integration method:</p>
<ol class="arabic simple">
<li>embed the geometry <span class="math">\(\Omega\)</span> in a rectangular area <span class="math">\(R\)</span></li>
<li>draw a large number of <em>random</em> points <span class="math">\((x,y)\)</span> in <span class="math">\(R\)</span></li>
<li>count the fraction <span class="math">\(q\)</span> of points that are inside <span class="math">\(\Omega\)</span></li>
<li>approximate <span class="math">\(A(\Omega)/A(R)\)</span> by <span class="math">\(q\)</span>, i.e., set <span class="math">\(A(\Omega) = qA(R)\)</span></li>
<li>evaluate the mean of <span class="math">\(f\)</span>, <span class="math">\(\bar f\)</span>, at the points inside <span class="math">\(\Omega\)</span></li>
<li>estimate the integral as <span class="math">\(A(\Omega)\bar f\)</span></li>
</ol>
<p>Note that <span class="math">\(A(R)\)</span> is trivial to compute since <span class="math">\(R\)</span> is a rectangle,
while <span class="math">\(A(\Omega)\)</span> is unknown. However, if we assume that the fraction
of <span class="math">\(A(R)\)</span> occupied by <span class="math">\(A(\Omega)\)</span> is the same as the fraction of
random points inside <span class="math">\(\Omega\)</span>, we get a simple estimate for <span class="math">\(A(\Omega)\)</span>.</p>
<p>To get an idea of the method, consider a circular domain
<span class="math">\(\Omega\)</span> embedded in a rectangle as shown below. A collection of
random points is illustrated by black dots.</p>
<div class="figure">
<a class="reference internal image-reference" href="_images/integral_complex_domain.png"><img alt="_images/integral_complex_domain.png" src="_images/integral_complex_domain.png" style="width: 600px;" /></a>
</div>
</div>
<div class="section" id="implementation-4">
<h3>Implementation<a class="headerlink" href="#implementation-4" title="Permalink to this headline">¶</a></h3>
<p>A Python function implementing <span class="math">\(\int_\Omega f(x,y)dxdy\)</span> can be written
like this:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>

<span class="k">def</span> <span class="nf">MonteCarlo_double</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">x0</span><span class="p">,</span> <span class="n">x1</span><span class="p">,</span> <span class="n">y0</span><span class="p">,</span> <span class="n">y1</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Monte Carlo integration of f over a domain g&gt;=0, embedded</span>
<span class="sd">    in a rectangle [x0,x1]x[y0,y1]. n^2 is the number of</span>
<span class="sd">    random points.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c"># Draw n**2 random points in the rectangle</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="n">x0</span><span class="p">,</span> <span class="n">x1</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="n">y0</span><span class="p">,</span> <span class="n">y1</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
    <span class="c"># Compute sum of f values inside the integration domain</span>
    <span class="n">f_mean</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">num_inside</span> <span class="o">=</span> <span class="mi">0</span>   <span class="c"># number of x,y points inside domain (g&gt;=0)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)):</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">y</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">g</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">y</span><span class="p">[</span><span class="n">j</span><span class="p">])</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">num_inside</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="n">f_mean</span> <span class="o">+=</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">y</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
    <span class="n">f_mean</span> <span class="o">=</span> <span class="n">f_mean</span><span class="o">/</span><span class="nb">float</span><span class="p">(</span><span class="n">num_inside</span><span class="p">)</span>
    <span class="n">area</span> <span class="o">=</span> <span class="n">num_inside</span><span class="o">/</span><span class="nb">float</span><span class="p">(</span><span class="n">n</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">x1</span> <span class="o">-</span> <span class="n">x0</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">y1</span> <span class="o">-</span> <span class="n">y0</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">area</span><span class="o">*</span><span class="n">f_mean</span>
</pre></div>
</div>
<p>(See the file
<a class="reference external" href="https://github.com/hplgit/prog4comp/tree/master/src/py/MC_double.py">MC_double.py</a>.)</p>
</div>
<div class="section" id="verification">
<h3>Verification<a class="headerlink" href="#verification" title="Permalink to this headline">¶</a></h3>
<p>A simple test case is to check the area of a rectangle <span class="math">\([0,2]\times[3,4.5]\)</span>
embedded in a rectangle <span class="math">\([0,3]\times [2,5]\)</span>. The right answer is 3,
but Monte Carlo integration is, unfortunately, never exact so it is
impossible to predict the output of the algorithm. All we know is that
the estimated integral should approach 3 as the number of random points
goes to infinity. Also, for a fixed number of points, we can
run the algorithm several times and get different numbers that fluctuate
around the exact value, since different sample points are used in different
calls to the Monte Carlo integration algorithm.</p>
<p>The area of the rectangle can be computed by the integral <span class="math">\(\int_0^2\int_3^{4.5}
dydx\)</span>, so in this case we identify
<span class="math">\(f(x,y)=1\)</span>, and the <span class="math">\(g\)</span> function can be specified as (e.g.)
1 if <span class="math">\((x,y)\)</span> is inside <span class="math">\([0,2]\times[3,4.5]\)</span> and <span class="math">\(-1\)</span> otherwise.
Here is an example on how we can utilize the <code class="docutils literal"><span class="pre">MonteCarlo_double</span></code>
function to compute the area for different number of samples:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">MC_double</span> <span class="kn">import</span> <span class="n">MonteCarlo_double</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">g</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="p">(</span><span class="mi">1</span> <span class="k">if</span> <span class="p">(</span><span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">x</span> <span class="o">&lt;=</span> <span class="mi">2</span> <span class="ow">and</span> <span class="mi">3</span> <span class="o">&lt;=</span> <span class="n">y</span> <span class="o">&lt;=</span> <span class="mf">4.5</span><span class="p">)</span> <span class="k">else</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">MonteCarlo_double</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>
<span class="go">2.9484</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">MonteCarlo_double</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">1000</span><span class="p">)</span>
<span class="go">2.947032</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">MonteCarlo_double</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">1000</span><span class="p">)</span>
<span class="go">3.0234600000000005</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">MonteCarlo_double</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">2000</span><span class="p">)</span>
<span class="go">2.9984580000000003</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">MonteCarlo_double</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">2000</span><span class="p">)</span>
<span class="go">3.1903469999999996</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">MonteCarlo_double</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">5000</span><span class="p">)</span>
<span class="go">2.986515</span>
</pre></div>
</div>
<p>We see that the values fluctuate around 3, a fact that supports
a correct implementation, but in principle, bugs could be hidden
behind the inaccurate answers.</p>
<p>It is mathematically known that the standard deviation of the Monte Carlo
estimate of an integral converges as <span class="math">\(n^{-1/2}\)</span>, where <span class="math">\(n\)</span> is the number
of samples. This kind of convergence rate estimate could be used to
verify the implementation, but this topic is beyond the scope of this book.</p>
</div>
<div class="section" id="test-function-for-function-with-random-numbers">
<span id="index-48"></span><h3>Test function for function with random numbers<a class="headerlink" href="#test-function-for-function-with-random-numbers" title="Permalink to this headline">¶</a></h3>
<p>To make a test function, we need a unit test that has identical
behavior each time we run the test. This seems difficult when random
numbers are involved, because these numbers are different every time
we run the algorithm, and each run hence produces a (slightly)
different result.  A standard way to test algorithms involving random
numbers is to <em>fix the seed</em> of the random number generator. Then the
sequence of numbers is the same every time we run the algorithm.
Assuming that the <code class="docutils literal"><span class="pre">MonteCarlo_double</span></code> function works, we fix the seed,
observe a certain result, and take this result as the correct
result. Provided the test function always uses this seed, we should
get exactly this result every time the <code class="docutils literal"><span class="pre">MonteCarlo_double</span></code> function is
called. Our test function can then be written as shown below.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">test_MonteCarlo_double_rectangle_area</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;Check the area of a rectangle.&quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">g</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="mi">1</span> <span class="k">if</span> <span class="p">(</span><span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">x</span> <span class="o">&lt;=</span> <span class="mi">2</span> <span class="ow">and</span> <span class="mi">3</span> <span class="o">&lt;=</span> <span class="n">y</span> <span class="o">&lt;=</span> <span class="mf">4.5</span><span class="p">)</span> <span class="k">else</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>

    <span class="n">x0</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>  <span class="n">x1</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>  <span class="n">y0</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>  <span class="n">y1</span> <span class="o">=</span> <span class="mi">5</span>  <span class="c"># embedded rectangle</span>
    <span class="n">n</span> <span class="o">=</span> <span class="mi">1000</span>
    <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="mi">8</span><span class="p">)</span>      <span class="c"># must fix the seed!</span>
    <span class="n">I_expected</span> <span class="o">=</span> <span class="mf">3.121092</span>  <span class="c"># computed with this seed</span>
    <span class="n">I_computed</span> <span class="o">=</span> <span class="n">MonteCarlo_double</span><span class="p">(</span>
        <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">x0</span><span class="p">,</span> <span class="n">x1</span><span class="p">,</span> <span class="n">y0</span><span class="p">,</span> <span class="n">y1</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
    <span class="k">assert</span> <span class="nb">abs</span><span class="p">(</span><span class="n">I_expected</span> <span class="o">-</span> <span class="n">I_computed</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mf">1E-14</span>
</pre></div>
</div>
<p>(See the file <a class="reference external" href="https://github.com/hplgit/prog4comp/tree/master/src/py/MC_double.py">MC_double.py</a>.)</p>
</div>
<div class="section" id="integral-over-a-circle">
<h3>Integral over a circle<a class="headerlink" href="#integral-over-a-circle" title="Permalink to this headline">¶</a></h3>
<p>The test above involves a trivial function <span class="math">\(f(x,y)=1\)</span>. We should also
test a non-constant <span class="math">\(f\)</span> function and a more complicated domain. Let
<span class="math">\(\Omega\)</span> be a circle at the origin with radius 2, and let <span class="math">\(f=\sqrt{x^2
+ y^2}\)</span>.  This choice makes it possible to compute an exact result: in
polar coordinates, <span class="math">\(\int_\Omega f(x,y)dxdy\)</span> simplifies to
<span class="math">\(2\pi\int_0^2 r^2dr = 16\pi/3\)</span>.  We must be prepared for quite crude
approximations that fluctuate around this exact result. As in the test
case above, we experience better results with larger number of points.
When we have such evidence for a working implementation, we can turn
the test into a proper test function. Here is an example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">test_MonteCarlo_double_circle_r</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;Check the integral of r over a circle with radius 2.&quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">g</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="n">xc</span><span class="p">,</span> <span class="n">yc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span>  <span class="c"># center</span>
        <span class="n">R</span> <span class="o">=</span> <span class="mi">2</span>          <span class="c"># radius</span>
        <span class="k">return</span>  <span class="n">R</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="p">((</span><span class="n">x</span><span class="o">-</span><span class="n">xc</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">y</span><span class="o">-</span><span class="n">yc</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>

    <span class="c"># Exact: integral of r*r*dr over circle with radius R becomes</span>
    <span class="c"># 2*pi*1/3*R**3</span>
    <span class="kn">import</span> <span class="nn">sympy</span>
    <span class="n">r</span> <span class="o">=</span> <span class="n">sympy</span><span class="o">.</span><span class="n">symbols</span><span class="p">(</span><span class="s">&#39;r&#39;</span><span class="p">)</span>
    <span class="n">I_exact</span> <span class="o">=</span> <span class="n">sympy</span><span class="o">.</span><span class="n">integrate</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">sympy</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">r</span><span class="o">*</span><span class="n">r</span><span class="p">,</span> <span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
    <span class="k">print</span> <span class="s">&#39;Exact integral:&#39;</span><span class="p">,</span> <span class="n">I_exact</span><span class="o">.</span><span class="n">evalf</span><span class="p">()</span>
    <span class="n">x0</span> <span class="o">=</span> <span class="o">-</span><span class="mi">2</span><span class="p">;</span>  <span class="n">x1</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>  <span class="n">y0</span> <span class="o">=</span> <span class="o">-</span><span class="mi">2</span><span class="p">;</span>  <span class="n">y1</span> <span class="o">=</span> <span class="mi">2</span>
    <span class="n">n</span> <span class="o">=</span> <span class="mi">1000</span>
    <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span>
    <span class="n">I_expected</span> <span class="o">=</span> <span class="mf">16.7970837117376384</span>  <span class="c"># Computed with this seed</span>
    <span class="n">I_computed</span> <span class="o">=</span> <span class="n">MonteCarlo_double</span><span class="p">(</span>
        <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">y</span><span class="o">**</span><span class="mi">2</span><span class="p">),</span>
        <span class="n">g</span><span class="p">,</span> <span class="n">x0</span><span class="p">,</span> <span class="n">x1</span><span class="p">,</span> <span class="n">y0</span><span class="p">,</span> <span class="n">y1</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
    <span class="k">print</span> <span class="s">&#39;MC approximation </span><span class="si">%d</span><span class="s"> samples): </span><span class="si">%.16f</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">n</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="n">I_computed</span><span class="p">)</span>
    <span class="k">assert</span> <span class="nb">abs</span><span class="p">(</span><span class="n">I_expected</span> <span class="o">-</span> <span class="n">I_computed</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mf">1E-15</span>
</pre></div>
</div>
<p>(See the file <a class="reference external" href="https://github.com/hplgit/prog4comp/tree/master/src/py/MC_double.py">MC_double.py</a>.)</p>
</div>
</div>
<div class="section" id="exercises-3">
<h2>Exercises<a class="headerlink" href="#exercises-3" title="Permalink to this headline">¶</a></h2>
<p>Compute by hand the area composed of two trapezoids (of equal width) that
approximates the integral <span class="math">\(\int_1^3 2x^3dx\)</span>. Make a test function
that calls the <code class="docutils literal"><span class="pre">trapezoidal</span></code> function in <code class="docutils literal"><span class="pre">trapezoidal.py</span></code>
and compares the return value with the hand-calculated value.</p>
<p><strong>Solution.</strong>
The code may be written as follows</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">trapezoidal</span> <span class="kn">import</span> <span class="n">trapezoidal</span>

<span class="k">def</span> <span class="nf">test_trapezoidal</span><span class="p">():</span>
    <span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
        <span class="k">return</span> <span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="o">**</span><span class="mi">3</span>
    <span class="n">a</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>  <span class="n">b</span> <span class="o">=</span> <span class="mi">3</span>
    <span class="n">n</span> <span class="o">=</span> <span class="mi">2</span>
    <span class="n">numerical</span> <span class="o">=</span> <span class="n">trapezoidal</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
    <span class="n">hand</span> <span class="o">=</span> <span class="mf">44.0</span>
    <span class="n">error</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">numerical</span> <span class="o">-</span> <span class="n">hand</span><span class="p">)</span>
    <span class="n">tol</span> <span class="o">=</span> <span class="mf">1E-14</span>
    <span class="k">assert</span> <span class="n">error</span> <span class="o">&lt;</span> <span class="n">tol</span><span class="p">,</span> <span class="n">error</span>

<span class="n">test_trapezoidal</span><span class="p">()</span>
</pre></div>
</div>
<p>Filename: <code class="docutils literal"><span class="pre">trapezoidal_test_func.py</span></code>.</p>
<p>Compute by hand the area composed of two rectangles (of equal width) that
approximates the integral <span class="math">\(\int_1^3 2x^3dx\)</span>. Make a test function
that calls the <code class="docutils literal"><span class="pre">midpoint</span></code> function in <code class="docutils literal"><span class="pre">midpoint.py</span></code>
and compares the return value with the hand-calculated value.</p>
<p><strong>Solution.</strong>
The code may be written as follows</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">midpoint</span> <span class="kn">import</span> <span class="n">midpoint</span>

<span class="k">def</span> <span class="nf">test_midpoint</span><span class="p">():</span>
    <span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
        <span class="k">return</span> <span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="o">**</span><span class="mi">3</span>
    <span class="n">a</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>  <span class="n">b</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
    <span class="n">n</span> <span class="o">=</span> <span class="mi">2</span>
    <span class="n">numerical</span> <span class="o">=</span> <span class="n">midpoint</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
    <span class="n">hand</span> <span class="o">=</span> <span class="mf">38.0</span>
    <span class="n">error</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">numerical</span> <span class="o">-</span> <span class="n">hand</span><span class="p">)</span>
    <span class="n">tol</span> <span class="o">=</span> <span class="mf">1E-14</span>
    <span class="k">assert</span> <span class="n">error</span> <span class="o">&lt;</span> <span class="n">tol</span><span class="p">,</span> <span class="n">error</span>

<span class="n">test_midpoint</span><span class="p">()</span>
</pre></div>
</div>
<p>Filename: <code class="docutils literal"><span class="pre">midpoint_test_func.py</span></code>.</p>
<p>Apply the <code class="docutils literal"><span class="pre">trapezoidal</span></code> and <code class="docutils literal"><span class="pre">midpoint</span></code> functions to compute
the integral <span class="math">\(\int_2^6 x(x -1)dx\)</span> with 2 and 100 subintervals.
Compute the error too.</p>
<p><strong>Solution.</strong>
The code may be written as follows</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">trapezoidal</span> <span class="kn">import</span> <span class="n">trapezoidal</span>
<span class="kn">from</span> <span class="nn">midpoint</span> <span class="kn">import</span> <span class="n">midpoint</span>

<span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">x</span><span class="o">*</span><span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>

<span class="n">a</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>  <span class="n">b</span> <span class="o">=</span> <span class="mi">6</span><span class="p">;</span>
<span class="n">n</span> <span class="o">=</span> <span class="mi">100</span>

<span class="n">numerical_trap</span> <span class="o">=</span> <span class="n">trapezoidal</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
<span class="n">numerical_mid</span>  <span class="o">=</span> <span class="n">midpoint</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>

<span class="c"># Compute exact integral by sympy</span>
<span class="kn">import</span> <span class="nn">sympy</span> <span class="kn">as</span> <span class="nn">sp</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">symbols</span><span class="p">(</span><span class="s">&#39;x&#39;</span><span class="p">)</span>
<span class="n">F</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">integrate</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
<span class="n">exact</span> <span class="o">=</span> <span class="n">F</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span> <span class="o">-</span> <span class="n">F</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
<span class="n">exact</span> <span class="o">=</span> <span class="n">exact</span><span class="o">.</span><span class="n">evalf</span><span class="p">()</span>

<span class="n">error_trap</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">numerical_trap</span> <span class="o">-</span> <span class="n">exact</span><span class="p">)</span>
<span class="n">error_mid</span>  <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">numerical_mid</span> <span class="o">-</span> <span class="n">exact</span><span class="p">)</span>

<span class="k">print</span> <span class="s">&#39;For n = </span><span class="si">%d</span><span class="s">, we get:&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">n</span><span class="p">)</span>
<span class="k">print</span> <span class="s">&#39;Numerical trapezoid: </span><span class="si">%g</span><span class="s"> , Error: </span><span class="si">%g</span><span class="s">&#39;</span> <span class="o">%</span> \
                                 <span class="p">(</span><span class="n">numerical_trap</span><span class="p">,</span><span class="n">error_trap</span><span class="p">)</span>
<span class="k">print</span> <span class="s">&#39;Numerical midpoint: </span><span class="si">%g</span><span class="s"> , Error: </span><span class="si">%g</span><span class="s">&#39;</span> <span class="o">%</span> \
                                 <span class="p">(</span><span class="n">numerical_mid</span><span class="p">,</span><span class="n">error_mid</span><span class="p">)</span>
</pre></div>
</div>
<p>In the code, we have taken the opportunity to show
how commenting often is used to switch between two
code fragments, typically single statements. The
alternatives <code class="docutils literal"><span class="pre">n</span> <span class="pre">=</span> <span class="pre">2</span></code> and <code class="docutils literal"><span class="pre">n</span> <span class="pre">=</span> <span class="pre">100</span></code> are switched by
removing/adding the comment sign <code class="docutils literal"><span class="pre">#</span></code>, before running
the code anew. Another alternative would of course be
to ask the user for the value of <code class="docutils literal"><span class="pre">n</span></code>.
Running the program with <code class="docutils literal"><span class="pre">n</span> <span class="pre">=</span> <span class="pre">2</span></code>, produces the following printout:</p>
<div class="highlight-text"><div class="highlight"><pre>For n = 2, we get:
Numerical trapezoid: 56 , Error: 2.667
Numerical midpoint: 52 , Error: 1.333
</pre></div>
</div>
<p>while running it with <code class="docutils literal"><span class="pre">n</span> <span class="pre">=</span> <span class="pre">100</span></code> gives:</p>
<div class="highlight-text"><div class="highlight"><pre>For n = 100, we get:
Numerical trapezoid: 53.3344 , Error: 0.0014
Numerical midpoint: 53.3328 , Error: 0.0002
</pre></div>
</div>
<p>The analytical value of the integral is 53.333 (rounded).</p>
<p>Filename: <code class="docutils literal"><span class="pre">integrate_parabola.py</span></code>.</p>
<p>We consider integrating the sine function: <span class="math">\(\int_0^b \sin (x)dx\)</span>.</p>
<p><strong>a)</strong>
Let <span class="math">\(b=\pi\)</span> and use two intervals in the trapezoidal and midpoint method.
Compute the integral by hand and illustrate how the two numerical
methods approximates the integral. Compare with the exact value.</p>
<p><strong>Solution.</strong>
Analytically, the integral computes to 2. By hand, with the trapezoidal method,
we get 1.570. Graphically (Figure <a class="reference internal" href="#fig-intgr-sine-a-trap"><span class="std std-ref">The integral computed with the trapezoidal method (n = 2)</span></a>), it is clear that
the numerical approach will have to under-estimate the true result.</p>
<p>The area under the blue graph in Figure <a class="reference internal" href="#fig-intgr-sine-a-trap"><span class="std std-ref">The integral computed with the trapezoidal method (n = 2)</span></a>
corresponds to the &#8220;true&#8221; area under the graph of the integrand. The area
under the red graph corresponds to what you get with the trapezoidal method and
two intervals.</p>
<div class="figure" id="id6">
<span id="fig-intgr-sine-a-trap"></span><a class="reference internal image-reference" href="_images/integrate_sine_a_trap.png"><img alt="_images/integrate_sine_a_trap.png" src="_images/integrate_sine_a_trap.png" style="width: 400px;" /></a>
<p class="caption"><span class="caption-text"><em>The integral computed with the trapezoidal method (n = 2)</em></span></p>
</div>
<p>By hand, with the midpoint method, we get 2.221. Graphically (Figure <a class="reference internal" href="#fig-intgr-sine-a-mid"><span class="std std-ref">The integral computed with the midpoint method (n = 2)</span></a>),
we might see that the numerical approach will have to over-estimate the true result.
Again, the area under the blue graph in Figure <a class="reference internal" href="#fig-intgr-sine-a-mid"><span class="std std-ref">The integral computed with the midpoint method (n = 2)</span></a>
corresponds to the &#8220;true&#8221; area under the graph of the integrand. The area
under the red graph corresponds to what you get with the midpoint method and
two intervals.</p>
<div class="figure" id="id7">
<span id="fig-intgr-sine-a-mid"></span><a class="reference internal image-reference" href="_images/integrate_sine_a_mid.png"><img alt="_images/integrate_sine_a_mid.png" src="_images/integrate_sine_a_mid.png" style="width: 400px;" /></a>
<p class="caption"><span class="caption-text"><em>The integral computed with the midpoint method (n = 2)</em></span></p>
</div>
<p><strong>b)</strong>
Do a) when <span class="math">\(b=2\pi\)</span>.</p>
<p><strong>Solution.</strong>
Analytically, the integral computes to zero. In this case, both numerical methods will correctly calculate the integral to zero even with just two intervals! Graphically, we see that they arrive at zero for &#8220;different reasons&#8221;. The trapezoidal method constructs both its trapezoids by use of the function (integrand) value at the midpoint of the whole interval. However, there the integrand crosses the x-axis, i.e. it evaluates to zero. The &#8220;area&#8221; computed by the trapezoidal method becomes the zero area located &#8220;between&#8221; the green graph and the x-axis in Figure <a class="reference internal" href="#fig-intgr-sine-b-trap-mid"><span class="std std-ref">The integral computed with the trapezoidal and midpoint method (n = 2)</span></a>. The midpoint method computes the areas of two rectangles (red graph in Figure <a class="reference internal" href="#fig-intgr-sine-b-trap-mid"><span class="std std-ref">The integral computed with the trapezoidal and midpoint method (n = 2)</span></a>), but since the signs of these equal areas differ, they add to zero.</p>
<div class="figure" id="id8">
<span id="fig-intgr-sine-b-trap-mid"></span><a class="reference internal image-reference" href="_images/integrate_sine_b_trap_mid.png"><img alt="_images/integrate_sine_b_trap_mid.png" src="_images/integrate_sine_b_trap_mid.png" style="width: 400px;" /></a>
<p class="caption"><span class="caption-text"><em>The integral computed with the trapezoidal and midpoint method (n = 2)</em></span></p>
</div>
<p>Filename: <code class="docutils literal"><span class="pre">integrate_sine.pdf</span></code>.</p>
<p>Modify the file <code class="docutils literal"><span class="pre">test_trapezoidal.py</span></code> such that the
three tests are applied to the function <code class="docutils literal"><span class="pre">midpoint</span></code> implementing
the midpoint method for integration.</p>
<p><strong>Solution.</strong>
Note that also the midpoint method will do an exact (to within machine precision)
integration when the integrand is a straight line. This is so, since the errors
from each rectangle will cancel. The code reads:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">midpoint</span> <span class="kn">import</span> <span class="n">midpoint</span>

<span class="k">def</span> <span class="nf">test_midpoint_one_exact_result</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;Compare one hand-computed result.&quot;&quot;&quot;</span>
    <span class="kn">from</span> <span class="nn">math</span> <span class="kn">import</span> <span class="n">exp</span>
    <span class="n">v</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">t</span><span class="p">:</span> <span class="mi">3</span><span class="o">*</span><span class="p">(</span><span class="n">t</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="n">exp</span><span class="p">(</span><span class="n">t</span><span class="o">**</span><span class="mi">3</span><span class="p">)</span>
    <span class="n">n</span> <span class="o">=</span> <span class="mi">2</span>
    <span class="n">numerical</span> <span class="o">=</span> <span class="n">midpoint</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
    <span class="n">exact</span> <span class="o">=</span> <span class="mf">1.3817914596908085</span>
    <span class="n">err</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">exact</span> <span class="o">-</span> <span class="n">numerical</span><span class="p">)</span>
    <span class="n">tol</span> <span class="o">=</span> <span class="mf">1E-14</span>
    <span class="k">assert</span> <span class="n">err</span> <span class="o">&lt;</span> <span class="n">tol</span><span class="p">,</span> <span class="n">err</span>

<span class="k">def</span> <span class="nf">test_midpoint_linear</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;Check that linear functions are integrated exactly&quot;&quot;&quot;</span>
    <span class="c"># ...they should, since errros from each rectangle cancel</span>
    <span class="n">f</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="mi">6</span><span class="o">*</span><span class="n">x</span> <span class="o">-</span> <span class="mi">4</span>
    <span class="n">F</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="mi">3</span><span class="o">*</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="mi">4</span><span class="o">*</span><span class="n">x</span>  <span class="c"># Anti-derivative</span>
    <span class="n">a</span> <span class="o">=</span> <span class="mf">1.2</span><span class="p">;</span>  <span class="n">b</span> <span class="o">=</span> <span class="mf">4.4</span>
    <span class="n">exact</span> <span class="o">=</span> <span class="n">F</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="o">-</span> <span class="n">F</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="n">tol</span> <span class="o">=</span> <span class="mf">1E-14</span>
    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">21</span><span class="p">:</span>
        <span class="n">numerical</span> <span class="o">=</span> <span class="n">midpoint</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
        <span class="n">err</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">exact</span> <span class="o">-</span> <span class="n">numerical</span><span class="p">)</span>
        <span class="k">assert</span> <span class="n">err</span> <span class="o">&lt;</span> <span class="n">tol</span><span class="p">,</span> <span class="s">&#39;n = </span><span class="si">%d</span><span class="s">, err = </span><span class="si">%g</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="n">err</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">test_midpoint_conv_rate</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;Check empirical convergence rates against the expected -2.&quot;&quot;&quot;</span>
    <span class="kn">from</span> <span class="nn">math</span> <span class="kn">import</span> <span class="n">exp</span>
    <span class="n">v</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">t</span><span class="p">:</span> <span class="mi">3</span><span class="o">*</span><span class="p">(</span><span class="n">t</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="n">exp</span><span class="p">(</span><span class="n">t</span><span class="o">**</span><span class="mi">3</span><span class="p">)</span>
    <span class="n">V</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">t</span><span class="p">:</span> <span class="n">exp</span><span class="p">(</span><span class="n">t</span><span class="o">**</span><span class="mi">3</span><span class="p">)</span>
    <span class="n">a</span> <span class="o">=</span> <span class="mf">1.1</span><span class="p">;</span>  <span class="n">b</span> <span class="o">=</span> <span class="mf">1.9</span>
    <span class="n">r</span> <span class="o">=</span> <span class="n">convergence_rates</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="mi">14</span><span class="p">)</span>
    <span class="k">print</span> <span class="n">r</span>
    <span class="n">tol</span> <span class="o">=</span> <span class="mf">0.01</span>
    <span class="k">assert</span> <span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">r</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">tol</span><span class="p">,</span> <span class="n">r</span><span class="p">[</span><span class="o">-</span><span class="mi">4</span><span class="p">:]</span>

<span class="k">def</span> <span class="nf">convergence_rates</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">F</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">num_experiments</span><span class="o">=</span><span class="mi">14</span><span class="p">):</span>
    <span class="kn">from</span> <span class="nn">math</span> <span class="kn">import</span> <span class="n">log</span>
    <span class="kn">from</span> <span class="nn">numpy</span> <span class="kn">import</span> <span class="n">zeros</span>
    <span class="n">exact</span> <span class="o">=</span> <span class="n">F</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="o">-</span> <span class="n">F</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">(</span><span class="n">num_experiments</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
    <span class="n">E</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">(</span><span class="n">num_experiments</span><span class="p">)</span>
    <span class="n">r</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">(</span><span class="n">num_experiments</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_experiments</span><span class="p">):</span>
        <span class="n">n</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span><span class="o">**</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">numerical</span> <span class="o">=</span> <span class="n">midpoint</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">n</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="n">E</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">exact</span> <span class="o">-</span> <span class="n">numerical</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">r_im1</span> <span class="o">=</span> <span class="n">log</span><span class="p">(</span><span class="n">E</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">/</span><span class="n">E</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span><span class="o">/</span><span class="n">log</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">n</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="o">/</span><span class="n">n</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">r</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="s">&#39;</span><span class="si">%.2f</span><span class="s">&#39;</span> <span class="o">%</span> <span class="n">r_im1</span><span class="p">)</span>  <span class="c"># Truncate, two decimals</span>
    <span class="k">return</span> <span class="n">r</span>

<span class="n">test_midpoint_one_exact_result</span><span class="p">()</span>
<span class="n">test_midpoint_linear</span><span class="p">()</span>
<span class="n">test_midpoint_conv_rate</span><span class="p">()</span>
</pre></div>
</div>
<p>Filename: <code class="docutils literal"><span class="pre">test_midpoint.py</span></code>.</p>
<p>The trapezoidal method integrates linear functions exactly, and this
property was used in the test function <code class="docutils literal"><span class="pre">test_trapezoidal_linear</span></code> in the file
<code class="docutils literal"><span class="pre">test_trapezoidal.py</span></code>. Change the function used in
the section <span class="xref std std-ref">sec:integrals:testprocs</span> to <span class="math">\(f(x)=6\cdot 10^8 x - 4\cdot 10^6\)</span>
and rerun the test. What happens? How must you change the test
to make it useful? How does the convergence rate test behave? Any need
for adjustment?</p>
<p><strong>Solution.</strong>
With the new function given, we get the error message that includes:</p>
<div class="highlight-text"><div class="highlight"><pre>AssertionError: n = 2, err = 9.53674e-07
</pre></div>
</div>
<p>The numerical calculation then obviously differs from the exact value by
more than what is specified in the tolerance <code class="docutils literal"><span class="pre">tol</span></code>. We may understand this
by considering the new function, i.e., <span class="math">\(f(x)=6\cdot 10^8 x - 4\cdot 10^6\)</span>.
Any rounding error in <span class="math">\(x\)</span> will get magnified big time by the factor <span class="math">\(6\cdot 10^8\)</span> in front,
i.e. the slope of the line. This makes the numerical calculation more inaccurate than previously.
To fix this problem, we have several options. One possibility is to relax the tolerance, but
this is not very satisfactory. After all, the calculation is supposed to be &#8220;exact&#8221; for a straight
line. Another alternative is to introduce a new integration variable such
that we scale the interval <span class="math">\([a,b]\)</span> into <span class="math">\([\frac{a}{6\cdot 10^8},\frac{b}{6\cdot 10^8}]\)</span>, as
this will neutralize the huge factor in front of <span class="math">\(x\)</span>, bringing the accuracy back to where it was previously. This
alternative is implemented in
<a class="reference external" href="https://github.com/hplgit/prog4comp/tree/master/src/py/test_trapezoidal2.py">test_trapezoidal2.py</a>.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">trapezoidal</span> <span class="kn">import</span> <span class="n">trapezoidal</span>

<span class="k">def</span> <span class="nf">test_trapezoidal_linear_scale</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;Check that linear functions are integrated exactly&quot;&quot;&quot;</span>
    <span class="n">f</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="mf">6E8</span><span class="o">*</span><span class="n">x</span> <span class="o">-</span> <span class="mf">4E6</span>
    <span class="n">F</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="mf">3E8</span><span class="o">*</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="mf">4E6</span><span class="o">*</span><span class="n">x</span>  <span class="c"># Anti-derivative</span>
    <span class="c">#a = 1.2;  b = 4.4</span>
    <span class="n">a</span> <span class="o">=</span> <span class="mf">1.2</span><span class="o">/</span><span class="mf">6E8</span><span class="p">;</span>  <span class="n">b</span> <span class="o">=</span> <span class="mf">4.4</span><span class="o">/</span><span class="mf">6E8</span>       <span class="c"># Scale interval down</span>
    <span class="n">exact</span> <span class="o">=</span> <span class="n">F</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="o">-</span> <span class="n">F</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="n">tol</span> <span class="o">=</span> <span class="mf">1E-14</span>
    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">21</span><span class="p">:</span>
        <span class="n">numerical</span> <span class="o">=</span> <span class="n">trapezoidal</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
        <span class="n">err</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">exact</span> <span class="o">-</span> <span class="n">numerical</span><span class="p">)</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="s">&#39;n = </span><span class="si">%d</span><span class="s">, err = </span><span class="si">%g</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">err</span><span class="p">)</span>
        <span class="k">assert</span> <span class="n">err</span> <span class="o">&lt;</span> <span class="n">tol</span><span class="p">,</span> <span class="n">msg</span>
        <span class="k">print</span> <span class="n">msg</span>
</pre></div>
</div>
<p>A third alternative is to use the module <code class="docutils literal"><span class="pre">decimal</span></code> that comes with Python, which
allows number precision to be altered by the programmer. An alternative,
better suited for numerical computing, is the <code class="docutils literal"><span class="pre">mpmath</span></code> module in SymPy (since
it supports standard mathematical functions such as <code class="docutils literal"><span class="pre">sin</span></code> and <code class="docutils literal"><span class="pre">cos</span></code> with
arbitrary precision, while <code class="docutils literal"><span class="pre">decimal</span></code> can only the standard arithmetics with
arbitrary precision).</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">trapezoidal</span> <span class="kn">import</span> <span class="n">trapezoidal</span>

<span class="k">def</span> <span class="nf">test_trapezoidal_linear_scale</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;Check that linear functions are integrated exactly&quot;&quot;&quot;</span>
    <span class="n">f</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="mf">6E8</span><span class="o">*</span><span class="n">x</span> <span class="o">-</span> <span class="mf">4E6</span>
    <span class="n">F</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="mf">3E8</span><span class="o">*</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="mf">4E6</span><span class="o">*</span><span class="n">x</span>  <span class="c"># Anti-derivative</span>
    <span class="c">#a = 1.2;  b = 4.4</span>
    <span class="n">a</span> <span class="o">=</span> <span class="mf">1.2</span><span class="o">/</span><span class="mf">6E8</span><span class="p">;</span>  <span class="n">b</span> <span class="o">=</span> <span class="mf">4.4</span><span class="o">/</span><span class="mf">6E8</span>       <span class="c"># Scale interval down</span>
    <span class="n">exact</span> <span class="o">=</span> <span class="n">F</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="o">-</span> <span class="n">F</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="n">tol</span> <span class="o">=</span> <span class="mf">1E-14</span>
    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">21</span><span class="p">:</span>
        <span class="n">numerical</span> <span class="o">=</span> <span class="n">trapezoidal</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
        <span class="n">err</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">exact</span> <span class="o">-</span> <span class="n">numerical</span><span class="p">)</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="s">&#39;n = </span><span class="si">%d</span><span class="s">, err = </span><span class="si">%g</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">err</span><span class="p">)</span>
        <span class="k">assert</span> <span class="n">err</span> <span class="o">&lt;</span> <span class="n">tol</span><span class="p">,</span> <span class="n">msg</span>
        <span class="k">print</span> <span class="n">msg</span>

<span class="k">def</span> <span class="nf">test_trapezoidal_linear_reldiff</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Check that linear functions are integrated exactly.</span>
<span class="sd">    Use relative and not absolute difference.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">f</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="mf">6E8</span><span class="o">*</span><span class="n">x</span> <span class="o">-</span> <span class="mf">4E6</span>
    <span class="n">F</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="mf">3E8</span><span class="o">*</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="mf">4E6</span><span class="o">*</span><span class="n">x</span>  <span class="c"># Anti-derivative</span>
    <span class="n">a</span> <span class="o">=</span> <span class="mf">1.2</span><span class="p">;</span>  <span class="n">b</span> <span class="o">=</span> <span class="mf">4.4</span>               <span class="c"># Scale interval down</span>
    <span class="n">exact</span> <span class="o">=</span> <span class="n">F</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="o">-</span> <span class="n">F</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="n">tol</span> <span class="o">=</span> <span class="mf">1E-14</span>
    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">21</span><span class="p">:</span>
        <span class="n">numerical</span> <span class="o">=</span> <span class="n">trapezoidal</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
        <span class="n">err</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">exact</span> <span class="o">-</span> <span class="n">numerical</span><span class="p">)</span><span class="o">/</span><span class="n">exact</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="s">&#39;n = </span><span class="si">%d</span><span class="s">, err = </span><span class="si">%g</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">err</span><span class="p">)</span>
        <span class="k">assert</span> <span class="n">err</span> <span class="o">&lt;</span> <span class="n">tol</span><span class="p">,</span> <span class="n">msg</span>
        <span class="k">print</span> <span class="n">msg</span>

<span class="k">def</span> <span class="nf">test_trapezoidal_conv_rate</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;Check empirical convergence rates against the expected -2.&quot;&quot;&quot;</span>
    <span class="c">#from math import exp</span>
    <span class="n">f</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="mf">6E8</span><span class="o">*</span><span class="n">x</span> <span class="o">-</span> <span class="mf">4E6</span>
    <span class="n">F</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="mf">3E8</span><span class="o">*</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="mf">4E6</span><span class="o">*</span><span class="n">x</span>  <span class="c"># Anti-derivative</span>
    <span class="n">a</span> <span class="o">=</span> <span class="mf">1.1</span><span class="p">;</span>  <span class="n">b</span> <span class="o">=</span> <span class="mf">1.9</span>
    <span class="n">r</span> <span class="o">=</span> <span class="n">convergence_rates</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">F</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="mi">14</span><span class="p">)</span>
    <span class="k">print</span> <span class="n">r</span>
    <span class="n">tol</span> <span class="o">=</span> <span class="mf">0.01</span>
    <span class="k">assert</span> <span class="nb">abs</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">r</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">tol</span><span class="p">,</span> <span class="n">r</span><span class="p">[</span><span class="o">-</span><span class="mi">4</span><span class="p">:]</span>

<span class="k">def</span> <span class="nf">convergence_rates</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">F</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">num_experiments</span><span class="o">=</span><span class="mi">14</span><span class="p">):</span>
    <span class="kn">from</span> <span class="nn">math</span> <span class="kn">import</span> <span class="n">log</span>
    <span class="kn">from</span> <span class="nn">numpy</span> <span class="kn">import</span> <span class="n">zeros</span>
    <span class="n">exact</span> <span class="o">=</span> <span class="n">F</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="o">-</span> <span class="n">F</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">(</span><span class="n">num_experiments</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
    <span class="n">E</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">(</span><span class="n">num_experiments</span><span class="p">)</span>
    <span class="n">r</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">(</span><span class="n">num_experiments</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_experiments</span><span class="p">):</span>
        <span class="n">n</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span><span class="o">**</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">numerical</span> <span class="o">=</span> <span class="n">trapezoidal</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">n</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="n">E</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">exact</span> <span class="o">-</span> <span class="n">numerical</span><span class="p">)</span>
        <span class="k">print</span> <span class="n">E</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">r_im1</span> <span class="o">=</span> <span class="n">log</span><span class="p">(</span><span class="n">E</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">/</span><span class="n">E</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span><span class="o">/</span><span class="n">log</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">n</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="o">/</span><span class="n">n</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">r</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="s">&#39;</span><span class="si">%.2f</span><span class="s">&#39;</span> <span class="o">%</span> <span class="n">r_im1</span><span class="p">)</span>  <span class="c"># Truncate, two decimals</span>
    <span class="k">return</span> <span class="n">r</span>

<span class="n">test_trapezoidal_linear_scale</span><span class="p">()</span>
<span class="n">test_trapezoidal_linear_reldiff</span><span class="p">()</span>
<span class="n">test_trapezoidal_conv_rate</span><span class="p">()</span>
</pre></div>
</div>
<p>The best alternative, however, is to consider relative differences instead
of absolute differences. That is, we compute <code class="docutils literal"><span class="pre">(exact</span> <span class="pre">-</span> <span class="pre">numerical)/exact</span></code>
instead of just <code class="docutils literal"><span class="pre">exact</span> <span class="pre">-</span> <span class="pre">numerical</span></code>. This relative error is <span class="math">\(10^{-16}\)</span>
even if we compute with very big numbers.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">test_trapezoidal_linear_reldiff</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Check that linear functions are integrated exactly.</span>
<span class="sd">    Use relative and not absolute difference.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">f</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="mf">6E8</span><span class="o">*</span><span class="n">x</span> <span class="o">-</span> <span class="mf">4E6</span>
    <span class="n">F</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="mf">3E8</span><span class="o">*</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="mf">4E6</span><span class="o">*</span><span class="n">x</span>  <span class="c"># Anti-derivative</span>
    <span class="n">a</span> <span class="o">=</span> <span class="mf">1.2</span><span class="p">;</span>  <span class="n">b</span> <span class="o">=</span> <span class="mf">4.4</span>               <span class="c"># Scale interval down</span>
    <span class="n">exact</span> <span class="o">=</span> <span class="n">F</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="o">-</span> <span class="n">F</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="n">tol</span> <span class="o">=</span> <span class="mf">1E-14</span>
    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">21</span><span class="p">:</span>
        <span class="n">numerical</span> <span class="o">=</span> <span class="n">trapezoidal</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
        <span class="n">err</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">exact</span> <span class="o">-</span> <span class="n">numerical</span><span class="p">)</span><span class="o">/</span><span class="n">exact</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="s">&#39;n = </span><span class="si">%d</span><span class="s">, err = </span><span class="si">%g</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">err</span><span class="p">)</span>
        <span class="k">assert</span> <span class="n">err</span> <span class="o">&lt;</span> <span class="n">tol</span><span class="p">,</span> <span class="n">msg</span>
        <span class="k">print</span> <span class="n">msg</span>

<span class="k">def</span> <span class="nf">test_trapezoidal_conv_rate</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;Check empirical convergence rates against the expected -2.&quot;&quot;&quot;</span>
    <span class="c">#from math import exp</span>
    <span class="n">f</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="mf">6E8</span><span class="o">*</span><span class="n">x</span> <span class="o">-</span> <span class="mf">4E6</span>
    <span class="n">F</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="mf">3E8</span><span class="o">*</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="mf">4E6</span><span class="o">*</span><span class="n">x</span>  <span class="c"># Anti-derivative</span>
    <span class="n">a</span> <span class="o">=</span> <span class="mf">1.1</span><span class="p">;</span>  <span class="n">b</span> <span class="o">=</span> <span class="mf">1.9</span>
    <span class="n">r</span> <span class="o">=</span> <span class="n">convergence_rates</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">F</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="mi">14</span><span class="p">)</span>
    <span class="k">print</span> <span class="n">r</span>
    <span class="n">tol</span> <span class="o">=</span> <span class="mf">0.01</span>
    <span class="k">assert</span> <span class="nb">abs</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">r</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">tol</span><span class="p">,</span> <span class="n">r</span><span class="p">[</span><span class="o">-</span><span class="mi">4</span><span class="p">:]</span>

<span class="k">def</span> <span class="nf">convergence_rates</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">F</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">num_experiments</span><span class="o">=</span><span class="mi">14</span><span class="p">):</span>
    <span class="kn">from</span> <span class="nn">math</span> <span class="kn">import</span> <span class="n">log</span>
    <span class="kn">from</span> <span class="nn">numpy</span> <span class="kn">import</span> <span class="n">zeros</span>
    <span class="n">exact</span> <span class="o">=</span> <span class="n">F</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="o">-</span> <span class="n">F</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">(</span><span class="n">num_experiments</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
    <span class="n">E</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">(</span><span class="n">num_experiments</span><span class="p">)</span>
    <span class="n">r</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">(</span><span class="n">num_experiments</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_experiments</span><span class="p">):</span>
        <span class="n">n</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span><span class="o">**</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">numerical</span> <span class="o">=</span> <span class="n">trapezoidal</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">n</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="n">E</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">exact</span> <span class="o">-</span> <span class="n">numerical</span><span class="p">)</span>
        <span class="k">print</span> <span class="n">E</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">r_im1</span> <span class="o">=</span> <span class="n">log</span><span class="p">(</span><span class="n">E</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">/</span><span class="n">E</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span><span class="o">/</span><span class="n">log</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">n</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="o">/</span><span class="n">n</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">r</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="s">&#39;</span><span class="si">%.2f</span><span class="s">&#39;</span> <span class="o">%</span> <span class="n">r_im1</span><span class="p">)</span>  <span class="c"># Truncate, two decimals</span>
    <span class="k">return</span> <span class="n">r</span>
</pre></div>
</div>
<p>Computing convergence rates is not meaningful in this test, because the
error is mathematically zero.</p>
<p>Filename: <code class="docutils literal"><span class="pre">test_trapezoidal2.py</span></code>.</p>
<p>We want to test how the <code class="docutils literal"><span class="pre">trapezoidal</span></code> function works for the integral
<span class="math">\(\int_0^4\sqrt{x}dx\)</span>. Two of the tests in <code class="docutils literal"><span class="pre">test_trapezoidal.py</span></code>
are meaningful for this integral. Compute by hand the result of
using 2 or 3 trapezoids and modify the <code class="docutils literal"><span class="pre">test_trapezoidal_one_exact_result</span></code>
function accordingly. Then modify <code class="docutils literal"><span class="pre">test_trapezoidal_conv_rate</span></code>
to handle the square root integral.</p>
<p><strong>Solution.</strong>
Adjustments to the code are made according to the remark below and
hand calculations are written into the code. The code then reads:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">trapezoidal</span> <span class="kn">import</span> <span class="n">trapezoidal</span>

<span class="k">def</span> <span class="nf">test_trapezoidal_one_exact_result</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;Compare one hand-computed result.&quot;&quot;&quot;</span>
    <span class="n">f</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">**</span><span class="mf">0.5</span>
    <span class="n">tol</span> <span class="o">=</span> <span class="mf">1E-14</span>
    <span class="n">exact</span> <span class="o">=</span> <span class="p">[</span><span class="mf">4.82842712474619</span><span class="p">,</span> <span class="mf">5.050258266979605</span><span class="p">]</span> <span class="c"># n=2, n=3</span>
    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]:</span>
        <span class="n">numerical</span> <span class="o">=</span> <span class="n">trapezoidal</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
        <span class="n">err</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">exact</span><span class="p">[</span><span class="n">n</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="n">numerical</span><span class="p">)</span>
        <span class="k">assert</span> <span class="n">err</span> <span class="o">&lt;</span> <span class="n">tol</span><span class="p">,</span> <span class="n">err</span>

<span class="k">def</span> <span class="nf">test_trapezoidal_conv_rate</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;Check empirical convergence rates against the expected -2.&quot;&quot;&quot;</span>
    <span class="kn">from</span> <span class="nn">math</span> <span class="kn">import</span> <span class="n">exp</span>
    <span class="n">f</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">**</span><span class="mf">0.5</span>
    <span class="n">F</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="p">(</span><span class="mf">2.0</span><span class="o">/</span><span class="mi">3</span><span class="p">)</span><span class="o">*</span><span class="n">x</span><span class="o">**</span><span class="p">(</span><span class="mf">3.0</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">a</span> <span class="o">=</span> <span class="mf">0.0</span> <span class="o">+</span> <span class="mf">0.1</span><span class="p">;</span>  <span class="n">b</span> <span class="o">=</span> <span class="mf">4.0</span>         <span class="c"># a adjusted by 0.1</span>
    <span class="n">r</span> <span class="o">=</span> <span class="n">convergence_rates</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">F</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="mi">14</span><span class="p">)</span>
    <span class="k">print</span> <span class="n">r</span>
    <span class="n">tol</span> <span class="o">=</span> <span class="mf">0.01</span>
    <span class="k">assert</span> <span class="nb">abs</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">r</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">tol</span><span class="p">,</span> <span class="n">r</span><span class="p">[</span><span class="o">-</span><span class="mi">4</span><span class="p">:]</span>

<span class="k">def</span> <span class="nf">convergence_rates</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">F</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">num_experiments</span><span class="o">=</span><span class="mi">14</span><span class="p">):</span>
    <span class="kn">from</span> <span class="nn">math</span> <span class="kn">import</span> <span class="n">log</span>
    <span class="kn">from</span> <span class="nn">numpy</span> <span class="kn">import</span> <span class="n">zeros</span>
    <span class="n">exact</span> <span class="o">=</span> <span class="n">F</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="o">-</span> <span class="n">F</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">(</span><span class="n">num_experiments</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
    <span class="n">E</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">(</span><span class="n">num_experiments</span><span class="p">)</span>
    <span class="n">r</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">(</span><span class="n">num_experiments</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_experiments</span><span class="p">):</span>
        <span class="n">n</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span><span class="o">**</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">numerical</span> <span class="o">=</span> <span class="n">trapezoidal</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">n</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="n">E</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">exact</span> <span class="o">-</span> <span class="n">numerical</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">r_im1</span> <span class="o">=</span> <span class="n">log</span><span class="p">(</span><span class="n">E</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">/</span><span class="n">E</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span><span class="o">/</span><span class="n">log</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">n</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="o">/</span><span class="n">n</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">r</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="s">&#39;</span><span class="si">%.2f</span><span class="s">&#39;</span> <span class="o">%</span> <span class="n">r_im1</span><span class="p">)</span>  <span class="c"># Truncate to two decimals</span>
    <span class="k">return</span> <span class="n">r</span>

<span class="n">test_trapezoidal_one_exact_result</span><span class="p">()</span>
<span class="n">test_trapezoidal_conv_rate</span><span class="p">()</span>
</pre></div>
</div>
<p>Filename: <code class="docutils literal"><span class="pre">test_trapezoidal3.py</span></code>.</p>
<div class="section" id="remarks-5">
<h3>Remarks<a class="headerlink" href="#remarks-5" title="Permalink to this headline">¶</a></h3>
<p>The convergence rate test fails. Printing out <code class="docutils literal"><span class="pre">r</span></code> shows that the
actual convergence rate for this integral is <span class="math">\(-1.5\)</span> and not <span class="math">\(-2\)</span>.
The reason is that the <a class="reference external" href="http://en.wikipedia.org/wiki/Trapezoidal_rule#Error_analysis">error in the trapezoidal method</a>
is <span class="math">\(-(b-a)^3n^{-2}f''(\xi)\)</span> for some (unknown) <span class="math">\(\xi\in [a,b]\)</span>.
With <span class="math">\(f(x)=\sqrt{x}\)</span>, <span class="math">\(f''(\xi)\rightarrow -\infty\)</span> as <span class="math">\(\xi\rightarrow 0\)</span>,
pointing to a potential problem in the size of the error.
Running a test with <span class="math">\(a&gt;0\)</span>, say <span class="math">\(\int_{0.1}^4\sqrt{x}dx\)</span> shows that
the convergence rate is indeed restored to -2.</p>
<div class="section" id="exercise-37-rectangle-methods">
<span id="sec-exer-rectanglemethod"></span><h4>Exercise 37: Rectangle methods<a class="headerlink" href="#exercise-37-rectangle-methods" title="Permalink to this headline">¶</a></h4>
<p>The midpoint method divides the interval of integration into equal-sized
subintervals and approximates the integral in each subinterval by
a rectangle whose height equals the function value at the midpoint of
the subinterval. Instead, one might use either the left or right end of
the subinterval as illustrated in Figure <a class="reference internal" href="#fig-vcarrectangle"><span class="std std-ref">Illustration of the rectangle method with evaluating the rectangle height by either the left or right point</span></a>.
This defines a <em>rectangle method</em> of integration. The height of the
rectangle can be based on the left or right end or the midpoint.</p>
<div class="figure" id="id9">
<span id="fig-vcarrectangle"></span><a class="reference internal image-reference" href="_images/viz_rectangle.png"><img alt="_images/viz_rectangle.png" src="_images/viz_rectangle.png" style="width: 800px;" /></a>
<p class="caption"><span class="caption-text"><em>Illustration of the rectangle method with evaluating the rectangle height by either the left or right point</em></span></p>
</div>
<p><strong>a)</strong>
Write a function <code class="docutils literal"><span class="pre">rectangle(f,</span> <span class="pre">a,</span> <span class="pre">b,</span> <span class="pre">n,</span> <span class="pre">height='left')</span></code> for
computing an integral <span class="math">\(\int_a^bf(x)dx\)</span> by the rectangle method
with height computed based on the value of <code class="docutils literal"><span class="pre">height</span></code>, which is either</p>
<blockquote>
<div><code class="docutils literal"><span class="pre">left</span></code>, <code class="docutils literal"><span class="pre">right</span></code>, or <code class="docutils literal"><span class="pre">mid</span></code>.</div></blockquote>
<p><strong>Solution.</strong>
Placing the code for both <em>a</em> and <em>b</em> into one file, the code may read:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">rectangle</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">height</span><span class="o">=</span><span class="s">&#39;left&#39;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Uses a rectangle method for integrating f. The height of</span>
<span class="sd">    each rectangle is computed either at the left end, middle or</span>
<span class="sd">    right end of each sub-interval&quot;&quot;&quot;</span>
    <span class="n">h</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">b</span><span class="o">-</span><span class="n">a</span><span class="p">)</span><span class="o">/</span><span class="n">n</span>
    <span class="k">if</span> <span class="n">height</span> <span class="o">==</span> <span class="s">&#39;left&#39;</span><span class="p">:</span>
        <span class="n">start</span> <span class="o">=</span> <span class="n">a</span>
    <span class="k">elif</span> <span class="n">height</span> <span class="o">==</span> <span class="s">&#39;mid&#39;</span><span class="p">:</span>
        <span class="n">start</span> <span class="o">=</span> <span class="n">a</span> <span class="o">+</span> <span class="n">h</span><span class="o">/</span><span class="mf">2.0</span>
    <span class="k">else</span><span class="p">:</span>      <span class="c"># Must be right end</span>
        <span class="n">start</span> <span class="o">=</span> <span class="n">a</span> <span class="o">+</span> <span class="n">h</span>
    <span class="n">result</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
        <span class="n">result</span> <span class="o">+=</span> <span class="n">f</span><span class="p">((</span><span class="n">start</span><span class="p">)</span> <span class="o">+</span> <span class="n">i</span><span class="o">*</span><span class="n">h</span><span class="p">)</span>
    <span class="n">result</span> <span class="o">*=</span> <span class="n">h</span>
    <span class="k">return</span> <span class="n">result</span>

<span class="k">def</span> <span class="nf">test_rectangle_one_exact_result</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;Compare one hand-computed result.&quot;&quot;&quot;</span>
    <span class="kn">from</span> <span class="nn">math</span> <span class="kn">import</span> <span class="n">exp</span>
    <span class="n">v</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">t</span><span class="p">:</span> <span class="mi">3</span><span class="o">*</span><span class="p">(</span><span class="n">t</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="n">exp</span><span class="p">(</span><span class="n">t</span><span class="o">**</span><span class="mi">3</span><span class="p">)</span>
    <span class="n">method</span> <span class="o">=</span> <span class="p">[</span><span class="s">&#39;left&#39;</span><span class="p">,</span> <span class="s">&#39;mid&#39;</span><span class="p">,</span> <span class="s">&#39;right&#39;</span><span class="p">]</span>
    <span class="n">n</span> <span class="o">=</span> <span class="mi">2</span>
    <span class="n">exact</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.4249306699000599</span><span class="p">,</span> <span class="mf">1.3817914596908085</span><span class="p">,</span> \
                                           <span class="mf">4.5023534125886275</span><span class="p">]</span>
    <span class="n">tol</span> <span class="o">=</span> <span class="mf">1E-14</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">method</span><span class="p">)):</span>
        <span class="n">numerical</span> <span class="o">=</span> <span class="n">rectangle</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">method</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="n">err</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">exact</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">numerical</span><span class="p">)</span>
        <span class="k">assert</span> <span class="n">err</span> <span class="o">&lt;</span> <span class="n">tol</span><span class="p">,</span> <span class="n">err</span>

<span class="k">def</span> <span class="nf">test_rectangle_linear</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;Check that linear functions are integrated exactly</span>
<span class="sd">    (with midpoint) or with a known correctable error (left</span>
<span class="sd">    and right)&quot;&quot;&quot;</span>
    <span class="n">method</span> <span class="o">=</span> <span class="p">[</span><span class="s">&#39;left&#39;</span><span class="p">,</span> <span class="s">&#39;mid&#39;</span><span class="p">,</span> <span class="s">&#39;right&#39;</span><span class="p">]</span>
    <span class="n">f</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="mi">6</span><span class="o">*</span><span class="n">x</span> <span class="o">-</span> <span class="mi">4</span>
    <span class="n">slope</span> <span class="o">=</span> <span class="mi">6</span>
    <span class="n">F</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="mi">3</span><span class="o">*</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="mi">4</span><span class="o">*</span><span class="n">x</span>  <span class="c"># Anti-derivative</span>
    <span class="c"># From the slope of f (i.e. 6), we know that left will</span>
    <span class="c"># under-estimate the inegral by C (given below), while</span>
    <span class="c"># right will over-estimate by C</span>
    <span class="n">a</span> <span class="o">=</span> <span class="mf">1.2</span><span class="p">;</span>  <span class="n">b</span> <span class="o">=</span> <span class="mf">4.4</span>
    <span class="n">exact</span> <span class="o">=</span> <span class="n">F</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="o">-</span> <span class="n">F</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="c">#tol = 1E-14</span>
    <span class="n">tol</span> <span class="o">=</span> <span class="mf">1E-13</span>        <span class="c"># Slightly relaxed compared to previously</span>
    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">21</span><span class="p">:</span>
        <span class="n">h</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">b</span><span class="o">-</span><span class="n">a</span><span class="p">)</span><span class="o">/</span><span class="n">n</span>
        <span class="n">C</span> <span class="o">=</span> <span class="n">n</span><span class="o">*</span><span class="p">(</span><span class="mf">0.5</span><span class="o">*</span><span class="n">slope</span><span class="o">*</span><span class="n">h</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>    <span class="c"># Correction term for left/right</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">method</span><span class="p">)):</span>
            <span class="n">numerical</span> <span class="o">=</span> <span class="n">rectangle</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">method</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">method</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="s">&#39;left&#39;</span><span class="p">):</span>
                <span class="n">numerical</span> <span class="o">+=</span> <span class="n">C</span>
            <span class="k">elif</span> <span class="p">(</span><span class="n">method</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="s">&#39;right&#39;</span><span class="p">):</span>
                <span class="n">numerical</span> <span class="o">-=</span> <span class="n">C</span>
            <span class="n">err</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">exact</span> <span class="o">-</span> <span class="n">numerical</span><span class="p">)</span>
            <span class="k">assert</span> <span class="n">err</span> <span class="o">&lt;</span> <span class="n">tol</span><span class="p">,</span> <span class="s">&#39;n = </span><span class="si">%d</span><span class="s">, err = </span><span class="si">%g</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="n">err</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">test_rectangle_conv_rate</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;Check empirical convergence rates against the expected rate,</span>
<span class="sd">    which is -2 for midpoint and -1 for left and right.&quot;&quot;&quot;</span>
    <span class="kn">from</span> <span class="nn">math</span> <span class="kn">import</span> <span class="n">exp</span>
    <span class="n">method</span> <span class="o">=</span> <span class="p">[</span><span class="s">&#39;left&#39;</span><span class="p">,</span> <span class="s">&#39;mid&#39;</span><span class="p">,</span> <span class="s">&#39;right&#39;</span><span class="p">]</span>
    <span class="n">v</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">t</span><span class="p">:</span> <span class="mi">3</span><span class="o">*</span><span class="p">(</span><span class="n">t</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="n">exp</span><span class="p">(</span><span class="n">t</span><span class="o">**</span><span class="mi">3</span><span class="p">)</span>
    <span class="n">V</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">t</span><span class="p">:</span> <span class="n">exp</span><span class="p">(</span><span class="n">t</span><span class="o">**</span><span class="mi">3</span><span class="p">)</span>
    <span class="n">a</span> <span class="o">=</span> <span class="mf">1.1</span><span class="p">;</span>  <span class="n">b</span> <span class="o">=</span> <span class="mf">1.9</span>
    <span class="n">tol</span> <span class="o">=</span> <span class="mf">0.01</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">method</span><span class="p">)):</span>
        <span class="n">r</span> <span class="o">=</span> <span class="n">convergence_rates</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">method</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="mi">14</span><span class="p">)</span>
        <span class="k">print</span> <span class="n">r</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">method</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="s">&#39;left&#39;</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">method</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="s">&#39;right&#39;</span><span class="p">):</span>
            <span class="k">assert</span> <span class="nb">abs</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">r</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">tol</span><span class="p">,</span> <span class="n">r</span><span class="p">[</span><span class="o">-</span><span class="mi">4</span><span class="p">:]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">assert</span> <span class="nb">abs</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">r</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">tol</span><span class="p">,</span> <span class="n">r</span><span class="p">[</span><span class="o">-</span><span class="mi">4</span><span class="p">:]</span>

<span class="k">def</span> <span class="nf">convergence_rates</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">F</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">height</span><span class="p">,</span> <span class="n">num_experiments</span><span class="o">=</span><span class="mi">14</span><span class="p">):</span>
    <span class="kn">from</span> <span class="nn">math</span> <span class="kn">import</span> <span class="n">log</span>
    <span class="kn">from</span> <span class="nn">numpy</span> <span class="kn">import</span> <span class="n">zeros</span>
    <span class="n">exact</span> <span class="o">=</span> <span class="n">F</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="o">-</span> <span class="n">F</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">(</span><span class="n">num_experiments</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
    <span class="n">E</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">(</span><span class="n">num_experiments</span><span class="p">)</span>
    <span class="n">r</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">(</span><span class="n">num_experiments</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_experiments</span><span class="p">):</span>
        <span class="n">n</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span><span class="o">**</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">numerical</span> <span class="o">=</span> <span class="n">rectangle</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">n</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">height</span><span class="p">)</span>
        <span class="n">E</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">exact</span> <span class="o">-</span> <span class="n">numerical</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">r_im1</span> <span class="o">=</span> <span class="n">log</span><span class="p">(</span><span class="n">E</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">/</span><span class="n">E</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span><span class="o">/</span><span class="n">log</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">n</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="o">/</span><span class="n">n</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">r</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="s">&#39;</span><span class="si">%.2f</span><span class="s">&#39;</span> <span class="o">%</span> <span class="n">r_im1</span><span class="p">)</span>  <span class="c"># Truncate to two decimals</span>
    <span class="k">return</span> <span class="n">r</span>

<span class="n">test_rectangle_one_exact_result</span><span class="p">()</span>
<span class="n">test_rectangle_linear</span><span class="p">()</span>
<span class="n">test_rectangle_conv_rate</span><span class="p">()</span>
</pre></div>
</div>
<p><strong>b)</strong>
Write three test functions for the three unit test procedures
described in the section <span class="xref std std-ref">sec:integrals:testprocs</span>. Make sure you
test for <code class="docutils literal"><span class="pre">height</span></code> equal to <code class="docutils literal"><span class="pre">left</span></code>, <code class="docutils literal"><span class="pre">right</span></code>, and <code class="docutils literal"><span class="pre">mid</span></code>. You may
call the <code class="docutils literal"><span class="pre">midpoint</span></code> function for checking the result when <code class="docutils literal"><span class="pre">height=mid</span></code>.</p>
<p><strong>Hint.</strong>
Edit <code class="docutils literal"><span class="pre">test_trapezoidal.py</span></code>.</p>
<p><strong>Solution.</strong>
See code above.</p>
<p>Filename: <code class="docutils literal"><span class="pre">rectangle_methods.py</span></code>.</p>
</div>
<div class="section" id="exercise-38-adaptive-integration">
<span id="sec-exer-adaptive-int"></span><h4>Exercise 38: Adaptive integration<a class="headerlink" href="#exercise-38-adaptive-integration" title="Permalink to this headline">¶</a></h4>
<p>Suppose we want to use the trapezoidal or midpoint method to
compute an integral <span class="math">\(\int_a^b f(x)dx\)</span> with an error less than
a prescribed tolerance <span class="math">\(\epsilon\)</span>. What is the appropriate
size of <span class="math">\(n\)</span>?</p>
<p>To answer this question, we may enter an iterative procedure where
we compare the results produced by <span class="math">\(n\)</span> and <span class="math">\(2n\)</span> intervals,
and if the difference is smaller than <span class="math">\(\epsilon\)</span>, the value corresponding
to <span class="math">\(2n\)</span> is returned. Otherwise, we halve <span class="math">\(n\)</span> and repeat the procedure.</p>
<p><strong>Hint.</strong>
It may be a good idea to organize your code so that the function <code class="docutils literal"><span class="pre">adaptive_integration</span></code> can be used
easily in future programs you write.</p>
<p><strong>a)</strong>
Write a function</p>
<div class="highlight-text"><div class="highlight"><pre>adaptive_integration(f, a, b, eps, method=midpoint)
</pre></div>
</div>
<p>that implements the idea above (<code class="docutils literal"><span class="pre">eps</span></code> corresponds to the tolerance
<span class="math">\(\epsilon\)</span>, and <code class="docutils literal"><span class="pre">method</span></code> can be <code class="docutils literal"><span class="pre">midpoint</span></code> or <code class="docutils literal"><span class="pre">trapezoidal</span></code>).</p>
<p><strong>Solution.</strong>
Easing the answers to the whole of this exercise, as well as preparing for easy use of
adaptive integration in future programs, we organize the
coding of tasks <em>a</em>, <em>b</em> and <em>c</em> into one file, making it a module.
The code then reads:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">numpy</span> <span class="kn">import</span> <span class="n">linspace</span><span class="p">,</span> <span class="n">zeros</span><span class="p">,</span> <span class="n">sqrt</span><span class="p">,</span> <span class="n">log</span>
<span class="kn">from</span> <span class="nn">trapezoidal</span> <span class="kn">import</span> <span class="n">trapezoidal</span>
<span class="kn">from</span> <span class="nn">midpoint</span> <span class="kn">import</span> <span class="n">midpoint</span>

<span class="k">def</span> <span class="nf">adaptive_integration</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">eps</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s">&#39;midpoint&#39;</span><span class="p">):</span>
    <span class="n">n_limit</span> <span class="o">=</span> <span class="mi">1000000</span>   <span class="c"># Just a choice (used to avoid inf loop)</span>
    <span class="n">n</span> <span class="o">=</span> <span class="mi">2</span>
    <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s">&#39;trapezoidal&#39;</span><span class="p">:</span>
        <span class="n">integral_n</span>  <span class="o">=</span> <span class="n">trapezoidal</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
        <span class="n">integral_2n</span> <span class="o">=</span> <span class="n">trapezoidal</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">n</span><span class="p">)</span>
        <span class="n">diff</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">integral_2n</span> <span class="o">-</span> <span class="n">integral_n</span><span class="p">)</span>
        <span class="k">print</span> <span class="s">&#39;trapezoidal diff: &#39;</span><span class="p">,</span> <span class="n">diff</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">diff</span> <span class="o">&gt;</span> <span class="n">eps</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">n</span> <span class="o">&lt;</span> <span class="n">n_limit</span><span class="p">):</span>
            <span class="n">integral_n</span>  <span class="o">=</span> <span class="n">trapezoidal</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
            <span class="n">integral_2n</span> <span class="o">=</span> <span class="n">trapezoidal</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">n</span><span class="p">)</span>
            <span class="n">diff</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">integral_2n</span> <span class="o">-</span> <span class="n">integral_n</span><span class="p">)</span>
            <span class="k">print</span> <span class="s">&#39;trapezoidal diff: &#39;</span><span class="p">,</span> <span class="n">diff</span>
            <span class="n">n</span> <span class="o">*=</span> <span class="mi">2</span>
    <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s">&#39;midpoint&#39;</span><span class="p">:</span>
        <span class="n">integral_n</span>  <span class="o">=</span> <span class="n">midpoint</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
        <span class="n">integral_2n</span> <span class="o">=</span> <span class="n">midpoint</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">n</span><span class="p">)</span>
        <span class="n">diff</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">integral_2n</span> <span class="o">-</span> <span class="n">integral_n</span><span class="p">)</span>
        <span class="k">print</span> <span class="s">&#39;midpoint diff: &#39;</span><span class="p">,</span> <span class="n">diff</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">diff</span> <span class="o">&gt;</span> <span class="n">eps</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">n</span> <span class="o">&lt;</span> <span class="n">n_limit</span><span class="p">):</span>
            <span class="n">integral_n</span>  <span class="o">=</span> <span class="n">midpoint</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
            <span class="n">integral_2n</span> <span class="o">=</span> <span class="n">midpoint</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">n</span><span class="p">)</span>
            <span class="n">diff</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">integral_2n</span> <span class="o">-</span> <span class="n">integral_n</span><span class="p">)</span>
            <span class="k">print</span> <span class="s">&#39;midpoint diff: &#39;</span><span class="p">,</span> <span class="n">diff</span>
            <span class="n">n</span> <span class="o">*=</span> <span class="mi">2</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">print</span> <span class="s">&#39;Error - adaptive integration called with unknown par&#39;</span>
    <span class="c"># Now we check if acceptable n was found or not</span>
    <span class="k">if</span> <span class="n">diff</span> <span class="o">&lt;=</span> <span class="n">eps</span><span class="p">:</span>   <span class="c"># Success</span>
        <span class="k">print</span> <span class="s">&#39;The integral computes to: &#39;</span><span class="p">,</span> <span class="n">integral_2n</span>
        <span class="k">return</span> <span class="n">n</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="o">-</span><span class="n">n</span>   <span class="c"># Return negative n to tell &quot;not found&quot;</span>

<span class="k">def</span> <span class="nf">application</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;...Tasks b) and c)&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">x</span><span class="o">**</span><span class="mi">2</span>
    <span class="k">def</span> <span class="nf">g</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

    <span class="c">#eps = 1E-1           # Just switch between these two eps values</span>
    <span class="n">eps</span> <span class="o">=</span> <span class="mf">1E-10</span>
    <span class="c">#a = 0.0</span>
    <span class="n">a</span> <span class="o">=</span> <span class="mf">0.0</span> <span class="o">+</span> <span class="mf">0.01</span><span class="p">;</span>       <span class="c"># If we adjust a, sqrt(x) is handled easily</span>
    <span class="n">b</span> <span class="o">=</span> <span class="mf">2.0</span>
    <span class="c"># ...f</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">adaptive_integration</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">eps</span><span class="p">,</span> <span class="s">&#39;midpoint&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">print</span> <span class="s">&#39;Sufficient n is: </span><span class="si">%d</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">n</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">print</span> <span class="s">&#39;No n was found in </span><span class="si">%d</span><span class="s"> iterations&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">n_limit</span><span class="p">)</span>

    <span class="n">n</span> <span class="o">=</span> <span class="n">adaptive_integration</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">eps</span><span class="p">,</span> <span class="s">&#39;trapezoidal&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">print</span> <span class="s">&#39;Sufficient n is: </span><span class="si">%d</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">n</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">print</span> <span class="s">&#39;No n was found in </span><span class="si">%d</span><span class="s"> iterations&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">n_limit</span><span class="p">)</span>

    <span class="c"># ...g</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">adaptive_integration</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">eps</span><span class="p">,</span> <span class="s">&#39;midpoint&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">print</span> <span class="s">&#39;Sufficient n is: </span><span class="si">%d</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">n</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">print</span> <span class="s">&#39;No n was found in </span><span class="si">%d</span><span class="s"> iterations&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">n_limit</span><span class="p">)</span>

    <span class="n">n</span> <span class="o">=</span> <span class="n">adaptive_integration</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">eps</span><span class="p">,</span> <span class="s">&#39;trapezoidal&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">print</span> <span class="s">&#39;Sufficient n is: </span><span class="si">%d</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">n</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">print</span> <span class="s">&#39;No n was found in </span><span class="si">%d</span><span class="s"> iterations&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">n_limit</span><span class="p">)</span>

    <span class="c"># Task c, make plot for both midpoint and trapezoidal</span>
    <span class="n">eps</span> <span class="o">=</span> <span class="n">linspace</span><span class="p">(</span><span class="mf">1E-1</span><span class="p">,</span><span class="mf">10E-10</span><span class="p">,</span><span class="mi">10</span><span class="p">)</span>
    <span class="n">n_m</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">eps</span><span class="p">))</span>
    <span class="n">n_t</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">eps</span><span class="p">))</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">n_m</span><span class="p">)):</span>
        <span class="n">n_m</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">adaptive_integration</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">eps</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="s">&#39;midpoint&#39;</span><span class="p">)</span>
        <span class="n">n_t</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">adaptive_integration</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">eps</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="s">&#39;trapezoidal&#39;</span><span class="p">)</span>

    <span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="kn">as</span> <span class="nn">plt</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">log</span><span class="p">(</span><span class="n">eps</span><span class="p">),</span><span class="n">n_m</span><span class="p">,</span><span class="s">&#39;b-&#39;</span><span class="p">,</span><span class="n">log</span><span class="p">(</span><span class="n">eps</span><span class="p">),</span><span class="n">n_t</span><span class="p">,</span><span class="s">&#39;r-&#39;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s">&#39;log(eps)&#39;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s">&#39;n for midpoint (blue) and trapezoidal (red)&#39;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
    <span class="k">print</span> <span class="n">n</span>
    <span class="k">print</span> <span class="n">eps</span>

<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">application</span><span class="p">()</span>
</pre></div>
</div>
<p><strong>b)</strong>
Test the method on <span class="math">\(\int_0^2x^2dx\)</span> and <span class="math">\(\int_0^2\sqrt{x}dx\)</span>
for <span class="math">\(\epsilon = 10^{-1}, 10^{-10}\)</span> and write out the exact error.</p>
<p><strong>Solution.</strong>
See the code above. Note that, in our suggested code, it is foreseen
that the programmer switches between the two epsilon values by use of commenting, i.e.
adding/removing <code class="docutils literal"><span class="pre">#</span></code>. This may of course be avoided, if desirable, by asking the user for epsilon.</p>
<p><strong>c)</strong>
Make a plot of <span class="math">\(n\)</span> versus <span class="math">\(\epsilon \in [10^{-1}, 10^{-10}]\)</span> for
<span class="math">\(\int_0^2\sqrt{x}dx\)</span>. Use logarithmic scale for <span class="math">\(\epsilon\)</span>.</p>
<p><strong>Solution.</strong>
From Figure <a class="reference internal" href="#fig-adaptintegr"><span class="std std-ref">Showing n as a function of log(eps) when  is computed by the midpoint (blue) and the trapezoidal (red) method</span></a>, we see that the stricter the value of epsilon, the larger the
difference between the midpoint and the trapezoidal methods. For a given value for epsilon, the
midpoint method comes within the tolerance with fewer intervals (lower value of <code class="docutils literal"><span class="pre">n</span></code>) than does
the trapezoidal method. This should be expected, since the midpoint method is somewhat more accurate
than the trapezoidal method.</p>
<div class="figure" id="id10">
<span id="fig-adaptintegr"></span><a class="reference internal image-reference" href="_images/adaptive_integration.png"><img alt="_images/adaptive_integration.png" src="_images/adaptive_integration.png" style="width: 800px;" /></a>
<p class="caption"><span class="caption-text">Showing <code class="docutils literal"><span class="pre">n</span></code> as a function of <code class="docutils literal"><span class="pre">log(eps)</span></code> when <span class="math">\(\int_0^2\sqrt{x}dx\)</span> is computed by the midpoint (blue) and the trapezoidal (red) method</span></p>
</div>
<p>One way of producing this plot, is by using the code lines included at the end of
<code class="docutils literal"><span class="pre">adaptive_integration.py</span></code> (see the above).</p>
<p>Filename: <code class="docutils literal"><span class="pre">adaptive_integration.py</span></code>.</p>
</div>
</div>
<div class="section" id="remarks-6">
<h3>Remarks<a class="headerlink" href="#remarks-6" title="Permalink to this headline">¶</a></h3>
<p>The type of method explored in this exercise is called <em>adaptive</em>,
because it tries to adapt the value of <span class="math">\(n\)</span> to meet a given
error criterion. The true error can very seldom be computed
(since we do not know the exact answer to the computational
problem), so one has to find other indicators of the error, such
as the one here where the changes in the integral value, as
the number of intervals is doubled, is taken to reflect the error.</p>
<div class="section" id="exercise-39-integrating-x-raised-to-x">
<span id="sec-exer-integrate-x2x"></span><h4>Exercise 39: Integrating x raised to x<a class="headerlink" href="#exercise-39-integrating-x-raised-to-x" title="Permalink to this headline">¶</a></h4>
<p>Consider the integral</p>
<div class="math">
\[I = \int_0^4 x^x\,dx\thinspace .\]</div>
<p>The integrand <span class="math">\(x^x\)</span> does not have an anti-derivative that can be expressed in terms of standard functions (visit <a class="reference external" href="http://wolframalpha.com">http://wolframalpha.com</a> and type
<code class="docutils literal"><span class="pre">integral(x**x,x)</span></code> to convince yourself that
our claim is right. Note that Wolfram alpha does give you an answer, but that answer is an approximation, it is <em>not</em> exact. This is because
Wolfram alpha too uses numerical methods to arrive at the answer, just as you will in this exercise). Therefore, we are forced to compute the integral by numerical methods. Compute a result that is right to four digits.</p>
<p><strong>Hint.</strong>
Use ideas from <a class="reference internal" href="#sec-exer-adaptive-int"><span class="std std-ref">Exercise 38: Adaptive integration</span></a>.</p>
<p><strong>Solution.</strong>
When the function <code class="docutils literal"><span class="pre">adaptive_integration</span></code> is available, the code may be written as:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">adaptive_integration</span> <span class="kn">import</span> <span class="n">adaptive_integration</span>

<span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">x</span><span class="o">**</span><span class="n">x</span>

<span class="n">eps</span> <span class="o">=</span> <span class="mf">1E-4</span>
<span class="n">a</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">;</span>  <span class="n">b</span> <span class="o">=</span> <span class="mf">2.0</span>

<span class="c"># Choose midpoint method</span>
<span class="n">n</span> <span class="o">=</span> <span class="n">adaptive_integration</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">eps</span><span class="p">,</span> <span class="s">&#39;midpoint&#39;</span><span class="p">)</span>
<span class="k">if</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
    <span class="k">print</span> <span class="s">&#39;Sufficient n is: </span><span class="si">%d</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">n</span><span class="p">)</span>
<span class="k">else</span><span class="p">:</span>
    <span class="c"># The negative n is returned to signal that the upper limit of n</span>
    <span class="c"># was passed</span>
    <span class="k">print</span> <span class="s">&#39;No n was found in </span><span class="si">%d</span><span class="s"> iterations&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">n</span><span class="p">))</span>
</pre></div>
</div>
<p>Remember that <code class="docutils literal"><span class="pre">adaptive_integration</span></code> prints out the computed integral, so no effort
in that respect is required here.</p>
<p>Running the program, gives a printout to the screen showing how <code class="docutils literal"><span class="pre">diff</span></code> gets smaller and
smaller each time. The final two lines of the printout read:</p>
<div class="highlight-text"><div class="highlight"><pre>The integral computes to: 2.83384395958
Sufficient n is: 256
</pre></div>
</div>
<p>The computed value may be compared to what Wolfram alpha gives. Remember that since we
have not computed the exact error, we can <em>not</em> guarantee that the
&#8220;result is right to four digits&#8221;. However, we have reason to believe that we &#8220;are close&#8221;.
Typically, when it is known that the error measure used is not precise, the tolerance is
made stricter.</p>
<p>Filename: <code class="docutils literal"><span class="pre">integrate_x2x.py</span></code>.</p>
</div>
<div class="section" id="exercise-40-integrate-products-of-sine-functions">
<span id="sec-exer-sine-products"></span><h4>Exercise 40: Integrate products of sine functions<a class="headerlink" href="#exercise-40-integrate-products-of-sine-functions" title="Permalink to this headline">¶</a></h4>
<p>In this exercise we shall integrate</p>
<div class="math">
\[I_{j,k} = \int_{-\pi}^{\pi} \sin(jx)\sin(kx)dx,\]</div>
<p>where <span class="math">\(j\)</span> and <span class="math">\(k\)</span> are integers.</p>
<p><strong>a)</strong>
Plot <span class="math">\(\sin(x)\sin(2x)\)</span> and <span class="math">\(\sin(2x)\sin(3x)\)</span> for <span class="math">\(x\in ]-\pi,\pi]\)</span>
in separate plots.
Explain why you expect
<span class="math">\(\int_{-\pi}^{\pi}\sin x\sin 2x\,dx=0\)</span> and
<span class="math">\(\int_{-\pi}^{\pi}\sin 2x\sin 3x\,dx=0\)</span>.</p>
<p><strong>b)</strong>
Use the trapezoidal rule to compute <span class="math">\(I_{j,k}\)</span> for <span class="math">\(j=1,\ldots,10\)</span> and
<span class="math">\(k=1,\ldots,10\)</span>.</p>
<p>Filename: <code class="docutils literal"><span class="pre">products_sines.py</span></code>.</p>
</div>
<div class="section" id="exercise-41-revisit-fit-of-sines-to-a-function">
<span id="sec-exer-revisitfitsines"></span><h4>Exercise 41: Revisit fit of sines to a function<a class="headerlink" href="#exercise-41-revisit-fit-of-sines-to-a-function" title="Permalink to this headline">¶</a></h4>
<p>This is a continuation of <a class="reference internal" href="._pylight003.html#nd-exer-fitsines"><span class="std std-ref">Exercise 28: Fit sines to straight line</span></a>. The task is to
approximate a given function <span class="math">\(f(t)\)</span> on <span class="math">\([-\pi,\pi]\)</span> by a sum of sines,</p>
<div class="math" id="eq-auto4">
\[\tag{28}
S_N(t) = \sum_{n=1}^{N} b_n \sin(nt)\thinspace .\]</div>
<p>We are now interested in computing the unknown coefficients <span class="math">\(b_n\)</span>
such that <span class="math">\(S_N(t)\)</span> is in some sense the <em>best approximation</em> to <span class="math">\(f(t)\)</span>.
One common way of doing this is to first set up a general expression
for the <em>approximation error</em>, measured by &#8220;summing up&#8221; the
squared deviation of <span class="math">\(S_N\)</span> from <span class="math">\(f\)</span>:</p>
<div class="math">
\[E = \int_{-\pi}^{\pi}(S_N(t)-f(t))^2dt\thinspace .\]</div>
<p>We may view <span class="math">\(E\)</span> as a function of <span class="math">\(b_1,\ldots,b_N\)</span>. Minimizing <span class="math">\(E\)</span>
with respect to <span class="math">\(b_1,\ldots,b_N\)</span> will give us a <em>best approximation</em>,
in the sense that we adjust <span class="math">\(b_1,\ldots,b_N\)</span> such that <span class="math">\(S_N\)</span> deviates
as little as possible from <span class="math">\(f\)</span>.</p>
<p>Minimization of a function of <span class="math">\(N\)</span> variables, <span class="math">\(E(b_1,\ldots,b_N)\)</span> is
mathematically performed by requiring all the partial derivatives
to be zero:</p>
<div class="math">
\[\begin{split}\frac{\partial E}{\partial b_1} &amp; = 0,\\
\frac{\partial E}{\partial b_2} &amp; = 0,\\
&amp;\vdots\\
\frac{\partial E}{\partial b_N} &amp; = 0\thinspace .\end{split}\]</div>
<p><strong>a)</strong>
Compute the partial derivative <span class="math">\(\partial E/\partial b_1\)</span> and
generalize to the arbitrary case <span class="math">\(\partial E/\partial b_n\)</span>, <span class="math">\(1\leq n\leq N\)</span>.</p>
<p><strong>Solution.</strong></p>
<div class="math">
\[\frac{\partial E}{\partial b_1}  = \frac{\partial}{\partial b_1} (\int_{-\pi}^{\pi}(S_N(t)-f(t))^2dt),                 \nonumber\]</div>
<div class="math">
\[= \int_{-\pi}^{\pi} \frac{\partial}{\partial b_1}((S_N(t)-f(t))^2dt),                 \nonumber\]</div>
<div class="math">
\[= 2\int_{-\pi}^{\pi} (S_N(t)-f(t))\sin(t)dt,                                           \nonumber\]</div>
<p>where it has been assumed that the integrand is such that the partial derivative can be moved inside the integration.</p>
<p>We see that the partial derivative of <span class="math">\(E\)</span> with respect to any one of the <span class="math">\(b\)</span> coefficients will take on the same form, meaning that</p>
<div class="math">
\[\frac{\partial E}{\partial b_n} = 2\int_{-\pi}^{\pi} (S_N(t)-f(t))\sin(nt)dt,              \nonumber\]</div>
<p>where <span class="math">\(1\leq n\leq N\)</span>.</p>
<p><strong>b)</strong>
Show that</p>
<div class="math">
\[b_n = \frac{1}{\pi}\int_{-\pi}^{\pi}f(t)\sin(nt)\,dt\thinspace .\]</div>
<p><strong>Solution.</strong>
Requiring</p>
<div class="math">
\[\frac{\partial E}{\partial b_n} = 0,              \nonumber\]</div>
<p>means that the following must apply,</p>
<div class="math">
\[2\int_{-\pi}^{\pi} (S_N(t)-f(t))\sin(nt)dt = 0.              \nonumber\]</div>
<p>This may be rewritten as</p>
<div class="math">
\[\int_{-\pi}^{\pi} S_N(t)\sin(nt)dt = \int_{-\pi}^{\pi} f(t)\sin(nt)dt              \nonumber\]</div>
<p>or, if we insert the expression for <span class="math">\(S_N\)</span>, we get</p>
<div class="math">
\[\int_{-\pi}^{\pi} (\sum_{i=1}^{N} b_i \sin(it))\sin(nt)dt = \int_{-\pi}^{\pi} f(t)\sin(nt)dt,              \nonumber\]</div>
<p>where the summation variable in <span class="math">\(S_N\)</span> has been changed from <span class="math">\(n\)</span> to <span class="math">\(i\)</span>, avoiding conflict with the <span class="math">\(n\)</span> already present in <span class="math">\(\sin(nt)\)</span>.</p>
<p>Now, since</p>
<div class="math">
\[\int_{-\pi}^{\pi} \sin^2(nt)dt = \pi,              \nonumber\]</div>
<p>while</p>
<div class="math">
\[\int_{-\pi}^{\pi} \sin(it)\sin(nt)dt = 0,              \nonumber\]</div>
<p>when <span class="math">\(i \neq n\)</span>, we arrive at</p>
<div class="math">
\[b_n = \frac{1}{\pi}\int_{-\pi}^{\pi}f(t)\sin(nt)\,dt\thinspace .\]</div>
<p><strong>c)</strong>
Write a function <code class="docutils literal"><span class="pre">integrate_coeffs(f,</span> <span class="pre">N,</span> <span class="pre">M)</span></code> that computes <span class="math">\(b_1,\ldots,b_N\)</span>
by numerical integration, using <span class="math">\(M\)</span> intervals in the trapezoidal rule.</p>
<p><strong>Solution.</strong>
Answers to all (programming) questions in this exercise are collected in one script
which reads:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">numpy</span> <span class="kn">import</span> <span class="n">linspace</span><span class="p">,</span> <span class="n">zeros</span><span class="p">,</span> <span class="n">pi</span><span class="p">,</span> <span class="n">sin</span><span class="p">,</span> <span class="n">exp</span>
<span class="kn">from</span> <span class="nn">trapezoidal</span> <span class="kn">import</span> <span class="n">trapezoidal</span>

<span class="k">def</span> <span class="nf">integrate_coeffs</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">M</span><span class="p">):</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">(</span><span class="n">N</span><span class="p">)</span>
    <span class="n">left_end</span> <span class="o">=</span> <span class="o">-</span><span class="n">pi</span><span class="p">;</span> <span class="n">right_end</span> <span class="o">=</span> <span class="n">pi</span>
    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
        <span class="n">f_sin</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">t</span><span class="p">:</span> <span class="n">f</span><span class="p">(</span><span class="n">t</span><span class="p">)</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="n">n</span><span class="o">*</span><span class="n">t</span><span class="p">)</span>
        <span class="n">b</span><span class="p">[</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="n">pi</span><span class="p">)</span><span class="o">*</span><span class="n">trapezoidal</span><span class="p">(</span><span class="n">f_sin</span><span class="p">,</span> <span class="n">left_end</span><span class="p">,</span> <span class="n">right_end</span><span class="p">,</span> <span class="n">M</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">b</span>

<span class="k">def</span> <span class="nf">test_integrate_coeffs</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;Check that sin(nt) are integrated exactly by trapezoidal&quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">t</span><span class="p">):</span>
        <span class="k">return</span> <span class="mi">1</span>
    <span class="n">tol</span> <span class="o">=</span> <span class="mf">1E-14</span>
    <span class="n">N</span> <span class="o">=</span> <span class="mi">10</span>
    <span class="n">M</span> <span class="o">=</span> <span class="mi">100</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">integrate_coeffs</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">M</span><span class="p">)</span>
    <span class="k">print</span> <span class="n">b</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">10</span><span class="p">):</span>
        <span class="n">err</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>  <span class="c"># Supposed to be zero</span>
        <span class="k">assert</span> <span class="n">err</span> <span class="o">&lt;</span> <span class="n">tol</span><span class="p">,</span> <span class="s">&#39;n = </span><span class="si">%d</span><span class="s">, err = </span><span class="si">%g</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="n">err</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">plot_approx</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">M</span><span class="p">,</span> <span class="n">filename</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">S_N</span><span class="p">(</span><span class="n">b</span><span class="p">,</span><span class="n">t</span><span class="p">):</span>
        <span class="nb">sum</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">b</span><span class="p">)):</span>
            <span class="nb">sum</span> <span class="o">+=</span> <span class="n">b</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">*</span><span class="n">sin</span><span class="p">((</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">t</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">sum</span>
    <span class="n">left_end</span> <span class="o">=</span> <span class="o">-</span><span class="n">pi</span><span class="p">;</span>  <span class="n">right_end</span> <span class="o">=</span> <span class="n">pi</span>
    <span class="n">time</span> <span class="o">=</span> <span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="n">pi</span><span class="p">,</span> <span class="n">pi</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">time</span><span class="p">)</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">integrate_coeffs</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">M</span><span class="p">)</span>
    <span class="n">y_approx</span> <span class="o">=</span> <span class="n">S_N</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">time</span><span class="p">)</span>

    <span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="kn">as</span> <span class="nn">plt</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">();</span> <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">time</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="s">&#39;k-&#39;</span><span class="p">,</span> <span class="n">time</span><span class="p">,</span> <span class="n">y_approx</span><span class="p">,</span> <span class="s">&#39;k--&#39;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s">&#39;t&#39;</span><span class="p">);</span>  <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s">&#39;f (solid) and S (dashed)&#39;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">application</span><span class="p">():</span>
    <span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">t</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="n">pi</span><span class="p">)</span><span class="o">*</span><span class="n">t</span>
    <span class="n">N</span> <span class="o">=</span> <span class="mi">3</span>
    <span class="n">M</span> <span class="o">=</span> <span class="mi">100</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">integrate_coeffs</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">M</span><span class="p">)</span>
    <span class="k">print</span> <span class="n">b</span>
    <span class="k">for</span> <span class="n">N</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">24</span><span class="p">]:</span>
        <span class="n">plot_filename</span> <span class="o">=</span> <span class="s">&#39;C:/Users/Svein/Desktop/S_whenNis&#39;</span> \
                                              <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">N</span><span class="p">)</span> <span class="o">+</span> <span class="s">&#39;.pdf&#39;</span>
        <span class="n">plot_approx</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">M</span><span class="p">,</span> <span class="n">plot_filename</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">g</span><span class="p">(</span><span class="n">t</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="p">(</span><span class="n">t</span><span class="o">-</span><span class="n">pi</span><span class="p">))</span>
    <span class="n">plot_filename</span> <span class="o">=</span> <span class="s">&#39;C:/Users/Svein/Desktop/new_f_S_whenNis&#39;</span> \
                                              <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="mi">100</span><span class="p">)</span> <span class="o">+</span> <span class="s">&#39;.pdf&#39;</span>
    <span class="n">plot_approx</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="n">M</span><span class="p">,</span> <span class="n">plot_filename</span><span class="p">)</span>

<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">application</span><span class="p">()</span>
    <span class="n">test_integrate_coeffs</span><span class="p">()</span>
</pre></div>
</div>
<p><strong>d)</strong>
A remarkable property of the trapezoidal rule is that it is exact for integrals
<span class="math">\(\int_{-\pi}^{\pi}\sin nt\,dt\)</span> (when subintervals are of equal size). Use this
property to create a function <code class="docutils literal"><span class="pre">test_integrate_coeff</span></code> to verify the
implementation of <code class="docutils literal"><span class="pre">integrate_coeffs</span></code>.</p>
<p><strong>Solution.</strong>
See code given above.</p>
<p><strong>e)</strong>
Implement the choice <span class="math">\(f(t) = \frac{1}{\pi}t\)</span> as a Python function
<code class="docutils literal"><span class="pre">f(t)</span></code> and call <code class="docutils literal"><span class="pre">integrate_coeffs(f,</span> <span class="pre">3,</span> <span class="pre">100)</span></code> to see what the
optimal choice of <span class="math">\(b_1, b_2, b_3\)</span> is.</p>
<p><strong>Solution.</strong>
See code given above. Running the script produces a printout of the following values
for the <span class="math">\(b\)</span> coefficients:</p>
<div class="highlight-text"><div class="highlight"><pre> 0.63641032
-0.3178909
 0.2115779
</pre></div>
</div>
<p><strong>f)</strong>
Make a function <code class="docutils literal"><span class="pre">plot_approx(f,</span> <span class="pre">N,</span> <span class="pre">M,</span> <span class="pre">filename)</span></code> where you plot <code class="docutils literal"><span class="pre">f(t)</span></code>
together with the best approximation <span class="math">\(S_N\)</span> as computed above,
using <span class="math">\(M\)</span> intervals for numerical integration. Save the plot to a file
with name <code class="docutils literal"><span class="pre">filename</span></code>.</p>
<p><strong>Solution.</strong>
See code given above.</p>
<p><strong>g)</strong>
Run <code class="docutils literal"><span class="pre">plot_approx(f,</span> <span class="pre">N,</span> <span class="pre">M,</span> <span class="pre">filename)</span></code> for <span class="math">\(f(t) = \frac{1}{\pi}t\)</span>
for <span class="math">\(N=3,6,12,24\)</span>. Observe how the approximation improves.</p>
<p><strong>Solution.</strong>
See code given above. Running the program will produce one plot (Figure <a class="reference internal" href="#fig-s-n3"><span class="std std-ref">The function  and its approximation  when </span></a>, Figure <a class="reference internal" href="#fig-s-n6"><span class="std std-ref">The function  and its approximation  when </span></a>, Figure <a class="reference internal" href="#fig-s-n12"><span class="std std-ref">The function  and its approximation  when </span></a> and Figure <a class="reference internal" href="#fig-s-n24"><span class="std std-ref">The function  and its approximation  when </span></a>) for each value of <span class="math">\(N\)</span>. We see from the plots that the larger the <span class="math">\(N\)</span>, the better the approximation.</p>
<div class="figure" id="id11">
<span id="fig-s-n3"></span><a class="reference internal image-reference" href="_images/S_whenNis3.png"><img alt="_images/S_whenNis3.png" src="_images/S_whenNis3.png" style="width: 800px;" /></a>
<p class="caption"><span class="caption-text">The function <span class="math">\(f(t)\)</span> and its approximation <span class="math">\(S_N(t)\)</span> when <span class="math">\(N = 3\)</span></span></p>
</div>
<div class="figure" id="id12">
<span id="fig-s-n6"></span><a class="reference internal image-reference" href="_images/S_whenNis6.png"><img alt="_images/S_whenNis6.png" src="_images/S_whenNis6.png" style="width: 800px;" /></a>
<p class="caption"><span class="caption-text">The function <span class="math">\(f(t)\)</span> and its approximation <span class="math">\(S_N(t)\)</span> when <span class="math">\(N = 6\)</span></span></p>
</div>
<div class="figure" id="id13">
<span id="fig-s-n12"></span><a class="reference internal image-reference" href="_images/S_whenNis12.png"><img alt="_images/S_whenNis12.png" src="_images/S_whenNis12.png" style="width: 800px;" /></a>
<p class="caption"><span class="caption-text">The function <span class="math">\(f(t)\)</span> and its approximation <span class="math">\(S_N(t)\)</span> when <span class="math">\(N = 12\)</span></span></p>
</div>
<div class="figure" id="id14">
<span id="fig-s-n24"></span><a class="reference internal image-reference" href="_images/S_whenNis24.png"><img alt="_images/S_whenNis24.png" src="_images/S_whenNis24.png" style="width: 800px;" /></a>
<p class="caption"><span class="caption-text">The function <span class="math">\(f(t)\)</span> and its approximation <span class="math">\(S_N(t)\)</span> when <span class="math">\(N = 24\)</span></span></p>
</div>
<p><strong>h)</strong>
Run <code class="docutils literal"><span class="pre">plot_approx</span></code> for <span class="math">\(f(t) = e^{-(t-\pi)}\)</span> and <span class="math">\(N=100\)</span>.
Observe a fundamental problem: regardless of <span class="math">\(N\)</span>, <span class="math">\(S_N(-\pi)=0\)</span>, not
<span class="math">\(e^{2\pi}\approx 535\)</span>. (There are ways to fix this issue.)</p>
<p><strong>Solution.</strong>
See code given above. Running the program (also) produces the plot seen in Figure <a class="reference internal" href="#fig-new-f-s-n100"><span class="std std-ref">The new function  and its approximation  when </span></a>. Clearly, the approximation is no good at the endpoints of the interval.</p>
<div class="figure" id="id15">
<span id="fig-new-f-s-n100"></span><a class="reference internal image-reference" href="_images/S_whenNis3.png"><img alt="_images/S_whenNis3.png" src="_images/S_whenNis3.png" style="width: 800px;" /></a>
<p class="caption"><span class="caption-text">The new function <span class="math">\(f(t)\)</span> and its approximation <span class="math">\(S_N(t)\)</span> when <span class="math">\(N = 100\)</span></span></p>
</div>
<p>Filename: <code class="docutils literal"><span class="pre">autofit_sines.py</span></code>.</p>
</div>
<div class="section" id="exercise-42-derive-the-trapezoidal-rule-for-a-double-integral">
<span id="sec-exer-trapezoidal-2d"></span><h4>Exercise 42: Derive the trapezoidal rule for a double integral<a class="headerlink" href="#exercise-42-derive-the-trapezoidal-rule-for-a-double-integral" title="Permalink to this headline">¶</a></h4>
<p>Use ideas in the section <span class="xref std std-ref">sec:int:double:midpoint</span> to derive a formula
for computing a double integral <span class="math">\(\int_a^b\int_c^d f(x,y)dydx\)</span> by the
trapezoidal rule.  Implement and test this rule.</p>
<p><strong>Solution.</strong>
We introduce a help function <span class="math">\(g(x)\)</span> and write</p>
<div class="math">
\[\int_a^b \int_c^d f(x,y) dydx = \int_a^b g(x)dx,\quad
g(x) = \int_c^d f(x,y) dy\thinspace .\]</div>
<p>Next, we apply the trapezoidal rule (<a class="reference internal" href="#sec-integrals-trap"><span class="std std-ref">The composite trapezoidal rule</span></a>) to each of the integrals</p>
<div class="math">
\[\int_a^b g(x)dx,\quad
g(x) = \int_c^d f(x,y) dy\thinspace .\]</div>
<p>Starting with <span class="math">\(g(x)=\int_c^d f(x,y)dy\)</span>, we introduce
<span class="math">\(n_y\)</span> intervals on <span class="math">\([c,d]\)</span> with length <span class="math">\(h_y\)</span>. The trapezoidal rule
for this integral then becomes</p>
<div class="math">
\[g(x) = \int_c^d f(x,y) dy \approx  h_y \left[\frac{1}{2}f(x,c) + \sum_{j=1}^{n_y-1}f(x,y_j) + \frac{1}{2}f(x,d) \right],\]</div>
<p>with <span class="math">\(y_j = c + jh_y\)</span>.
For the outer integral <span class="math">\(\int_a^b g(x)dx\)</span>, we get:</p>
<div class="math">
\[\int_a^b g(x)dx \approx h_x \left[\frac{1}{2}g(a) + \sum_{i=1}^{n_x-1}g(x_i) + \frac{1}{2}g(b) \right],
\quad x_i=a + ih_x\thinspace .\]</div>
<p>Combining the formulas, we get the <em>composite trapezoidal method
for a double integral</em>:</p>
<div class="math">
\[\int_a^b \int_c^d f(x,y) dydx \approx
h_x \biggl[\frac{1}{2}\left(h_y \left[\frac{1}{2}f(a,c) +
\sum_{j=1}^{n_y-1}f(a,y_j) + \frac{1}{2}f(a,d) \right]\right) + \nonumber\]</div>
<div class="math">
\[\quad \sum_{i=1}^{n_x-1}\left(h_y \left[\frac{1}{2}f(x_i,c) + \sum_{j=1}^{n_y-1}f(x_i,y_j) + \frac{1}{2}f(x_i,d) \right]\right)+\nonumber\]</div>
<div class="math">
\[\quad \frac{1}{2}\left(h_y \left[\frac{1}{2}f(b,c) + \sum_{j=1}^{n_y-1}f(b,y_j) + \frac{1}{2}f(b,d) \right]\right) \biggr]\nonumber\]</div>
<div class="math">
\[=
h_xh_y \biggl[\frac{1}{4}\left(f(a,c) + f(a,d) + f(b,c) + f(b,d) \right) +\nonumber\]</div>
<div class="math">
\[\quad \frac{1}{2}\sum_{i=1}^{n_x-1}\left(f(a + ih_x,c) + f(a + ih_x,d)\right) +
\nonumber\]</div>
<div class="math">
\[\quad \frac{1}{2}\sum_{j=1}^{n_y-1}\left(f(a,c + jh_y) + f(b,c + jh_y)\right) +
\nonumber\]</div>
<div class="math">
\[\quad \sum_{i=1}^{n_x-1} \sum_{j=1}^{n_y-1} f(a + ih_x, c + jh_y)\biggr]\thinspace .
\nonumber\]</div>
<p>The formula may be implemented and tested as shown in <code class="docutils literal"><span class="pre">trapezoidal_double.py</span></code>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">trapezoidal_double</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">nx</span><span class="p">,</span> <span class="n">ny</span><span class="p">):</span>
    <span class="n">hx</span> <span class="o">=</span> <span class="p">(</span><span class="n">b</span> <span class="o">-</span> <span class="n">a</span><span class="p">)</span><span class="o">/</span><span class="nb">float</span><span class="p">(</span><span class="n">nx</span><span class="p">)</span>
    <span class="n">hy</span> <span class="o">=</span> <span class="p">(</span><span class="n">d</span> <span class="o">-</span> <span class="n">c</span><span class="p">)</span><span class="o">/</span><span class="nb">float</span><span class="p">(</span><span class="n">ny</span><span class="p">)</span>
    <span class="n">I</span> <span class="o">=</span> <span class="mf">0.25</span><span class="o">*</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span> <span class="o">+</span> <span class="n">f</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">d</span><span class="p">)</span> <span class="o">+</span> <span class="n">f</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span> <span class="o">+</span> <span class="n">f</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">d</span><span class="p">))</span>
    <span class="n">Ix</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">nx</span><span class="p">):</span>
        <span class="n">xi</span> <span class="o">=</span> <span class="n">a</span> <span class="o">+</span> <span class="n">i</span><span class="o">*</span><span class="n">hx</span>
        <span class="n">Ix</span> <span class="o">+=</span> <span class="n">f</span><span class="p">(</span><span class="n">xi</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span> <span class="o">+</span> <span class="n">f</span><span class="p">(</span><span class="n">xi</span><span class="p">,</span> <span class="n">d</span><span class="p">)</span>
    <span class="n">I</span> <span class="o">+=</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">Ix</span>
    <span class="n">Iy</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">ny</span><span class="p">):</span>
        <span class="n">yj</span> <span class="o">=</span> <span class="n">c</span> <span class="o">+</span> <span class="n">j</span><span class="o">*</span><span class="n">hy</span>
        <span class="n">Iy</span> <span class="o">+=</span> <span class="n">f</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">yj</span><span class="p">)</span> <span class="o">+</span> <span class="n">f</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">yj</span><span class="p">)</span>
    <span class="n">I</span> <span class="o">+=</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">Iy</span>
    <span class="n">Ixy</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">nx</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">ny</span><span class="p">):</span>
            <span class="n">xi</span> <span class="o">=</span> <span class="n">a</span> <span class="o">+</span> <span class="n">i</span><span class="o">*</span><span class="n">hx</span>
            <span class="n">yj</span> <span class="o">=</span> <span class="n">c</span> <span class="o">+</span> <span class="n">j</span><span class="o">*</span><span class="n">hy</span>
            <span class="n">Ixy</span> <span class="o">+=</span> <span class="n">f</span><span class="p">(</span><span class="n">xi</span><span class="p">,</span> <span class="n">yj</span><span class="p">)</span>
    <span class="n">I</span> <span class="o">+=</span> <span class="n">Ixy</span>
    <span class="n">I</span> <span class="o">*=</span> <span class="n">hx</span><span class="o">*</span><span class="n">hy</span>
    <span class="k">return</span> <span class="n">I</span>

<span class="k">def</span> <span class="nf">test_trapezoidal_double</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;Test that a linear function is integrated exactly.&quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="k">return</span> <span class="mi">2</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="n">y</span>

    <span class="n">a</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>  <span class="n">b</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>  <span class="n">c</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>  <span class="n">d</span> <span class="o">=</span> <span class="mi">3</span>
    <span class="kn">import</span> <span class="nn">sympy</span>
    <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">sympy</span><span class="o">.</span><span class="n">symbols</span><span class="p">(</span><span class="s">&#39;x  y&#39;</span><span class="p">)</span>
    <span class="n">I_expected</span> <span class="o">=</span> <span class="n">sympy</span><span class="o">.</span><span class="n">integrate</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">),</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">),</span> <span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">d</span><span class="p">))</span>
    <span class="c"># Test three cases: nx &lt; ny, nx = ny, nx &gt; ny</span>
    <span class="k">for</span> <span class="n">nx</span><span class="p">,</span> <span class="n">ny</span> <span class="ow">in</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">),</span> <span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span> <span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">3</span><span class="p">):</span>
        <span class="n">I_computed</span> <span class="o">=</span> <span class="n">trapezoidal_double</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">nx</span><span class="p">,</span> <span class="n">ny</span><span class="p">)</span>
        <span class="n">tol</span> <span class="o">=</span> <span class="mf">1E-14</span>
        <span class="c">#print I_expected, I_computed</span>
        <span class="k">assert</span> <span class="nb">abs</span><span class="p">(</span><span class="n">I_computed</span> <span class="o">-</span> <span class="n">I_expected</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">tol</span>

<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">test_trapezoidal_double</span><span class="p">()</span>
</pre></div>
</div>
<p>Filename: <code class="docutils literal"><span class="pre">trapezoidal_double.py</span></code>.</p>
</div>
<div class="section" id="exercise-43-compute-the-area-of-a-triangle-by-monte-carlo-integration">
<span id="sec-exer-mc-ellipse"></span><h4>Exercise 43: Compute the area of a triangle by Monte Carlo integration<a class="headerlink" href="#exercise-43-compute-the-area-of-a-triangle-by-monte-carlo-integration" title="Permalink to this headline">¶</a></h4>
<p>Use the Monte Carlo method from the section <a class="reference internal" href="#sec-int-complex-domain"><span class="std std-ref">Monte Carlo integration for complex-shaped domains</span></a> to
compute the area of a triangle with vertices at <span class="math">\((-1,0)\)</span>, <span class="math">\((1,0)\)</span>,
and <span class="math">\((3,0)\)</span>.</p>
<p><strong>Solution.</strong>
The program <code class="docutils literal"><span class="pre">MC_triangle.py</span></code> may be written as:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">MC_double</span> <span class="kn">import</span> <span class="n">MonteCarlo_double</span>

<span class="k">def</span> <span class="nf">g</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Utilize that triangle is symmetric about y-axis &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="p">(</span><span class="mi">1</span> <span class="k">if</span> <span class="p">(</span><span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">y</span> <span class="o">&lt;=</span> <span class="o">-</span><span class="mi">3</span><span class="o">*</span><span class="nb">abs</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="mi">3</span><span class="p">)</span> <span class="k">else</span> <span class="o">-</span><span class="mi">1</span> <span class="p">)</span>

<span class="k">print</span> <span class="n">MonteCarlo_double</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">1000</span><span class="p">)</span>
</pre></div>
</div>
<p>Filename: <code class="docutils literal"><span class="pre">MC_triangle.py</span></code>.</p>
</div>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <center>
            <p class="logo"><a href="http://cbc.simula.no/" title="Go to Center for Biomedical Computing">
              <img class="logo" src="_static/cbc_logo.png" alt="Logo"/>
            </a></p>
            </center>
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Computing integrals</a><ul>
<li><a class="reference internal" href="#basic-ideas-of-numerical-integration">Basic ideas of numerical integration</a><ul>
<li><a class="reference internal" href="#computational-example">Computational example</a></li>
</ul>
</li>
<li><a class="reference internal" href="#the-composite-trapezoidal-rule">The composite trapezoidal rule</a><ul>
<li><a class="reference internal" href="#specific-or-general-implementation">Specific or general implementation?</a></li>
<li><a class="reference internal" href="#implementation-with-functions">Implementation with functions</a></li>
<li><a class="reference internal" href="#solving-our-specific-problem-in-a-session">Solving our specific problem in a session</a></li>
<li><a class="reference internal" href="#solving-our-specific-problem-in-a-program">Solving our specific problem in a program</a><ul>
<li><a class="reference internal" href="#making-a-module">Making a module</a></li>
<li><a class="reference internal" href="#alternative-flat-special-purpose-implementation">Alternative flat special-purpose implementation</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#the-composite-midpoint-method">The composite midpoint method</a><ul>
<li><a class="reference internal" href="#the-idea">The idea</a><ul>
<li><a class="reference internal" href="#the-general-formula-2">The general formula</a></li>
<li><a class="reference internal" href="#implementation-2">Implementation</a></li>
<li><a class="reference internal" href="#comparing-the-trapezoidal-and-the-midpoint-methods">Comparing the trapezoidal and the midpoint methods</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#testing">Testing</a><ul>
<li><a class="reference internal" href="#hand-computed-results">Hand-computed results</a></li>
<li><a class="reference internal" href="#solving-a-problem-without-numerical-errors-1">Solving a problem without numerical errors</a></li>
<li><a class="reference internal" href="#demonstrating-correct-convergence-rates-1">Demonstrating correct convergence rates</a><ul>
<li><a class="reference internal" href="#finite-precision-of-floating-point-numbers">Finite precision of floating-point numbers</a></li>
<li><a class="reference internal" href="#constructing-unit-tests-and-writing-test-functions">Constructing unit tests and writing test functions</a></li>
</ul>
</li>
<li><a class="reference internal" href="#hand-computed-numerical-results">Hand-computed numerical results</a></li>
<li><a class="reference internal" href="#solving-a-problem-without-numerical-errors-2">Solving a problem without numerical errors</a></li>
<li><a class="reference internal" href="#demonstrating-correct-convergence-rates-2">Demonstrating correct convergence rates</a></li>
</ul>
</li>
<li><a class="reference internal" href="#vectorization-1">Vectorization</a><ul>
<li><a class="reference internal" href="#vectorizing-the-midpoint-rule">Vectorizing the midpoint rule</a></li>
<li><a class="reference internal" href="#vectorizing-the-trapezoidal-rule">Vectorizing the trapezoidal rule</a></li>
</ul>
</li>
<li><a class="reference internal" href="#measuring-computational-speed">Measuring computational speed</a></li>
<li><a class="reference internal" href="#double-and-triple-integrals">Double and triple integrals</a><ul>
<li><a class="reference internal" href="#derivation-via-one-dimensional-integrals">Derivation via one-dimensional integrals</a></li>
<li><a class="reference internal" href="#direct-derivation">Direct derivation</a></li>
<li><a class="reference internal" href="#programming-a-double-sum">Programming a double sum</a></li>
<li><a class="reference internal" href="#reusing-code-for-one-dimensional-integrals">Reusing code for one-dimensional integrals</a></li>
<li><a class="reference internal" href="#verification-via-test-functions">Verification via test functions</a><ul>
<li><a class="reference internal" href="#the-midpoint-rule-for-a-triple-integral">The midpoint rule for a triple integral</a></li>
</ul>
</li>
<li><a class="reference internal" href="#theory">Theory</a></li>
<li><a class="reference internal" href="#implementation-3">Implementation</a><ul>
<li><a class="reference internal" href="#monte-carlo-integration-for-complex-shaped-domains">Monte Carlo integration for complex-shaped domains</a></li>
</ul>
</li>
<li><a class="reference internal" href="#the-monte-carlo-integration-algorithm">The Monte Carlo integration algorithm</a></li>
<li><a class="reference internal" href="#implementation-4">Implementation</a></li>
<li><a class="reference internal" href="#verification">Verification</a></li>
<li><a class="reference internal" href="#test-function-for-function-with-random-numbers">Test function for function with random numbers</a></li>
<li><a class="reference internal" href="#integral-over-a-circle">Integral over a circle</a></li>
</ul>
</li>
<li><a class="reference internal" href="#exercises-3">Exercises</a><ul>
<li><a class="reference internal" href="#remarks-5">Remarks</a><ul>
<li><a class="reference internal" href="#exercise-37-rectangle-methods">Exercise 37: Rectangle methods</a></li>
<li><a class="reference internal" href="#exercise-38-adaptive-integration">Exercise 38: Adaptive integration</a></li>
</ul>
</li>
<li><a class="reference internal" href="#remarks-6">Remarks</a><ul>
<li><a class="reference internal" href="#exercise-39-integrating-x-raised-to-x">Exercise 39: Integrating x raised to x</a></li>
<li><a class="reference internal" href="#exercise-40-integrate-products-of-sine-functions">Exercise 40: Integrate products of sine functions</a></li>
<li><a class="reference internal" href="#exercise-41-revisit-fit-of-sines-to-a-function">Exercise 41: Revisit fit of sines to a function</a></li>
<li><a class="reference internal" href="#exercise-42-derive-the-trapezoidal-rule-for-a-double-integral">Exercise 42: Derive the trapezoidal rule for a double integral</a></li>
<li><a class="reference internal" href="#exercise-43-compute-the-area-of-a-triangle-by-monte-carlo-integration">Exercise 43: Compute the area of a triangle by Monte Carlo integration</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="._pylight003.html"
                        title="previous chapter">Basic constructions</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="._pylight005.html"
                        title="next chapter">Solving ordinary differential equations</a></p>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/._pylight004.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="._pylight005.html" title="Solving ordinary differential equations"
             >next</a> |</li>
        <li class="right" >
          <a href="._pylight003.html" title="Basic constructions"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">Programming for Computations (Python version)</a> &raquo;</li> 
      </ul>
    </div>
<div class="wrapper">
  <div class="footer">
    <a href="http://cbc.simula.no"><img src="_static/cbc_banner.png" width="100%"><a>
    <br />
    <br />
      &copy;2016, Svein Linge and Hans Petter Langtangen.
  </div>
</div>

  </body>
</html>
