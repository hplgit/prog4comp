
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Solving partial differential equations</title>
    
    <link rel="stylesheet" href="_static/default.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '1.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/javascript" src="_static/sidebar.js"></script>

        <script src="http://sagecell.sagemath.org/static/jquery.min.js"></script>
        <script src="http://sagecell.sagemath.org/static/embedded_sagecell.js"></script>

        <script>sagecell.makeSagecell({inputLocation: ".sage"});</script>

        <style type="text/css">
                .sagecell .CodeMirror-scroll {
                        overflow-y: hidden;
                        overflow-x: auto;
                }
                .sagecell .CodeMirror {
                        height: auto;
                }
        </style>

    
    <link rel="top" title="Programming for Computations (Python version)" href="index.html" />
    <link rel="next" title="Solving nonlinear algebraic equations" href="._pylight007.html" />
    <link rel="prev" title="Solving ordinary differential equations" href="._pylight005.html" />
 
  
       <style type="text/css">
         div.admonition {
           background-color: whiteSmoke;
           border: 1px solid #bababa;
         }
       </style>
      </head>
    
  <body role="document">
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="._pylight007.html" title="Solving nonlinear algebraic equations"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="._pylight005.html" title="Solving ordinary differential equations"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">Programming for Computations (Python version)</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="solving-partial-differential-equations">
<span id="th-solvpdes"></span><h1>Solving partial differential equations<a class="headerlink" href="#solving-partial-differential-equations" title="Permalink to this headline">¶</a></h1>
<p id="index-0">The subject of partial differential equations (PDEs) is enormous. At the same time, it is very important, since so many phenomena in nature and technology find their mathematical formulation through such equations. Knowing how to solve at least some PDEs is therefore of great importance to engineers. In an introductory book like this, nowhere near full justice to the subject can be made. However, we still find it valuable to give the reader a glimpse of the topic by presenting a few basic and general methods that we will apply to a very common type of PDE.</p>
<span class="target" id="index-1"></span><p id="index-2">We shall focus on one of the most widely encountered partial differential
equations: the diffusion equation, which in one dimension looks like</p>
<div class="math">
\[\frac{\partial u}{\partial t} = \beta\frac{\partial^2 u}{\partial x^2} + g
\thinspace .\]</div>
<p>The multi-dimensional counterpart is often written as</p>
<div class="math">
\[\frac{\partial u}{\partial t} = \beta\nabla^2 u + g
\thinspace .\]</div>
<p>We shall restrict the attention here to the one-dimensional case.</p>
<p>The unknown in the diffusion equation is a function <span class="math">\(u(x,t)\)</span> of space
and time. The physical significance of <span class="math">\(u\)</span> depends on what type of process
that is described by the diffusion equation. For example, <span class="math">\(u\)</span> is the
concentration of a substance if the diffusion equation models
transport of this substance by <em>diffusion</em>. Diffusion processes are of particular
relevance at the microscopic level in biology, e.g., diffusive transport
of certain ion types in a cell caused by molecular collisions.
There is also diffusion of atoms in a solid,
for instance, and diffusion of ink in a glass of water.</p>
<p>One very popular application of the diffusion equation is for heat
transport in solid bodies. Then <span class="math">\(u\)</span> is the temperature, and the
equation predicts how the temperature evolves in space and time within
the solid body. For such applications, the equations is known as the
<em>heat equation</em>.  We remark that the temperature in a fluid is
influenced not only by diffusion, but also by the flow of the
liquid. If present, the latter effect requires an extra term in the
equation (known as an advection or convection term).</p>
<p id="index-3">The term <span class="math">\(g\)</span> is known as the <em>source term</em> and
represents generation, or loss, of heat (by some mechanism) within the body.
For diffusive transport, <span class="math">\(g\)</span> models injection or extraction of the substance.</p>
<p>We should also mention that the diffusion equation may appear after simplifying
more complicated partial differential equations. For example, flow of a viscous
fluid between two flat and parallel plates is described by a one-dimensional
diffusion equation, where <span class="math">\(u\)</span> then is the fluid velocity.</p>
<span class="target" id="index-4"></span><span class="target" id="index-5"></span><p id="index-6">A partial differential equation is solved in some <em>domain</em> <span class="math">\(\Omega\)</span> in
space and for a time interval <span class="math">\([0,T]\)</span>. The solution of the equation is
not unique unless we also prescribe <em>initial and boundary conditions</em>.
The type and number of such conditions depend on the type of equation.
For the diffusion equation, we need one initial condition, <span class="math">\(u(x,0)\)</span>,
stating what <span class="math">\(u\)</span> is when the process starts. In addition,
the diffusion equation needs one boundary condition at each point of the boundary
<span class="math">\(\partial\Omega\)</span> of <span class="math">\(\Omega\)</span>. This condition can either be that <span class="math">\(u\)</span>
is known or that we know the normal derivative, <span class="math">\(\nabla u\cdot\boldsymbol{n}=\partial u/
\partial n\)</span> (<span class="math">\(\boldsymbol{n}\)</span> denotes an outward unit normal to <span class="math">\(\partial\Omega\)</span>).</p>
<p>Let us look at a specific application and how the diffusion equation with
initial and boundary conditions then appears. We consider the evolution of
temperature in a one-dimensional medium, more precisely a long rod, where
the surface of the rod is covered by an insulating material. The heat
can then not escape from the surface, which means that the temperature
distribution will only depend on a coordinate along the rod, <span class="math">\(x\)</span>, and
time <span class="math">\(t\)</span>. At one end of the rod, <span class="math">\(x=L\)</span>, we also assume that the surface is
insulated, but at the other end, <span class="math">\(x=0\)</span>, we assume that we have some device
for controlling the temperature of the medium. Here, a function <span class="math">\(s(t)\)</span>
tells what the temperature is in time. We therefore have a boundary
condition <span class="math">\(u(0,t)=s(t)\)</span>. At the other insulated end, <span class="math">\(x=L\)</span>,
heat cannot escape, which is expressed by the boundary condition
<span class="math">\(\partial u(L,t)/\partial x=0\)</span>. The surface along the rod is also
insulated and hence subject to the same boundary condition (here
generalized to <span class="math">\(\partial u/\partial n=0\)</span> at the curved surface). However,
since we have reduced
the problem to one dimension, we do not need this physical boundary
condition in our mathematical model. In one dimension, we can set
<span class="math">\(\Omega = [0,L]\)</span>.</p>
<p>To summarize, the partial differential equation with initial and boundary
conditions reads</p>
<div class="math" id="eq-esixone">
\[\tag{120}
\frac{\partial u(x,t)}{\partial t} = \beta \frac{\partial^{2}u(x,t)}{\partial x^2} + g(x,t), x \in \left(0,L\right),  t \in (0,T],\]</div>
<div class="math" id="eq-esixtwo">
\[\tag{121}
u(0,t) = s(t),  t \in (0,T],\]</div>
<div class="math" id="eq-esixthree">
\[\tag{122}
\frac{\partial}{\partial x}u(L,t) = 0, t \in (0,T],\]</div>
<div class="math" id="eq-esixfour">
\[\tag{123}
u(x,0) = I(x), x \in \left[0,L\right]\]\[    \thinspace .\]</div>
<p>Mathematically, we assume that at <span class="math">\(t=0\)</span>, the initial condition
<a class="reference internal" href="#eq-esixfour"><span class="std std-ref">(123)</span></a> holds and that the partial differential equation
<a class="reference internal" href="#eq-esixone"><span class="std std-ref">(120)</span></a> comes into play for <span class="math">\(t&gt;0\)</span>. Similarly, at the end points,
the boundary conditions <a class="reference internal" href="#eq-esixtwo"><span class="std std-ref">(121)</span></a> and <a class="reference internal" href="#eq-esixthree"><span class="std std-ref">(122)</span></a> govern <span class="math">\(u\)</span> and the equation therefore is
valid for <span class="math">\(x\in (0,L)\)</span>.</p>
<div class="admonition-boundary-and-initial-conditions-are-needed admonition">
<p class="first admonition-title">Boundary and initial conditions are needed</p>
<p class="last">The initial and boundary conditions are extremely important. Without them,
the solution is not unique, and no numerical method will work.
Unfortunately, many physical applications have one or more initial or
boundary conditions as unknowns. Such situations can be dealt with if we
have measurements of <span class="math">\(u\)</span>, but the mathematical framework is much more
complicated.</p>
</div>
<p>What about the source term <span class="math">\(g\)</span> in our example with temperature distribution
in a rod? <span class="math">\(g(x,t)\)</span> models heat generation inside the rod. One could think
of chemical reactions at a microscopic level in some materials as a reason
to include <span class="math">\(g\)</span>. However, in most applications with temperature evolution, <span class="math">\(g\)</span>
is zero and heat generation usually takes place at the boundary (as in
our example with <span class="math">\(u(0,t)=s(t)\)</span>).</p>
<p>Before continuing, we may consider an example of how the temperature
distribution evolves in the rod. At time <span class="math">\(t=0\)</span>, we assume that the
temperature is <span class="math">\(10^{\circ}\)</span> C. Then we suddenly apply a device at <span class="math">\(x=0\)</span> that
keeps the temperature at <span class="math">\(50^{\circ}\)</span> C at this end. What happens inside the
rod? Intuitively, you think that the heat generation at the end
will warm up the material in the vicinity of <span class="math">\(x=0\)</span>, and as time goes
by, more and more of the rod will be heated, before the entire
rod has a temperature of <span class="math">\(50^{\circ}\)</span> C (recall that no heat escapes from the
surface of the rod).</p>
<p>Mathematically, (with the temperature in Kelvin) this example has <span class="math">\(I(x)=283\)</span> K,
except at the end point: <span class="math">\(I(0)=323\)</span> K, <span class="math">\(s(t) = 323\)</span> K, and <span class="math">\(g=0\)</span>.
The figure below shows snapshots from four different times in
the evolution of the temperature.</p>
<div class="line-block">
<div class="line"><br /></div>
<div class="line"><br /></div>
</div>
<div class="figure">
<a class="reference internal image-reference" href="_images/rod_temp.png"><img alt="_images/rod_temp.png" src="_images/rod_temp.png" style="width: 800px;" /></a>
</div>
<div class="line-block">
<div class="line"><br /></div>
<div class="line"><br /></div>
</div>
<div>
<video  loop controls width='640' height='365' preload='none'>
    <source src="_static/mov/rod_FE.mp4"  type='video/mp4;  codecs="avc1.42E01E, mp4a.40.2"'>
    <source src="_static/mov/rod_FE.webm" type='video/webm; codecs="vp8, vorbis"'>
    <source src="_static/mov/rod_FE.ogg"  type='video/ogg;  codecs="theora, vorbis"'>
</video>
</div>
<p><em>Snapshots of temperature distribution.</em></p>

<!-- Issue warning if in a Safari browser -->
<script language="javascript">
if (!!(window.safari)) {
  document.write("<div style=\"width: 95%%; padding: 10px; border: 1px solid #100; border-radius: 4px;\"><p><font color=\"red\">The above movie will not play in Safari - use Chrome, Firefox, or Opera.</font></p></div>")}
</script><div class="section" id="finite-difference-methods">
<span id="th-solvpdes-molandfe"></span><h2>Finite difference methods<a class="headerlink" href="#finite-difference-methods" title="Permalink to this headline">¶</a></h2>
<span class="target" id="index-7"></span><span class="target" id="index-8"></span><p id="index-9">We shall now construct a numerical method for the diffusion equation.
We know how to solve ordinary differential equations, so in a way we
are able to deal with the time derivative. Very often in mathematics,
a new problem can be solved by reducing it to a series of problems we
know how to solve. In the present case, it means that we must do something
with the spatial derivative <span class="math">\(\partial^2 /\partial x^2\)</span> in order to
reduce the partial differential equation to ordinary differential equations.
One important technique for achieving this, is based on finite difference discretization of
spatial derivatives.</p>
<div class="section" id="reduction-of-a-pde-to-a-system-of-odes">
<span id="sec-pde-diff1d-reduce"></span><h3>Reduction of a PDE to a system of ODEs<a class="headerlink" href="#reduction-of-a-pde-to-a-system-of-odes" title="Permalink to this headline">¶</a></h3>
<span class="target" id="index-10"></span><p id="index-11">Introduce a spatial mesh in <span class="math">\(\Omega\)</span> with <em>mesh points</em></p>
<div class="math">
\[\begin{split}x_0=0 &lt; x_1 &lt; x_2 &lt; \cdots &lt; x_N=L \thinspace .\end{split}\]</div>
<p>The space between two mesh points <span class="math">\(x_i\)</span> and <span class="math">\(x_{i+1}\)</span>, i.e.&nbsp;the interval
<span class="math">\([x_i,x_{i+1}]\)</span>, is call a <em>cell</em>. We shall here, for simplicity,
assume that each cell has the same length <span class="math">\(\Delta x = x_{i+1}-x_i\)</span>,
<span class="math">\(i=0,\ldots, N-1\)</span>.</p>
<p>The partial differential equation is valid at all spatial points <span class="math">\(x\in\Omega\)</span>,
but we may relax this condition and demand that it is fulfilled at
the internal mesh points only, <span class="math">\(x_1,\ldots,x_{N-1}\)</span>:</p>
<div class="math" id="eq-sec-pde-diff1d-sampled">
\[\tag{124}
\frac{\partial u(x_i,t)}{\partial t} = \beta
    \frac{\partial^{2}u(x_i,t)}{\partial x^2} + g(x_i,t),\quad i=1,\ldots,N-1
    \thinspace .\]</div>
<p>Now, at any point <span class="math">\(x_i\)</span> we can approximate the second-order derivative
by a <em>finite difference</em>:</p>
<div class="math" id="eq-sec-pde-diff1d-2ndapprox">
\[\tag{125}
\frac{\partial^{2}u(x_i,t)}{\partial x^2} \approx
    \frac{u(x_{i+1},t) - 2u(x_i,t) + u(x_{i-1},t)}{\Delta x^2}\thinspace .\]</div>
<p>It is common to introduce a short notation <span class="math">\(u_i(t)\)</span> for <span class="math">\(u(x_i,t)\)</span>, i.e.,
<span class="math">\(u\)</span> approximated at some mesh point <span class="math">\(x_i\)</span> in space.
With this new notation we can, after inserting
<a class="reference internal" href="#eq-sec-pde-diff1d-2ndapprox"><span class="std std-ref">(125)</span></a> in <a class="reference internal" href="#eq-sec-pde-diff1d-sampled"><span class="std std-ref">(124)</span></a>, write
an approximation to the partial differential equation at
mesh point <span class="math">\((x_i,t\)</span>) as</p>
<div class="math" id="eq-sec-pde-diff1d-discrete">
\[\tag{126}
\frac{d u_i(t)}{d t} = \beta
    \frac{u_{i+1}(t) - 2u_i(t) + u_{i-1}(t)}{\Delta x^2} + g_i(t),\quad i=1,\ldots,N-1
    \thinspace .\]</div>
<p>Note that we have adopted the notation <span class="math">\(g_i(t)\)</span> for <span class="math">\(g(x_i,t)\)</span> too.</p>
<p id="index-12">What is <a class="reference internal" href="#eq-sec-pde-diff1d-discrete"><span class="std std-ref">(126)</span></a>? This is nothing but a <em>system of
ordinary differential equations</em> in <span class="math">\(N-1\)</span> unknowns <span class="math">\(u_1(t),\ldots,u_{N-1}(t)\)</span>!
In other words, with aid of the finite difference approximation <a class="reference internal" href="#eq-sec-pde-diff1d-2ndapprox"><span class="std std-ref">(125)</span></a>,
we have reduced the single partial differential equation to a system of ODEs,
which we know how to solve. In the literature, this strategy is called the <em>method of lines</em>.</p>
<p>We need to look into the initial and boundary conditions as well. The
initial condition <span class="math">\(u(x,0)=I(x)\)</span> translates to an initial condition for
every unknown function <span class="math">\(u_i(t)\)</span>: <span class="math">\(u_i(0)=I(x_i)\)</span>, <span class="math">\(i=0,\ldots,N\)</span>. At
the boundary <span class="math">\(x=0\)</span> we need an ODE in our ODE system, which must come
from the boundary condition at this point. The boundary condition
reads <span class="math">\(u(0,t)=s(t)\)</span>. We can derive an ODE from this equation by
differentiating both sides: <span class="math">\(u_0'(t)=s'(t)\)</span>. The ODE system above
cannot be used for <span class="math">\(u_0'\)</span> since that equation involves some quantity
<span class="math">\(u_{-1}'\)</span> outside the domain. Instead, we use the equation
<span class="math">\(u_0'(t)=s'(t)\)</span> derived from the boundary condition. For this
particular equation we also need to make sure the initial condition is
<span class="math">\(u_0(0)=s(0)\)</span> (otherwise nothing will happen: we get <span class="math">\(u=283\)</span> K
forever).</p>
<p>We remark that a separate ODE for the (known) boundary condition
<span class="math">\(u_0=s(t)\)</span> is not strictly needed. We can just work with the ODE
system for <span class="math">\(u_1,\ldots,u_{N}\)</span>, and in the ODE for <span class="math">\(u_0\)</span>, replace <span class="math">\(u_0(t)\)</span>
by <span class="math">\(s(t)\)</span>. However, these authors prefer to have an ODE for every
point value <span class="math">\(u_i\)</span>, <span class="math">\(i=0,\ldots,N\)</span>, which requires formulating the known boundary
at <span class="math">\(x=0\)</span> as an ODE. The reason for including the boundary values in the ODE
system is that the solution of the system is then the complete solution at
<em>all</em> mesh points, which is convenient, since special treatment of the boundary values
is then avoided.</p>
<p>The condition <span class="math">\(\partial u/\partial x=0\)</span> at
<span class="math">\(x=L\)</span> is a bit more complicated, but we can approximate the spatial derivative
by a centered finite difference:</p>
<div class="math">
\[\left.\frac{\partial u}{\partial x}\right|_{i=N}\approx \frac{u_{N+1}-u_{N-1}}{2\Delta x} = 0\thinspace .\]</div>
<p>This approximation involves a fictitious point <span class="math">\(x_{N+1}\)</span> outside the domain.
A common trick is to use <a class="reference internal" href="#eq-sec-pde-diff1d-discrete"><span class="std std-ref">(126)</span></a> for <span class="math">\(i=N\)</span>
and eliminate <span class="math">\(u_{N+1}\)</span> by use of the discrete boundary condition
(<span class="math">\(u_{N+1}=u_{N-1}\)</span>):</p>
<div class="math" id="eq-sec-pde-diff1d-discrete-n">
\[\tag{127}
\frac{d u_N(t)}{d t} = \beta
    \frac{2u_{N-1}(t) - 2u_N(t)}{\Delta x^2} + g_N(t)\thinspace .\]</div>
<p>That is, we have a special version of <a class="reference internal" href="#eq-sec-pde-diff1d-discrete"><span class="std std-ref">(126)</span></a> at
the boundary <span class="math">\(i=N\)</span>.</p>
<div class="admonition-what-about-simpler-finite-differences-at-the-boundary admonition">
<p class="first admonition-title">What about simpler finite differences at the boundary</p>
<p>Some reader may think that a smarter trick is to approximate the
boundary condition <span class="math">\(\partial u/\partial x\)</span> at <span class="math">\(x=L\)</span> by a one-sided
difference:</p>
<div class="math">
\[\left.\frac{\partial u}{\partial x}\right|_{i=N}\approx \frac{u_{N}-u_{N-1}}{\Delta x} = 0\thinspace .\]</div>
<p class="last">This gives a simple equation <span class="math">\(u_N=u_{N-1}\)</span> for the boundary value, and
a corresponding ODE <span class="math">\(u_N'=u_{N-1}'\)</span>. However, this approximation has
an error of order <span class="math">\(\Delta x\)</span>, while the centered approximation we used
above has an error of order <span class="math">\(\Delta x^2\)</span>. The finite difference approximation
we used for the second-order derivative in the diffusion equation also
has an error of order <span class="math">\(\Delta x^2\)</span>. Thus, if we use the simpler one-sided
difference above, it turns out that we reduce the overall accuracy of
the method.</p>
</div>
<p>We are now in a position to summarize how we can approximate the
partial differential equation problem <a class="reference internal" href="#eq-esixone"><span class="std std-ref">(120)</span></a>-<a class="reference internal" href="#eq-esixfour"><span class="std std-ref">(123)</span></a>
by a system of ordinary differential equations:</p>
<div class="math" id="eq-sec-pde-diff1d-ode1-0">
\[\tag{128}
\frac{du_0}{dt} = s'(t),\]</div>
<div class="math" id="eq-sec-pde-diff1d-ode1-i">
\[\tag{129}
\frac{du_i}{dt} =  \frac{\beta}{\Delta x^2}
    (u_{i+1}(t) - 2u_i(t) + u_{i-1}(t)) + g_i(t),\quad i=1,\ldots,N-1,\]</div>
<div class="math" id="eq-sec-pde-diff1d-ode1-n">
\[\tag{130}
\frac{du_N}{dt} =  \frac{2\beta}{\Delta x^2}
    (u_{N-1}(t) - u_N(t)) + g_N(t)\thinspace .\]</div>
<p>The initial conditions are</p>
<div class="math" id="eq-auto35">
\[\tag{131}
u_0(0) = s(0),\]</div>
<div class="math" id="eq-auto36">
\[\tag{132}
u_i(0) = I(x_i),\quad i=1,\ldots,N\thinspace .\]</div>
<p>We can apply any method for systems of ODEs to solve
<a class="reference internal" href="#eq-sec-pde-diff1d-ode1-0"><span class="std std-ref">(128)</span></a>-<a class="reference internal" href="#eq-sec-pde-diff1d-ode1-n"><span class="std std-ref">(130)</span></a>.</p>
</div>
<div class="section" id="construction-of-a-test-problem-with-known-discrete-solution">
<span id="sec-pde-diff1d-testproblem"></span><h3>Construction of a test problem with known discrete solution<a class="headerlink" href="#construction-of-a-test-problem-with-known-discrete-solution" title="Permalink to this headline">¶</a></h3>
<p>At this point, it is tempting to implement a real physical case and run it.
However, partial differential equations constitute a non-trivial topic where
mathematical and programming mistakes come easy. A better start is therefore to address
a carefully designed test example where we can check that the
method works. The most attractive examples for testing implementations
are those without approximation errors, because we know exactly what
numbers the program should produce. It turns out that solutions
<span class="math">\(u(x,t)\)</span> that are linear in time and in space can be exactly
reproduced by most numerical methods for partial differential equations.
A candidate solution might be</p>
<div class="math">
\[u(x,t) = (3t+2)(x-L)\thinspace .\]</div>
<p>Inserting this <span class="math">\(u\)</span> in the governing equation gives</p>
<div class="math">
\[3(x-L) = 0 + g(x,t)
\quad\Rightarrow\quad g(x,t)= 3(x-L)
\thinspace .\]</div>
<p>What about the boundary conditions? We realize that <span class="math">\(\partial u/\partial x
= 3t+2\)</span> for <span class="math">\(x=L\)</span>, which breaks the assumption of <span class="math">\(\partial u/\partial x=0\)</span>
at <span class="math">\(x=L\)</span> in the formulation of the numerical method above.
Moreover, <span class="math">\(u(0,t)=-L(3t+2)\)</span>,
so we must set <span class="math">\(s(t)=-L(3t+2)\)</span> and <span class="math">\(s'(t)=-3L\)</span>.
Finally, the initial condition dictates <span class="math">\(I(x)=2(x-L)\)</span>, but recall that
we must have <span class="math">\(u_0=s(0)\)</span>, and <span class="math">\(u_i=I(x_i)\)</span>, <span class="math">\(i=1,\ldots,N\)</span>: it is important
that <span class="math">\(u_0\)</span> starts out at the right value dictated by <span class="math">\(s(t)\)</span> in case
<span class="math">\(I(0)\)</span> is not equal this value.</p>
<p>First we need to generalize our method to handle <span class="math">\(\partial u/\partial x=\gamma
\neq 0\)</span> at <span class="math">\(x=L\)</span>. We then have</p>
<div class="math">
\[\frac{u_{N+1}(t)- u_{N-1}(t)}{2\Delta x}= \gamma\quad\Rightarrow
\quad u_{N+1} = u_{N-1} + 2\gamma \Delta x,\]</div>
<p>which inserted in <a class="reference internal" href="#eq-sec-pde-diff1d-discrete"><span class="std std-ref">(126)</span></a> gives</p>
<div class="math" id="eq-sec-pde-diff1d-discrete-n2">
\[\tag{133}
\frac{d u_N(t)}{d t} = \beta
    \frac{2u_{N-1}(t) + 2\gamma\Delta x - 2u_N(t)}{\Delta x^2} + g_N(t)\thinspace .\]</div>
</div>
<div class="section" id="implementation-forward-euler-method">
<h3>Implementation: Forward Euler method<a class="headerlink" href="#implementation-forward-euler-method" title="Permalink to this headline">¶</a></h3>
<p>In particular, we may use the Forward Euler method as implemented
in the general function <code class="docutils literal"><span class="pre">ode_FE</span></code> in the module <code class="docutils literal"><span class="pre">ode_system_FE</span></code>
from the section <a class="reference internal" href="._pylight005.html#sec-de-flu-prog-generic"><span class="std std-ref">Programming the numerical method; the general case</span></a>. The <code class="docutils literal"><span class="pre">ode_FE</span></code> function
needs a specification of the right-hand side of the ODE system.
This is a matter of translating <a class="reference internal" href="#eq-sec-pde-diff1d-ode1-0"><span class="std std-ref">(128)</span></a>,
<a class="reference internal" href="#eq-sec-pde-diff1d-ode1-i"><span class="std std-ref">(129)</span></a>, and
<a class="reference internal" href="#eq-sec-pde-diff1d-discrete-n2"><span class="std std-ref">(133)</span></a> to Python code
(in file
<a class="reference external" href="https://github.com/hplgit/prog4comp/tree/master/src/py/test_diffusion_pde_exact_linear.py">test_diffusion_pde_exact_linear.py</a>):</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">rhs</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">t</span><span class="p">):</span>
    <span class="n">N</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">u</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="n">rhs</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">(</span><span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">rhs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">dsdt</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">N</span><span class="p">):</span>
        <span class="n">rhs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">beta</span><span class="o">/</span><span class="n">dx</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">+</span> \
                 <span class="n">g</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">t</span><span class="p">)</span>
    <span class="n">rhs</span><span class="p">[</span><span class="n">N</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">beta</span><span class="o">/</span><span class="n">dx</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">u</span><span class="p">[</span><span class="n">N</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">dx</span><span class="o">*</span><span class="n">dudx</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="o">-</span>
                           <span class="mi">2</span><span class="o">*</span><span class="n">u</span><span class="p">[</span><span class="n">N</span><span class="p">])</span> <span class="o">+</span> <span class="n">g</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">N</span><span class="p">],</span> <span class="n">t</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">rhs</span>

<span class="k">def</span> <span class="nf">u_exact</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">t</span><span class="p">):</span>
    <span class="k">return</span> <span class="p">(</span><span class="mi">3</span><span class="o">*</span><span class="n">t</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="n">L</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">dudx</span><span class="p">(</span><span class="n">t</span><span class="p">):</span>
    <span class="k">return</span> <span class="p">(</span><span class="mi">3</span><span class="o">*</span><span class="n">t</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">s</span><span class="p">(</span><span class="n">t</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">u_exact</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">dsdt</span><span class="p">(</span><span class="n">t</span><span class="p">):</span>
    <span class="k">return</span> <span class="mi">3</span><span class="o">*</span><span class="p">(</span><span class="o">-</span><span class="n">L</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">g</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">t</span><span class="p">):</span>
    <span class="k">return</span> <span class="mi">3</span><span class="o">*</span><span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="n">L</span><span class="p">)</span>
</pre></div>
</div>
<p>Note that <code class="docutils literal"><span class="pre">dudx(t)</span></code> is the function representing the <span class="math">\(\gamma\)</span> parameter
in <a class="reference internal" href="#eq-sec-pde-diff1d-discrete-n2"><span class="std std-ref">(133)</span></a>.
Also note that the <code class="docutils literal"><span class="pre">rhs</span></code> function relies on access to global variables
<code class="docutils literal"><span class="pre">beta</span></code>, <code class="docutils literal"><span class="pre">dx</span></code>, <code class="docutils literal"><span class="pre">L</span></code>, and <code class="docutils literal"><span class="pre">x</span></code>, and global functions <code class="docutils literal"><span class="pre">dsdt</span></code>, <code class="docutils literal"><span class="pre">g</span></code>, and <code class="docutils literal"><span class="pre">dudx</span></code>.</p>
<p>We expect the solution to be correct
regardless of <span class="math">\(N\)</span> and <span class="math">\(\Delta t\)</span>, so we can choose a small <span class="math">\(N\)</span>, <span class="math">\(N=4\)</span>,
and <span class="math">\(\Delta t = 0.1\)</span>. A test function with <span class="math">\(N=4\)</span> goes like</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">test_diffusion_exact_linear</span><span class="p">():</span>
    <span class="k">global</span> <span class="n">beta</span><span class="p">,</span> <span class="n">dx</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="n">x</span>  <span class="c"># needed in rhs</span>
    <span class="n">L</span> <span class="o">=</span> <span class="mf">1.5</span>
    <span class="n">beta</span> <span class="o">=</span> <span class="mf">0.5</span>
    <span class="n">N</span> <span class="o">=</span> <span class="mi">4</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">dx</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">u</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">(</span><span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>

    <span class="n">U_0</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">(</span><span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">U_0</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">s</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">U_0</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">=</span> <span class="n">u_exact</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">dt</span> <span class="o">=</span> <span class="mf">0.1</span>
    <span class="k">print</span> <span class="n">dt</span>

    <span class="n">u</span><span class="p">,</span> <span class="n">t</span> <span class="o">=</span> <span class="n">ode_FE</span><span class="p">(</span><span class="n">rhs</span><span class="p">,</span> <span class="n">U_0</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">T</span><span class="o">=</span><span class="mf">1.2</span><span class="p">)</span>

    <span class="n">tol</span> <span class="o">=</span> <span class="mf">1E-12</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">u</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
        <span class="n">diff</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">u_exact</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">t</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">-</span> <span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="p">,:])</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
        <span class="k">assert</span> <span class="n">diff</span> <span class="o">&lt;</span> <span class="n">tol</span><span class="p">,</span> <span class="s">&#39;diff=</span><span class="si">%.16g</span><span class="s">&#39;</span> <span class="o">%</span> <span class="n">diff</span>
        <span class="k">print</span> <span class="s">&#39;diff=</span><span class="si">%g</span><span class="s"> at t=</span><span class="si">%g</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">diff</span><span class="p">,</span> <span class="n">t</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
</pre></div>
</div>
<p>With <span class="math">\(N=4\)</span> we reproduce the linear solution exactly. This brings confidence
to the implementation, which is just what we need for attacking a real
physical problem next.</p>
<div class="admonition-problems-with-reusing-the-rhs-function admonition">
<p class="first admonition-title">Problems with reusing the <code class="docutils literal"><span class="pre">rhs</span></code> function</p>
<p>The <code class="docutils literal"><span class="pre">rhs</span></code> function <em>must</em> take <code class="docutils literal"><span class="pre">u</span></code> and <code class="docutils literal"><span class="pre">t</span></code> as arguments, because that
is required by the <code class="docutils literal"><span class="pre">ode_FE</span></code> function. What about the variables
<code class="docutils literal"><span class="pre">beta</span></code>, <code class="docutils literal"><span class="pre">dx</span></code>, <code class="docutils literal"><span class="pre">L</span></code>, <code class="docutils literal"><span class="pre">x</span></code>, <code class="docutils literal"><span class="pre">dsdt</span></code>, <code class="docutils literal"><span class="pre">g</span></code>, and <code class="docutils literal"><span class="pre">dudx</span></code>
that the <code class="docutils literal"><span class="pre">rhs</span></code> function needs?
These are global in the solution we have presented so far.
Unfortunately, this has an undesired side effect: we cannot import
the <code class="docutils literal"><span class="pre">rhs</span></code> function in a new file, define <code class="docutils literal"><span class="pre">dudx</span></code> and <code class="docutils literal"><span class="pre">dsdt</span></code>
in this new file and get the imported <code class="docutils literal"><span class="pre">rhs</span></code> to use these functions.
The imported <code class="docutils literal"><span class="pre">rhs</span></code> will use the global variables, including functions,
in its own module.</p>
<p>How can we find solutions to this problem? Technically, we must
pack the extra data
<code class="docutils literal"><span class="pre">beta</span></code>, <code class="docutils literal"><span class="pre">dx</span></code>, <code class="docutils literal"><span class="pre">L</span></code>, <code class="docutils literal"><span class="pre">x</span></code>, <code class="docutils literal"><span class="pre">dsdt</span></code>, <code class="docutils literal"><span class="pre">g</span></code>, and <code class="docutils literal"><span class="pre">dudx</span></code> with the
<code class="docutils literal"><span class="pre">rhs</span></code> function, which requires more advanced programming considered
beyond the scope of this text.</p>
<span class="target" id="index-13"></span><p class="last" id="index-14">A class is the simplest construction for packing a function together
with data, see the beginning of Chapter 7 in <a class="reference internal" href="._pylight009.html#ref18" id="id1">[Ref18]</a> for
a detailed example on how classes can be used in such a context.
Another solution in Python, and especially in computer languages
supporting <em>functional programming</em>, is so called <em>closures</em>. They are
also covered in Chapter 7 in the mentioned reference and behave in a
magic way. The third solution is to allow an arbitrary set of
arguments for <code class="docutils literal"><span class="pre">rhs</span></code> in a list to be transferred to <code class="docutils literal"><span class="pre">ode_FE</span></code> and then
back to <code class="docutils literal"><span class="pre">rhs</span></code>. Appendix H.4 in <a class="reference internal" href="._pylight009.html#ref18" id="id2">[Ref18]</a> explains the
technical details.</p>
</div>
</div>
<div class="section" id="application-heat-conduction-in-a-rod">
<span id="sec-pde-diff1d-rod"></span><h3>Application: heat conduction in a rod<a class="headerlink" href="#application-heat-conduction-in-a-rod" title="Permalink to this headline">¶</a></h3>
<p>Let us return to the case with heat conduction in a rod
<a class="reference internal" href="#eq-esixone"><span class="std std-ref">(120)</span></a>-<a class="reference internal" href="#eq-esixfour"><span class="std std-ref">(123)</span></a>. Assume that the rod is 50 cm long
and made of aluminum alloy 6082. The <span class="math">\(\beta\)</span> parameter equals
<span class="math">\(\kappa/(\varrho c)\)</span>, where
<span class="math">\(\kappa\)</span> is the heat conduction coefficient,
<span class="math">\(\varrho\)</span> is the density, and <span class="math">\(c\)</span> is the heat
capacity. We can find proper values for these physical quantities in the case of
aluminum alloy 6082:
<span class="math">\(\varrho = 2.7\cdot 10^3\hbox{ kg/m}^3\)</span>, <span class="math">\(\kappa = 200\,\,\frac{\hbox{W}}{\hbox{mK}}\)</span>,
<span class="math">\(c=900\,\,\frac{\hbox{J}}{\hbox{Kkg}}\)</span>. This results in
<span class="math">\(\beta = \kappa/(\varrho c) = 8.2\cdot 10^{-5}\hbox{ m}^2/\hbox{s}\)</span>.
Preliminary simulations show that we are close to a constant
steady state temperature after 1 h, i.e., <span class="math">\(T=3600\)</span> s.</p>
<p>The <code class="docutils literal"><span class="pre">rhs</span></code> function from the previous
section can be reused, only the functions <code class="docutils literal"><span class="pre">s</span></code>, <code class="docutils literal"><span class="pre">dsdt</span></code>, <code class="docutils literal"><span class="pre">g</span></code>, and <code class="docutils literal"><span class="pre">dudx</span></code>
must be changed (see file
<a class="reference external" href="https://github.com/hplgit/prog4comp/tree/master/src/py/rod_FE.py">rod_FE.py</a>):</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">dudx</span><span class="p">(</span><span class="n">t</span><span class="p">):</span>
    <span class="k">return</span> <span class="mi">0</span>

<span class="k">def</span> <span class="nf">s</span><span class="p">(</span><span class="n">t</span><span class="p">):</span>
    <span class="k">return</span> <span class="mi">323</span>

<span class="k">def</span> <span class="nf">dsdt</span><span class="p">(</span><span class="n">t</span><span class="p">):</span>
    <span class="k">return</span> <span class="mi">0</span>

<span class="k">def</span> <span class="nf">g</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">t</span><span class="p">):</span>
    <span class="k">return</span> <span class="mi">0</span>
</pre></div>
</div>
<p>Parameters can be set as</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">L</span> <span class="o">=</span> <span class="mf">0.5</span>
<span class="n">beta</span> <span class="o">=</span> <span class="mf">8.2E-5</span>
<span class="n">N</span> <span class="o">=</span> <span class="mi">40</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
<span class="n">dx</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="n">u</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">(</span><span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>

<span class="n">U_0</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">(</span><span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
<span class="n">U_0</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">s</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="n">U_0</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">=</span> <span class="mi">283</span>
</pre></div>
</div>
<p>Let us use <span class="math">\(\Delta t = 0.00034375\)</span>.
We can now call <code class="docutils literal"><span class="pre">ode_FE</span></code> and then make an animation on the screen
to see how <span class="math">\(u(x,t)\)</span> develops in time:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">t0</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">clock</span><span class="p">()</span>
<span class="kn">from</span> <span class="nn">ode_system_FE</span> <span class="kn">import</span> <span class="n">ode_FE</span>
<span class="n">u</span><span class="p">,</span> <span class="n">t</span> <span class="o">=</span> <span class="n">ode_FE</span><span class="p">(</span><span class="n">rhs</span><span class="p">,</span> <span class="n">U_0</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">T</span><span class="o">=</span><span class="mi">1</span><span class="o">*</span><span class="mi">60</span><span class="o">*</span><span class="mi">60</span><span class="p">)</span>
<span class="n">t1</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">clock</span><span class="p">()</span>
<span class="k">print</span> <span class="s">&#39;CPU time: </span><span class="si">%.1f</span><span class="s">s&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">t1</span> <span class="o">-</span> <span class="n">t0</span><span class="p">)</span>

<span class="c"># Make movie</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="n">os</span><span class="o">.</span><span class="n">system</span><span class="p">(</span><span class="s">&#39;rm tmp_*.png&#39;</span><span class="p">)</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="kn">as</span> <span class="nn">plt</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ion</span><span class="p">()</span>
<span class="n">y</span> <span class="o">=</span> <span class="n">u</span><span class="p">[</span><span class="mi">0</span><span class="p">,:]</span>
<span class="n">lines</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">axis</span><span class="p">([</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">x</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="mi">273</span><span class="p">,</span> <span class="n">s</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">+</span><span class="mi">10</span><span class="p">])</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s">&#39;x&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s">&#39;u(x,t)&#39;</span><span class="p">)</span>
<span class="n">counter</span> <span class="o">=</span> <span class="mi">0</span>
<span class="c"># Plot each of the first 100 frames, then increase speed by 10x</span>
<span class="n">change_speed</span> <span class="o">=</span> <span class="mi">100</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">u</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
    <span class="k">print</span> <span class="n">t</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
    <span class="n">plot</span> <span class="o">=</span> <span class="bp">True</span> <span class="k">if</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">change_speed</span> <span class="k">else</span> <span class="n">i</span> <span class="o">%</span> <span class="mi">10</span> <span class="o">==</span> <span class="mi">0</span>
    <span class="n">lines</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_ydata</span><span class="p">(</span><span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="p">,:])</span>
    <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="n">change_speed</span><span class="p">:</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">([</span><span class="s">&#39;t=</span><span class="si">%.0f</span><span class="s"> 10x&#39;</span> <span class="o">%</span> <span class="n">t</span><span class="p">[</span><span class="n">i</span><span class="p">]])</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">([</span><span class="s">&#39;t=</span><span class="si">%.0f</span><span class="s">&#39;</span> <span class="o">%</span> <span class="n">t</span><span class="p">[</span><span class="n">i</span><span class="p">]])</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">draw</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">plot</span><span class="p">:</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="s">&#39;tmp_</span><span class="si">%04d</span><span class="s">.png&#39;</span> <span class="o">%</span> <span class="n">counter</span><span class="p">)</span>
        <span class="n">counter</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="c">#time.sleep(0.2)</span>
</pre></div>
</div>
<p>The plotting statements update the <span class="math">\(u(x,t)\)</span> curve on the screen.
In addition, we save a fraction of the plots to files <code class="docutils literal"><span class="pre">tmp_0000.png</span></code>,
<code class="docutils literal"><span class="pre">tmp_0001.png</span></code>, <code class="docutils literal"><span class="pre">tmp_0002.png</span></code>, and so on. These plots can be combined to
ordinary video files. A common tool is <code class="docutils literal"><span class="pre">ffmpeg</span></code> or its sister <code class="docutils literal"><span class="pre">avconv</span></code>.</p>
<p>These programs take the same type of command-line options.
To make a Flash video <code class="docutils literal"><span class="pre">movie.flv</span></code>, run</p>
<div class="highlight-text"><div class="highlight"><pre>Terminal&gt; ffmpeg -i tmp_%04d.png -r 4 -vcodec flv movie.flv
</pre></div>
</div>
<p>The <code class="docutils literal"><span class="pre">-i</span></code> option specifies the naming of the plot files in printf syntax,
and <code class="docutils literal"><span class="pre">-r</span></code> specifies the number of frames per second in the movie.
On Mac, run <code class="docutils literal"><span class="pre">ffmpeg</span></code> instead of <code class="docutils literal"><span class="pre">avconv</span></code> with the same options.
Other video formats, such as MP4, WebM, and Ogg can also be produced:</p>
<div class="highlight-text"><div class="highlight"><pre>Terminal&gt; ffmpeg -i tmp_%04d.png -r 4 -vcodec libx264   movie.mp4
Terminal&gt; ffmpeg -i tmp_%04d.png -r 4 -vcodec libvpx    movie.webm
Terminal&gt; ffmpeg -i tmp_%04d.png -r 4 -vcodec libtheora movie.ogg
</pre></div>
</div>
<p>The results of a simulation start out as in Figures
<a class="reference internal" href="#sec-pde-diff1d-fig-instability1"><span class="std std-ref">Unstable simulation of the temperature in a rod</span></a> and
<a class="reference internal" href="#sec-pde-diff1d-fig-instability2"><span class="std std-ref">Unstable simulation of the temperature in a rod</span></a>. We see that the solution
definitely looks wrong. The temperature is expected to be smooth, not
having such a saw-tooth shape. Also, after some time (Figure
<a class="reference internal" href="#sec-pde-diff1d-fig-instability2"><span class="std std-ref">Unstable simulation of the temperature in a rod</span></a>), the temperature starts to
increase much more than expected. We say that this solution is
<em>unstable</em>, meaning that it does not display the same characteristics
as the true, physical solution. Even though we tested the code
carefully in the previous section, it does not seem to work for a
physical application! How can that be?</p>
<div class="figure" id="id4">
<span id="sec-pde-diff1d-fig-instability1"></span><a class="reference internal image-reference" href="_images/rod_instability1.png"><img alt="_images/rod_instability1.png" src="_images/rod_instability1.png" style="width: 800px;" /></a>
<p class="caption"><span class="caption-text"><em>Unstable simulation of the temperature in a rod</em></span></p>
</div>
<div class="figure" id="id5">
<span id="sec-pde-diff1d-fig-instability2"></span><a class="reference internal image-reference" href="_images/rod_instability2.png"><img alt="_images/rod_instability2.png" src="_images/rod_instability2.png" style="width: 800px;" /></a>
<p class="caption"><span class="caption-text"><em>Unstable simulation of the temperature in a rod</em></span></p>
</div>
<span class="target" id="index-15"></span><span class="target" id="index-16"></span><p id="index-17">The problem is that <span class="math">\(\Delta t\)</span> is too large, making the solution <em>unstable</em>.
It turns out that the Forward Euler time integration method
puts a restriction on the size of <span class="math">\(\Delta t\)</span>. For the heat equation and the
way we have discretized it, this restriction can be shown to be
<a class="reference internal" href="._pylight009.html#ref20" id="id3">[Ref20]</a></p>
<div class="math" id="eq-sec-pde-diff1d-stabcrit">
\[\tag{134}
\Delta t \leq \frac{\Delta x^2}{2\beta}\thinspace .\]</div>
<p>This is called a <em>stability criterion</em>. With the chosen parameters,
<a class="reference internal" href="#eq-sec-pde-diff1d-stabcrit"><span class="std std-ref">(134)</span></a> tells us that the upper limit is
<span class="math">\(\Delta t=0.0003125\)</span>, which is smaller than our choice above.
Rerunning the case with a <span class="math">\(\Delta t\)</span> equal to <span class="math">\(\Delta x^2/(2\beta)\)</span>, indeed
shows a smooth evolution of
<span class="math">\(u(x,t)\)</span>. Find the program <code class="docutils literal"><span class="pre">rod_FE.py</span></code> and run it to see
an animation of the <span class="math">\(u(x,t)\)</span> function on the screen.</p>
<div class="admonition-scaling-and-dimensionless-quantities admonition" id="index-18">
<p class="first admonition-title">Scaling and dimensionless quantities</p>
<p>Our setting of parameters required finding three physical properties of
a certain material. The time interval for simulation and the time step
depend crucially on the values for <span class="math">\(\beta\)</span> and <span class="math">\(L\)</span>, which can vary significantly
from case to case. Often, we are more interested in how
the shape of <span class="math">\(u(x,t)\)</span> develops, than in the actual <span class="math">\(u\)</span>, <span class="math">\(x\)</span>, and <span class="math">\(t\)</span>
values for a specific material. We can then simplify the setting of
physical parameters by <em>scaling</em> the problem.</p>
<p>Scaling means that we introduce dimensionless independent and dependent
variables, here denoted by a bar:</p>
<div class="math">
\[\bar u = \frac{u-u^*}{u_c-u^*},\quad \bar x=\frac{x}{x_c},\quad \bar t = \frac{t}{t_c},\]</div>
<p>where <span class="math">\(u_c\)</span> is a characteristic size of the temperature, <span class="math">\(u^*\)</span> is
some reference temperature, while <span class="math">\(x_c\)</span> and
<span class="math">\(t_c\)</span> are characteristic time and space scales.
Here, it is natural to choose <span class="math">\(u^*\)</span> as the initial
condition, and set <span class="math">\(u_c\)</span> to the stationary (end) temperature.
Then <span class="math">\(\bar u\in [0,1]\)</span>, starting at 0 and ending at 1 as <span class="math">\(t\rightarrow\infty\)</span>.
The length <span class="math">\(L\)</span> is <span class="math">\(x_c\)</span>, while choosing <span class="math">\(t_c\)</span> is more challenging, but
one can argue for <span class="math">\(t_c = L^2/\beta\)</span>.
The resulting equation for <span class="math">\(\bar u\)</span> reads</p>
<div class="math">
\[\frac{\partial \bar u}{\partial \bar t} =
\frac{\partial^2 \bar u}{\partial \bar x^2},\quad \bar x\in (0,1)\thinspace .\]</div>
<p>Note that in this equation, there are <em>no physical parameters</em>!
In other words, we have found a model that is independent of the length
of the rod and the material it is made of (!).</p>
<p>We can easily solve this equation with our program by setting <span class="math">\(\beta=1\)</span>,
<span class="math">\(L=1\)</span>, <span class="math">\(I(x)=0\)</span>, and <span class="math">\(s(t)=1\)</span>.
It turns out that the total simulation time (to &#8220;infinity&#8221;)
can be taken as 1.2. When we have the solution <span class="math">\(\bar u(\bar x,\bar t)\)</span>,
the solution with dimension Kelvin, reflecting the true temperature
in our medium, is given by</p>
<div class="math">
\[u(x,t) = u^* + (u_c-u^*)\bar u(x/L, t\beta/L^2)\thinspace .\]</div>
<p>Through this formula we can quickly generate the solutions for
a rod made of aluminum, wood, or rubber - it is just a matter of
plugging in the right <span class="math">\(\beta\)</span> value.</p>
<p>Figure <a class="reference internal" href="#sec-pde-diff1d-fig-scaled"><span class="std std-ref">Snapshots of the dimensionless solution of a scaled problem</span></a> shows four snapshots of the scaled (dimensionless)
solution <span class="math">\(\bar (\bar x,\bar t)\)</span>.</p>
<p class="last">The power of scaling is to reduce the number of physical parameters
in a problem, and in the present case, we found one single problem
that is independent of the material (<span class="math">\(\beta\)</span>) and the geometry (<span class="math">\(L\)</span>).</p>
</div>
<div class="figure" id="id6">
<span id="sec-pde-diff1d-fig-scaled"></span><a class="reference internal image-reference" href="_images/rod_temp_scaled.png"><img alt="_images/rod_temp_scaled.png" src="_images/rod_temp_scaled.png" style="width: 800px;" /></a>
<p class="caption"><span class="caption-text"><em>Snapshots of the dimensionless solution of a scaled problem</em></span></p>
</div>
</div>
<div class="section" id="vectorization-2">
<h3>Vectorization<a class="headerlink" href="#vectorization-2" title="Permalink to this headline">¶</a></h3>
<p id="index-19">Occasionally in this book, we show how to speed up code by replacing
loops over arrays by vectorized expressions.
The present problem involves a loop for computing the right-hand side:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">N</span><span class="p">):</span>
    <span class="n">rhs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">beta</span><span class="o">/</span><span class="n">dx</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">+</span> <span class="n">g</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">t</span><span class="p">)</span>
</pre></div>
</div>
<p>This loop can be replaced by a vectorized expression with the following
reasoning. We want to set all the inner points at once: <code class="docutils literal"><span class="pre">rhs[1:N-1]</span></code>
(this goes from index <code class="docutils literal"><span class="pre">1</span></code> up to, but not including, <code class="docutils literal"><span class="pre">N</span></code>). As the loop
index <code class="docutils literal"><span class="pre">i</span></code> runs from <code class="docutils literal"><span class="pre">1</span></code> to <code class="docutils literal"><span class="pre">N-1</span></code>, the <code class="docutils literal"><span class="pre">u[i+1]</span></code>
term will cover all the inner <code class="docutils literal"><span class="pre">u</span></code> values displaced one index to the right
(compared to <code class="docutils literal"><span class="pre">1:N-1</span></code>), i.e., <code class="docutils literal"><span class="pre">u[2:N]</span></code>. Similarly, <code class="docutils literal"><span class="pre">u[i-1]</span></code> corresponds
to all inner <code class="docutils literal"><span class="pre">u</span></code> values displaced one index to the left: <code class="docutils literal"><span class="pre">u[0:N-2]</span></code>.
Finally, <code class="docutils literal"><span class="pre">u[i]</span></code> has the same indices as <code class="docutils literal"><span class="pre">rhs</span></code>: <code class="docutils literal"><span class="pre">u[1:N-1]</span></code>. The
vectorized loop can therefore be written in terms of slices:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">rhs</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="n">N</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">beta</span><span class="o">/</span><span class="n">dx</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">u</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">u</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="n">N</span><span class="p">]</span> <span class="o">+</span> <span class="n">u</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">N</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">+</span>
           <span class="n">g</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="n">N</span><span class="p">],</span> <span class="n">t</span><span class="p">)</span>
</pre></div>
</div>
<p>This rewrite speeds up the code by about a factor of 10.
A complete code is found in the file <code class="docutils literal"><span class="pre">rod_FE_vec.py</span></code>.</p>
</div>
<div class="section" id="using-odespy-to-solve-the-system-of-odes">
<h3>Using Odespy to solve the system of ODEs<a class="headerlink" href="#using-odespy-to-solve-the-system-of-odes" title="Permalink to this headline">¶</a></h3>
<p>Let us now show how to apply a general ODE package
like Odespy (see the section <a class="reference internal" href="._pylight005.html#sec-de-osc-odespy"><span class="std std-ref">Software for solving ODEs</span></a>) to solve
our diffusion problem. As long as we have defined a right-hand
side function <code class="docutils literal"><span class="pre">rhs</span></code> this is very straightforward:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">odespy</span>
<span class="n">solver</span> <span class="o">=</span> <span class="n">odespy</span><span class="o">.</span><span class="n">RKFehlberg</span><span class="p">(</span><span class="n">rhs</span><span class="p">)</span>
<span class="n">solver</span><span class="o">.</span><span class="n">set_initial_condition</span><span class="p">(</span><span class="n">U_0</span><span class="p">)</span>
<span class="n">T</span> <span class="o">=</span> <span class="mf">1.2</span>
<span class="n">N_t</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">T</span><span class="o">/</span><span class="nb">float</span><span class="p">(</span><span class="n">dt</span><span class="p">)))</span>
<span class="n">time_points</span> <span class="o">=</span> <span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">N_t</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
<span class="n">u</span><span class="p">,</span> <span class="n">t</span> <span class="o">=</span> <span class="n">solver</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">time_points</span><span class="p">)</span>

<span class="c"># Check how many time steps are required by adaptive vs</span>
<span class="c"># fixed-step methods</span>
<span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">solver</span><span class="p">,</span> <span class="s">&#39;t_all&#39;</span><span class="p">):</span>
    <span class="k">print</span> <span class="s">&#39;# time steps:&#39;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">solver</span><span class="o">.</span><span class="n">t_all</span><span class="p">)</span>
<span class="k">else</span><span class="p">:</span>
    <span class="k">print</span> <span class="s">&#39;# time steps:&#39;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
</pre></div>
</div>
<p>The very nice thing is that we can now easily experiment with many different integration methods.
Trying out some simple ones first, like
<code class="docutils literal"><span class="pre">RK2</span></code> and <code class="docutils literal"><span class="pre">RK4</span></code>, quickly reveals that the time step limitation of
the Forward Euler scheme also applies to these more sophisticated
Runge-Kutta methods, but their accuracy is better. However, the Odespy package
offers also adaptive methods. We can then specify a much larger
time step in <code class="docutils literal"><span class="pre">time_points</span></code>, and the solver will figure out
the appropriate step. Above we indicated how to use the adaptive
Runge-Kutta-Fehlberg 4-5 solver. While the <span class="math">\(\Delta t\)</span> corresponding
to the Forward Euler method requires over 8000 steps for a
simulation, we started the <code class="docutils literal"><span class="pre">RKFehlberg</span></code> method with 100 times this
time step and in the end it required just slightly more than 2500
steps, using the default tolerance parameters. Lowering the tolerance
did not save any significant amount of computational work.
Figure <a class="reference internal" href="#sec-pde-diff1d-fig-rkfehlberg"><span class="std std-ref">Time steps used by the Runge-Kutta-Fehlberg method: error tolerance  \( 10^{-3} \)  (left) and  \( 10^{-6} \)  (right)</span></a>
shows a comparison of the length of all the time steps
for two values of the tolerance. We see that the influence of the tolerance
is minor in this computational example, so it seems that the blow-up
due to instability is what governs the time step size. The nice feature
of this adaptive method is that we can just specify when we want the
solution to be computed, and the method figures out on its own what
time step that has to be used because of stability restrictions.</p>
<div class="figure" id="id7">
<span id="sec-pde-diff1d-fig-rkfehlberg"></span><a class="reference internal image-reference" href="_images/rod_RKFehlberg_dt.png"><img alt="_images/rod_RKFehlberg_dt.png" src="_images/rod_RKFehlberg_dt.png" style="width: 700px;" /></a>
<p class="caption"><span class="caption-text"><em>Time steps used by the Runge-Kutta-Fehlberg method: error tolerance  \( 10^{-3} \)  (left) and  \( 10^{-6} \)  (right)</em></span></p>
</div>
<p>We have seen how easy it is to apply sophisticated methods for
ODEs to this PDE example. We shall take the use of Odespy one step
further in the next section.</p>
</div>
<div class="section" id="implicit-methods">
<h3>Implicit methods<a class="headerlink" href="#implicit-methods" title="Permalink to this headline">¶</a></h3>
<p>A major problem with the stability criterion <a class="reference internal" href="#eq-sec-pde-diff1d-stabcrit"><span class="std std-ref">(134)</span></a>
is that the time step becomes very small if <span class="math">\(\Delta x\)</span> is small.
For example, halving <span class="math">\(\Delta x\)</span> requires four times as many time
steps and eight times the work. Now, with <span class="math">\(N=40\)</span>, which is a reasonable
resolution for the test problem above, the computations are very fast.
What takes time, is the visualization on the screen, but for that purpose one
can visualize only a subset of the time steps. However, there are occasions
when you need to take larger time steps with the
diffusion equation, especially if interest is in the long-term behavior
as <span class="math">\(t\rightarrow\infty\)</span>. You must then turn to <em>implicit methods</em> for ODEs.
These methods require the solutions of <em>linear systems</em>, if the underlying
PDE is linear, and systems of <em>nonlinear algebraic equations</em> if the
underlying PDE is non-linear.</p>
<p>The simplest implicit method is the Backward Euler scheme, which puts
no restrictions on <span class="math">\(\Delta t\)</span> for stability, but obviously, a large
<span class="math">\(\Delta t\)</span> leads to inaccurate results. The Backward Euler scheme
for a scalar ODE <span class="math">\(u' = f(u,t)\)</span> reads</p>
<div class="math">
\[\frac{u^{n+1} - u^{n}}{\Delta t} = f(u^{n+1}, t_{n+1})\thinspace .\]</div>
<p>This equation is to be solved for <span class="math">\(u^{n+1}\)</span>. If <span class="math">\(f\)</span> is linear in <span class="math">\(u\)</span>,
it is a linear equation, but if <span class="math">\(f\)</span> is nonlinear in <span class="math">\(u\)</span>, one needs
approximate methods for nonlinear equations (the chapter <a class="reference internal" href="._pylight007.html#th-nonlinalgeq"><span class="std std-ref">Solving nonlinear algebraic equations</span></a>).</p>
<p>In our case, we have a system of linear ODEs
<a class="reference internal" href="#eq-sec-pde-diff1d-ode1-0"><span class="std std-ref">(128)</span></a>-<a class="reference internal" href="#eq-sec-pde-diff1d-ode1-n"><span class="std std-ref">(130)</span></a>. The Backward
Euler scheme applied to each equation leads to</p>
<div class="math" id="eq-sec-pde-diff1d-ode1-0-be">
\[\tag{135}
\frac{u_0^{n+1}-u_0^n}{\Delta t} = s'(t_{n+1}),\]</div>
<div class="math" id="eq-sec-pde-diff1d-ode1-i-be">
\[\tag{136}
\frac{u_i^{n+1} - u_i^{n}}{\Delta t} =  \frac{\beta}{\Delta x^2}
    (u_{i+1}^{n+1} - 2u_i^{n+1} + u_{i-1}^{n+1}) + g_i(t_{n+1}),\]</div>
<div class="math">
\[\qquad\qquad \quad i=1,\ldots,N-1,\nonumber\]</div>
<div class="math" id="eq-sec-pde-diff1d-ode1-n-be">
\[\tag{137}
\frac{u_N^{n+1} - u_N^{n}}{\Delta t} =  \frac{2\beta}{\Delta x^2}
    (u_{N-1}^{n+1} - u_N^{n+1}) + g_i(t_{n+1})\thinspace .\]</div>
<p>This is a system of linear equations in the unknowns
<span class="math">\(u_i^{n+1}\)</span>, <span class="math">\(i=0,\ldots,N\)</span>, which is easy to realize by writing out
the equations for the case <span class="math">\(N=3\)</span>, collecting all the unknown
terms on the left-hand side and all the known terms on the right-hand side:</p>
<div class="math" id="eq-sec-pde-diff1d-ode1-0-be-3">
\[\tag{138}
u_0^{n+1} = u_0^n + \Delta t\,s'(t_{n+1}),\]</div>
<div class="math" id="eq-sec-pde-diff1d-ode1-i-be-3">
\[\tag{139}
u_1^{n+1} - \Delta t \frac{\beta}{\Delta x^2}
    (u_{2}^{n+1} - 2u_1^{n+1} + u_{0}^{n+1})
    = u_1^{n}  + \Delta t\,g_1(t_{n+1}),\]</div>
<div class="math" id="eq-sec-pde-diff1d-ode1-n-be-3">
\[\tag{140}
u_2^{n+1} - \Delta t\frac{2\beta}{\Delta x^2}
    (u_{1}^{n+1} - u_2^{n+1})  = u_2^{n}  + \Delta t\,g_2(t_{n+1})\thinspace .\]</div>
<p>A system of linear equations like this, is usually written on matrix form
<span class="math">\(Au=b\)</span>, where <span class="math">\(A\)</span> is a coefficient matrix, <span class="math">\(u=(u_0^{n+1},\ldots,n_N^{n+1})\)</span>
is the vector of unknowns, and <span class="math">\(b\)</span> is a vector of known values.
The coefficient matrix for the case <a class="reference internal" href="#eq-sec-pde-diff1d-ode1-0-be-3"><span class="std std-ref">(138)</span></a>-<a class="reference internal" href="#eq-sec-pde-diff1d-ode1-n-be-3"><span class="std std-ref">(140)</span></a> becomes</p>
<div class="math">
\[\begin{split}A = \left(\begin{array}{ccc}
1 &amp; 0 &amp; 0\\
-\Delta t \frac{\beta}{\Delta x^2} &amp; 1 + 2\Delta t \frac{\beta}{\Delta x^2}
&amp; - \Delta t \frac{\beta}{\Delta x^2}\\
0 &amp; - \Delta t\frac{2\beta}{\Delta x^2} &amp; 1 + \Delta t\frac{2\beta}{\Delta x^2}
\end{array}\right)\end{split}\]</div>
<p>In the general case <a class="reference internal" href="#eq-sec-pde-diff1d-ode1-0-be"><span class="std std-ref">(135)</span></a>-<a class="reference internal" href="#eq-sec-pde-diff1d-ode1-n-be"><span class="std std-ref">(137)</span></a>, the coefficient matrix is an <span class="math">\((N+1)\times(N+1)\)</span> matrix with
zero entries, except for</p>
<div class="math" id="eq-auto37">
\[\tag{141}
A_{1,1} = 1\]</div>
<div class="math" id="eq-auto38">
\[\tag{142}
A_{i,i-1} = -\Delta t \frac{\beta}{\Delta x^2},\quad i=2,\ldots,N-1\]</div>
<div class="math" id="eq-auto39">
\[\tag{143}
A_{i,i+1} = -\Delta t \frac{\beta}{\Delta x^2},\quad i=2,\ldots,N-1\]</div>
<div class="math" id="eq-auto40">
\[\tag{144}
A_{i,i} = 1 + 2\Delta t \frac{\beta}{\Delta x^2},\quad i=2,\ldots,N-1\]</div>
<div class="math" id="eq-auto41">
\[\tag{145}
A_{N,N-1}  = - \Delta t\frac{2\beta}{\Delta x^2}\]</div>
<div class="math" id="eq-auto42">
\[\tag{146}
A_{N,N} = 1 + \Delta t\frac{2\beta}{\Delta x^2}\]</div>
<p>If we want to apply general methods for systems of ODEs on the form
<span class="math">\(u'=f(u,t)\)</span>, we can assume a linear <span class="math">\(f(u,t)=Ku\)</span>. The coefficient
matrix <span class="math">\(K\)</span> is found from the right-hand side of
<a class="reference internal" href="#eq-sec-pde-diff1d-ode1-0-be"><span class="std std-ref">(135)</span></a>-<a class="reference internal" href="#eq-sec-pde-diff1d-ode1-n-be"><span class="std std-ref">(137)</span></a> to
be</p>
<div class="math" id="eq-auto43">
\[\tag{147}
K_{1,1} = 0\]</div>
<div class="math" id="eq-auto44">
\[\tag{148}
K_{i,i-1} = \frac{\beta}{\Delta x^2},\quad i=2,\ldots,N-1\]</div>
<div class="math" id="eq-auto45">
\[\tag{149}
K_{i,i+1} = \frac{\beta}{\Delta x^2},\quad i=2,\ldots,N-1\]</div>
<div class="math" id="eq-auto46">
\[\tag{150}
K_{i,i} = -\frac{2\beta}{\Delta x^2},\quad i=2,\ldots,N-1\]</div>
<div class="math" id="eq-auto47">
\[\tag{151}
K_{N,N-1}  = \frac{2\beta}{\Delta x^2}\]</div>
<div class="math" id="eq-auto48">
\[\tag{152}
K_{N,N} = -\frac{2\beta}{\Delta x^2}\]</div>
<p>We see that <span class="math">\(A=I-\Delta t\,K\)</span>.</p>
<p>To implement the Backward Euler scheme, we can either fill a matrix
and call a linear solver, or we can apply Odespy. We follow the
latter strategy. Implicit methods in Odespy need the <span class="math">\(K\)</span> matrix above,
given as an argument <code class="docutils literal"><span class="pre">jac</span></code> (Jacobian of <span class="math">\(f\)</span>) in the call to
<code class="docutils literal"><span class="pre">odespy.BackwardEuler</span></code>.
Here is the Python code for the right-hand side of the ODE system (<code class="docutils literal"><span class="pre">rhs</span></code>)
and the <span class="math">\(K\)</span> matrix (<code class="docutils literal"><span class="pre">K</span></code>) as well as statements
for initializing and running the Odespy solver <code class="docutils literal"><span class="pre">BackwardEuler</span></code>
(in the file <a class="reference external" href="https://github.com/hplgit/prog4comp/tree/master/src/py/rod_BE.py">rod_BE.py</a>):</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">rhs</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">t</span><span class="p">):</span>
    <span class="n">N</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">u</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="n">rhs</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">(</span><span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">rhs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">dsdt</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">N</span><span class="p">):</span>
        <span class="n">rhs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">beta</span><span class="o">/</span><span class="n">dx</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">+</span> \
                 <span class="n">g</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">t</span><span class="p">)</span>
    <span class="n">rhs</span><span class="p">[</span><span class="n">N</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">beta</span><span class="o">/</span><span class="n">dx</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">dx</span><span class="o">*</span><span class="n">dudx</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="o">-</span>
                           <span class="mi">2</span><span class="o">*</span><span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">+</span> <span class="n">g</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">N</span><span class="p">],</span> <span class="n">t</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">rhs</span>

<span class="k">def</span> <span class="nf">K</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">t</span><span class="p">):</span>
    <span class="n">N</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">u</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="n">K</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">((</span><span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>
    <span class="n">K</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">N</span><span class="p">):</span>
        <span class="n">K</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">beta</span><span class="o">/</span><span class="n">dx</span><span class="o">**</span><span class="mi">2</span>
        <span class="n">K</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">2</span><span class="o">*</span><span class="n">beta</span><span class="o">/</span><span class="n">dx</span><span class="o">**</span><span class="mi">2</span>
        <span class="n">K</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">beta</span><span class="o">/</span><span class="n">dx</span><span class="o">**</span><span class="mi">2</span>
    <span class="n">K</span><span class="p">[</span><span class="n">N</span><span class="p">,</span><span class="n">N</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">beta</span><span class="o">/</span><span class="n">dx</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="mi">2</span>
    <span class="n">K</span><span class="p">[</span><span class="n">N</span><span class="p">,</span><span class="n">N</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">beta</span><span class="o">/</span><span class="n">dx</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">K</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">odespy</span>
<span class="n">solver</span> <span class="o">=</span> <span class="n">odespy</span><span class="o">.</span><span class="n">BackwardEuler</span><span class="p">(</span><span class="n">rhs</span><span class="p">,</span> <span class="n">f_is_linear</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">jac</span><span class="o">=</span><span class="n">K</span><span class="p">)</span>
<span class="n">solver</span> <span class="o">=</span> <span class="n">odespy</span><span class="o">.</span><span class="n">ThetaRule</span><span class="p">(</span><span class="n">rhs</span><span class="p">,</span> <span class="n">f_is_linear</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">jac</span><span class="o">=</span><span class="n">K</span><span class="p">,</span> <span class="n">theta</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>
<span class="n">solver</span><span class="o">.</span><span class="n">set_initial_condition</span><span class="p">(</span><span class="n">U_0</span><span class="p">)</span>
<span class="n">T</span> <span class="o">=</span> <span class="mi">1</span><span class="o">*</span><span class="mi">60</span><span class="o">*</span><span class="mi">60</span>
<span class="n">N_t</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">T</span><span class="o">/</span><span class="nb">float</span><span class="p">(</span><span class="n">dt</span><span class="p">)))</span>
<span class="n">time_points</span> <span class="o">=</span> <span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">N_t</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
<span class="n">u</span><span class="p">,</span> <span class="n">t</span> <span class="o">=</span> <span class="n">solver</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">time_points</span><span class="p">)</span>
</pre></div>
</div>
<p>The file <code class="docutils literal"><span class="pre">rod_BE.py</span></code> has all the details and shows a movie of
the solution. We can run it with any <span class="math">\(\Delta t\)</span> we want, its size just
impacts the accuracy of the first steps.</p>
<span class="target" id="index-20"></span><div class="admonition-odespy-solvers-apply-dense-matrices admonition" id="index-21">
<p class="first admonition-title">Odespy solvers apply dense matrices</p>
<p>Looking at the entries of the <span class="math">\(K\)</span> matrix, we realize that there are
at maximum three entries different from zero in each row. Therefore,
most of the entries are zeroes. The Odespy solvers expect dense
square matrices as input, here with <span class="math">\((N+1)\times(N+1)\)</span> elements.
When solving the linear systems, a lot of storage and work are spent
on the zero entries in the matrix. It would be much more efficient to
store the matrix as a <em>tridiagonal</em> matrix and apply a specialized
Gaussian elimination solver for tridiagonal systems. Actually, this
reduces the work from the order <span class="math">\(N^3\)</span> to the order <span class="math">\(N\)</span>.</p>
<p class="last">In one-dimensional diffusion problems, the savings of using a tridiagonal
matrix are modest in practice, since the matrices are very small anyway.
In two- and three-dimensional PDE problems, however, one cannot afford dense
square matrices. Rather, one <em>must</em> resort to more efficient storage formats
and algorithms tailored to such formats, but this is beyond the scope of the present text.</p>
</div>
</div>
</div>
<div class="section" id="exercises-5">
<h2>Exercises<a class="headerlink" href="#exercises-5" title="Permalink to this headline">¶</a></h2>
<div class="section" id="exercise-63-simulate-a-diffusion-equation-by-hand">
<span id="sec-pde-diff1d-exer-handfe"></span><h3>Exercise 63: Simulate a diffusion equation by hand<a class="headerlink" href="#exercise-63-simulate-a-diffusion-equation-by-hand" title="Permalink to this headline">¶</a></h3>
<p>Consider the problem given by <a class="reference internal" href="#eq-sec-pde-diff1d-ode1-0"><span class="std std-ref">(128)</span></a>, <a class="reference internal" href="#eq-sec-pde-diff1d-ode1-i"><span class="std std-ref">(129)</span></a>
and <a class="reference internal" href="#eq-sec-pde-diff1d-discrete-n2"><span class="std std-ref">(133)</span></a>.
Set <span class="math">\(N=2\)</span> and compute <span class="math">\(u_i^0\)</span>, <span class="math">\(u_i^1\)</span> and <span class="math">\(u_i^2\)</span> by hand for <span class="math">\(i=0,1,2\)</span>.
Use these values to construct a test function for checking that the
implementation is correct.
Copy useful functions from
<code class="docutils literal"><span class="pre">test_diffusion_pde_exact_linear.py</span></code>
and make a new test function <code class="docutils literal"><span class="pre">test_diffusion_hand_calculation</span></code>.</p>
<p><strong>Solution.</strong>
Applying the forward Euler method to <a class="reference internal" href="#eq-sec-pde-diff1d-ode1-0"><span class="std std-ref">(128)</span></a>, we get</p>
<div class="math">
\[u_0^{n+1}=u_0^n - \Delta t (3L),\quad n=0,1\thinspace .\]</div>
<p>For the requested <code class="docutils literal"><span class="pre">n</span></code> values, we then find that</p>
<div class="math">
\[u_0^0 = 2(0-L)=-2L=-2(1.5)=-3.0\thinspace ,\nonumber\]</div>
<div class="math">
\[u_0^1 = u_0^0 - \Delta t (3L)=-3.0 - 0.1(3(1.5))=-3.45\thinspace ,\nonumber\]</div>
<div class="math">
\[u_0^2 = u_0^1 - \Delta t (3L)=-3.45 - 0.1(3(1.5))=-3.90\thinspace .\nonumber\]</div>
<p>Similarly, with forward Euler applied to <a class="reference internal" href="#eq-sec-pde-diff1d-ode1-i"><span class="std std-ref">(129)</span></a>, we get</p>
<div class="math">
\[u_1^{n+1}=u_1^n + \frac{\beta \Delta t}{\Delta x^2} (u_2^n - 2u_1^n + u_0^n) + \Delta t (f_1^n),\quad n=0,1\thinspace .\]</div>
<p>For the requested <code class="docutils literal"><span class="pre">n</span></code> values, we find</p>
<div class="math">
\[u_1^0 = 2(0.75-L)=2(0.75-1.5)=-1.5\thinspace ,\nonumber\]</div>
<div class="math">
\[u_1^1 = u_1^0 + \frac{\beta \Delta t}{\Delta x^2} (u_2^0 - 2u_1^0 + u_0^0) + \Delta t (f_1^0)\thinspace ,\nonumber\]</div>
<div class="math">
\[= -1.5 + \frac{(0.5)(0.1)}{0.75^2} (0 - 2(-1.5) + (-3.0)) + 0.1 (3(0.75-1.5))\thinspace ,\nonumber\]</div>
<div class="math">
\[= -1.725\thinspace ,\nonumber\]</div>
<div class="math">
\[u_1^2 = u_1^1 + \frac{\beta \Delta t}{\Delta x^2} (u_2^1 - 2u_1^1 + u_0^1) + \Delta t (f_1^1)\thinspace ,\nonumber\]</div>
<div class="math">
\[= -1.725 + \frac{(0.5)(0.1)}{0.75^2} (0 - 2(-1.725) + (-3.45)) + 0.1(3(0.75-1.5))\thinspace ,\nonumber\]</div>
<div class="math">
\[= -1.95\thinspace .\nonumber\]</div>
<p>Finally, applying the forward Euler method to <a class="reference internal" href="#eq-sec-pde-diff1d-discrete-n2"><span class="std std-ref">(133)</span></a>, we get</p>
<div class="math">
\[u_2^{n+1}=u_2^n + \frac{2\beta \Delta t}{\Delta x^2} (u_1^n + \Delta x\gamma - u_2^n) + \Delta t (f_2^n),\quad n=0,1\thinspace .\]</div>
<p>For the requested <code class="docutils literal"><span class="pre">n</span></code> values, we find</p>
<div class="math">
\[u_2^0 = 2(L-L)=0\thinspace ,\nonumber\]</div>
<div class="math">
\[u_2^1 = u_2^0 + \frac{2\beta \Delta t}{\Delta x^2} (u_1^0 + \Delta x\gamma + u_2^0) + \Delta t (f_2^0)\thinspace ,\nonumber\]</div>
<div class="math">
\[= 0 + \frac{2(0.5)(0.1)}{0.75^2} (2(0.75-1.5) + \frac{1.5}{2}(3(0) + 2) - 0) + 0.1 (0))\thinspace ,\nonumber\]</div>
<div class="math">
\[= 0\thinspace ,\nonumber\]</div>
<div class="math">
\[u_2^2 = u_2^1 + \frac{2\beta \Delta t}{\Delta x^2} (u_1^1 + \Delta x\gamma - u_2^1) + \Delta t (f_2^1)\thinspace ,\nonumber\]</div>
<div class="math">
\[= 0 + \frac{2(0.5)(0.1)}{0.75^2} (-1.725 + \frac{1.5}{2}(3(0.1)+2)-0) + 0.1(3(1.5-1.5))\thinspace ,\nonumber\]</div>
<div class="math">
\[= 0\thinspace .\nonumber\]</div>
<p>Code:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="sd">&quot;&quot;&quot;Hand calc: Verify implementation of the diffusion equation&quot;&quot;&quot;</span>

<span class="kn">from</span> <span class="nn">ode_system_FE</span> <span class="kn">import</span> <span class="n">ode_FE</span>
<span class="kn">from</span> <span class="nn">numpy</span> <span class="kn">import</span> <span class="n">linspace</span><span class="p">,</span> <span class="n">zeros</span><span class="p">,</span> <span class="nb">abs</span>
<span class="c">#from test_diffusion_pde_exact_linear import rhs, u_exact, dudx, s, dsdt, f</span>

<span class="k">def</span> <span class="nf">rhs</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">t</span><span class="p">):</span>
    <span class="n">N</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">u</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="n">rhs</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">(</span><span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">rhs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">dsdt</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">N</span><span class="p">):</span>
        <span class="n">rhs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">beta</span><span class="o">/</span><span class="n">dx</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">+</span> \
                 <span class="n">g</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">t</span><span class="p">)</span>
    <span class="n">rhs</span><span class="p">[</span><span class="n">N</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">beta</span><span class="o">/</span><span class="n">dx</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">u</span><span class="p">[</span><span class="n">N</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">dx</span><span class="o">*</span><span class="n">dudx</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="o">-</span>
                           <span class="mi">2</span><span class="o">*</span><span class="n">u</span><span class="p">[</span><span class="n">N</span><span class="p">])</span> <span class="o">+</span> <span class="n">g</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">N</span><span class="p">],</span> <span class="n">t</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">rhs</span>

<span class="k">def</span> <span class="nf">u_exact</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">t</span><span class="p">):</span>
    <span class="k">return</span> <span class="p">(</span><span class="mi">3</span><span class="o">*</span><span class="n">t</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="n">L</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">dudx</span><span class="p">(</span><span class="n">t</span><span class="p">):</span>
    <span class="k">return</span> <span class="p">(</span><span class="mi">3</span><span class="o">*</span><span class="n">t</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">s</span><span class="p">(</span><span class="n">t</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">u_exact</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">dsdt</span><span class="p">(</span><span class="n">t</span><span class="p">):</span>
    <span class="k">return</span> <span class="mi">3</span><span class="o">*</span><span class="p">(</span><span class="o">-</span><span class="n">L</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">g</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">t</span><span class="p">):</span>
    <span class="k">return</span> <span class="mi">3</span><span class="o">*</span><span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="n">L</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">test_rod_diffusion_hand</span><span class="p">():</span>
    <span class="k">global</span> <span class="n">beta</span><span class="p">,</span> <span class="n">dx</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="n">x</span>      <span class="c"># needed in rhs</span>
    <span class="n">L</span> <span class="o">=</span> <span class="mf">1.5</span>
    <span class="n">beta</span> <span class="o">=</span> <span class="mf">0.5</span>
    <span class="n">N</span> <span class="o">=</span> <span class="mi">2</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">dx</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">u</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">(</span><span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>

    <span class="n">U_0</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">(</span><span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">U_0</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">s</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">U_0</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">=</span> <span class="n">u_exact</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span> <span class="mi">0</span><span class="p">)</span>

    <span class="n">u_hand</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">U_0</span><span class="p">)))</span>
    <span class="n">u_hand</span><span class="p">[</span><span class="mi">0</span><span class="p">,:]</span> <span class="o">=</span> <span class="o">-</span><span class="mf">3.0</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.5</span><span class="p">,</span> <span class="mf">0.0</span>    <span class="c"># spatial indices: 0, 1 and 2</span>
    <span class="n">u_hand</span><span class="p">[</span><span class="mi">1</span><span class="p">,:]</span> <span class="o">=</span> <span class="o">-</span><span class="mf">3.45</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.725</span><span class="p">,</span> <span class="mf">0.0</span>
    <span class="n">u_hand</span><span class="p">[</span><span class="mi">2</span><span class="p">,:]</span> <span class="o">=</span> <span class="o">-</span><span class="mf">3.90</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.95</span><span class="p">,</span> <span class="mf">0.0</span>

    <span class="n">dt</span> <span class="o">=</span> <span class="mf">0.1</span>

    <span class="n">u</span><span class="p">,</span> <span class="n">t</span> <span class="o">=</span> <span class="n">ode_FE</span><span class="p">(</span><span class="n">rhs</span><span class="p">,</span> <span class="n">U_0</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">T</span><span class="o">=</span><span class="mf">1.2</span><span class="p">)</span>

    <span class="n">tol</span> <span class="o">=</span> <span class="mf">1E-12</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]:</span>
        <span class="k">print</span> <span class="n">u_hand</span><span class="p">[</span><span class="n">i</span><span class="p">,:]</span>
        <span class="k">print</span> <span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="p">,:]</span>
        <span class="n">diff</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">u_hand</span><span class="p">[</span><span class="n">i</span><span class="p">,:]</span> <span class="o">-</span> <span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="p">,:])</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
        <span class="k">assert</span> <span class="n">diff</span> <span class="o">&lt;</span> <span class="n">tol</span><span class="p">,</span> <span class="s">&#39;diff=</span><span class="si">%.16g</span><span class="s">&#39;</span> <span class="o">%</span> <span class="n">diff</span>
        <span class="k">print</span> <span class="s">&#39;diff=</span><span class="si">%g</span><span class="s"> at t=</span><span class="si">%g</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">diff</span><span class="p">,</span> <span class="n">t</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>

<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">test_rod_diffusion_hand</span><span class="p">()</span>
</pre></div>
</div>
<p>Filename: <code class="docutils literal"><span class="pre">test_rod_hand_calculations.py</span></code>.</p>
</div>
<div class="section" id="exercise-64-compute-temperature-variations-in-the-ground">
<span id="sec-pde-diff1d-exer-groundtemp"></span><h3>Exercise 64: Compute temperature variations in the ground<a class="headerlink" href="#exercise-64-compute-temperature-variations-in-the-ground" title="Permalink to this headline">¶</a></h3>
<p>The surface temperature at the ground shows daily and seasonal oscillations.
When the temperature rises at the surface, heat is propagated into
the ground, and the coefficient <span class="math">\(\beta\)</span> in the diffusion equation determines
how fast this propagation is. It takes some time before the temperature
rises down in the ground. At the surface, the temperature has then fallen.
We are interested in how the temperature varies down in the ground because
of temperature oscillations on the surface.</p>
<p>Assuming homogeneous horizontal properties of the ground, at least locally,
and no variations of the temperature at the surface at a fixed point of time,
we can neglect the horizontal variations of the temperature.
Then a one-dimensional diffusion equation governs the heat
propagation along a vertical axis called <span class="math">\(x\)</span>. The surface corresponds to
<span class="math">\(x=0\)</span> and the <span class="math">\(x\)</span> axis point downwards into the ground.
There is no source term in the equation (actually, if rocks in
the ground are radioactive, they emit heat and that can be modeled by
a source term, but this effect is neglected here).</p>
<p>At some depth <span class="math">\(x=L\)</span>
we assume that the heat changes in <span class="math">\(x\)</span> vanish, so <span class="math">\(\partial u/\partial x=0\)</span>
is an appropriate boundary condition at <span class="math">\(x=L\)</span>.
We assume a simple sinusoidal temperature variation at the surface:</p>
<div class="math">
\[u(0,t) = T_0 + T_a\sin\left(\frac{2\pi}{P}t\right),\]</div>
<p>where <span class="math">\(P\)</span> is the period, taken here as 24 hours (<span class="math">\(24\cdot 60\cdot 60\)</span> s).
The <span class="math">\(\beta\)</span> coefficient may be set to <span class="math">\(10^{-6}\hbox{ m}^2/\hbox{s}\)</span>.
Time is then measured in seconds. Set appropriate values for <span class="math">\(T_0\)</span> ad <span class="math">\(T_a\)</span>.</p>
<p><strong>a)</strong>
Show that the present problem has an analytical solution of the form</p>
<div class="math">
\[u(x,t) = A + Be^{-rx}\sin(\omega t - rx),\]</div>
<p>for appropriate values of <span class="math">\(A\)</span>, <span class="math">\(B\)</span>, <span class="math">\(r\)</span>, and <span class="math">\(\omega\)</span>.</p>
<p><strong>Solution.</strong>
Any function that is supposed to be a solution, must fit the equation, boundary
conditions and initial conditions, so we go ahead and check this.</p>
<p>From before, we have the temperature at the surface as a given sine function, i.e.
using <span class="math">\(x = 0\)</span> in the suggested (or given) solution should make it equal to the temperature function previously
given for the surface. This implies immediately that <span class="math">\(A = T_0\)</span>, <span class="math">\(B = T_a\)</span> and <span class="math">\(\omega = \frac{2\pi}{P}\)</span>.</p>
<p>At the other boundary, we see that the suggested solution approaches zero when x goes to infinity, which
is consistent with the boundary condition <span class="math">\(\frac{\partial u}{\partial x} = 0\)</span>.</p>
<p>With <span class="math">\(t = 0\)</span>, we find that</p>
<div class="math">
\[u(x,0) = A + B e^{-rx}\sin\left(-rx\right),\]</div>
<p>So, by making this our initial temperature distribution, also the initial conditions will be consistent
with the suggested solution.</p>
<p>Finally, the suggested solution must be consistent with <span class="math">\(\frac{\partial u}{\partial t} = \beta\frac{\partial^2 u}{\partial x^2}\)</span>, so
we perform the required partial derivatives to check.</p>
<div class="math">
\[\frac{\partial u}{\partial t} = \omega B e^{-rx}\cos\left(\omega t -rx\right),\]</div>
<div class="math">
\[\frac{\partial u}{\partial x} = -r B e^{-rx}\sin\left(\omega t -rx\right) -r B e^{-rx}\cos\left(\omega t -rx\right)  ,\]</div>
<div class="math">
\[\frac{\partial^2 u}{\partial x^2} =
-r\left[-r B e^{-rx}\sin\left(\omega t - rx\right) -
r B e^{-rx}\cos\left(\omega t - rx\right)\right] -
r\left[-r B e^{-rx}\cos\left(\omega t - rx\right) +
r B e^{-rx}\sin\left(\omega t -rx\right)\right]  ,\]</div>
<p>which reduces to</p>
<div class="math">
\[\frac{\partial^2 u}{\partial x^2} =
2 r^2 B e^{-rx}\cos\left(\omega t - rx\right)   ,\]</div>
<p>This means that we can decide the final parameter <span class="math">\(r\)</span> as well, since if only <span class="math">\(r = \sqrt{\frac{\omega}{2\beta}}\)</span>, we have that <span class="math">\(\frac{\partial u}{\partial t} = \beta\frac{\partial^2 u}{\partial x^2}\)</span>.</p>
<p><strong>b)</strong>
Solve this heat propagation problem numerically for some days and animate the
temperature. You may use the Forward Euler method in time. Plot both
the numerical and analytical solution. As initial condition for
the numerical solution, use the exact solution during program development,
and when the curves coincide in the animation for all times, your
implementation works, and you can then switch to a constant
initial condition: <span class="math">\(u(x,0)=T_0\)</span>.
For this latter initial condition,
how many periods of oscillations are necessary before there is a good
(visual) match between the numerical and exact solution (despite
differences at <span class="math">\(t=0\)</span>)?</p>
<p><strong>Solution.</strong>
Code:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="sd">&quot;&quot;&quot;Temperature vertically down in the ground (with Forward Euler).&quot;&quot;&quot;</span>

<span class="kn">from</span> <span class="nn">numpy</span> <span class="kn">import</span> <span class="n">linspace</span><span class="p">,</span> <span class="n">zeros</span><span class="p">,</span> <span class="n">linspace</span><span class="p">,</span> <span class="n">exp</span><span class="p">,</span> <span class="n">sin</span><span class="p">,</span> <span class="n">cos</span><span class="p">,</span> <span class="n">pi</span><span class="p">,</span> <span class="n">sqrt</span>
<span class="kn">import</span> <span class="nn">time</span>

<span class="k">def</span> <span class="nf">U</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">t</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; True temperature &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">A</span> <span class="o">+</span> <span class="n">B</span><span class="o">*</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">r</span><span class="o">*</span><span class="n">x</span><span class="p">)</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="n">omega</span><span class="o">*</span><span class="n">t</span> <span class="o">-</span> <span class="n">r</span><span class="o">*</span><span class="n">x</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">rhs</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">t</span><span class="p">):</span>
    <span class="n">N</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">u</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="n">rhs</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">(</span><span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">rhs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">dsdt</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">N</span><span class="p">):</span>
        <span class="n">rhs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">beta</span><span class="o">/</span><span class="n">dx</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">+</span> \
                 <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">t</span><span class="p">)</span>
    <span class="n">i</span> <span class="o">=</span> <span class="n">N</span>
    <span class="n">rhs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">beta</span><span class="o">/</span><span class="n">dx</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">+</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">N</span><span class="p">],</span> <span class="n">t</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">rhs</span>

<span class="k">def</span> <span class="nf">dudx</span><span class="p">(</span><span class="n">t</span><span class="p">):</span>
    <span class="k">return</span> <span class="mi">0</span>

<span class="k">def</span> <span class="nf">s</span><span class="p">(</span><span class="n">t</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">T0</span> <span class="o">+</span> <span class="n">Ta</span><span class="o">*</span><span class="n">sin</span><span class="p">((</span><span class="mi">2</span><span class="o">*</span><span class="n">pi</span><span class="o">/</span><span class="n">P</span><span class="p">)</span><span class="o">*</span><span class="n">t</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">dsdt</span><span class="p">(</span><span class="n">t</span><span class="p">):</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">Ta</span><span class="o">*</span><span class="mi">2</span><span class="o">*</span><span class="n">pi</span><span class="o">/</span><span class="n">P</span><span class="p">)</span><span class="o">*</span><span class="n">cos</span><span class="p">((</span><span class="mi">2</span><span class="o">*</span><span class="n">pi</span><span class="o">/</span><span class="n">P</span><span class="p">)</span><span class="o">*</span><span class="n">t</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">t</span><span class="p">):</span>
    <span class="k">return</span> <span class="mi">0</span>

<span class="k">def</span> <span class="nf">I</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Initial temp distribution&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">A</span> <span class="o">+</span> <span class="n">B</span><span class="o">*</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">r</span><span class="o">*</span><span class="n">x</span><span class="p">)</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="o">-</span><span class="n">r</span><span class="o">*</span><span class="n">x</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">I</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Initial temp distribution.&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">A</span>

<span class="n">beta</span> <span class="o">=</span> <span class="mf">1E-6</span>
<span class="n">T0</span> <span class="o">=</span> <span class="mi">283</span>        <span class="c"># just some choice</span>
<span class="n">Ta</span> <span class="o">=</span> <span class="mi">20</span>         <span class="c"># amplitude of temp osc</span>
<span class="n">P</span> <span class="o">=</span> <span class="mi">24</span><span class="o">*</span><span class="mi">60</span><span class="o">*</span><span class="mi">60</span>    <span class="c"># period, 24 hours</span>
<span class="n">A</span> <span class="o">=</span> <span class="n">T0</span>
<span class="n">B</span> <span class="o">=</span> <span class="n">Ta</span>
<span class="n">omega</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">pi</span><span class="o">/</span><span class="n">P</span>
<span class="n">r</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">omega</span><span class="o">/</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">beta</span><span class="p">))</span>
<span class="n">L</span> <span class="o">=</span> <span class="mi">2</span>           <span class="c"># depth vertically down in the ground</span>
<span class="n">N</span> <span class="o">=</span> <span class="mi">100</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
<span class="n">dx</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="n">u</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">(</span><span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>

<span class="n">U_0</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">(</span><span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
<span class="n">U_0</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">s</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="n">U_0</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">=</span> <span class="n">I</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>

<span class="n">dt</span> <span class="o">=</span> <span class="n">dx</span><span class="o">**</span><span class="mi">2</span><span class="o">/</span><span class="nb">float</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">beta</span><span class="p">)</span>
<span class="k">print</span> <span class="s">&#39;stability limit:&#39;</span><span class="p">,</span> <span class="n">dt</span>

<span class="n">t0</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">clock</span><span class="p">()</span>
<span class="kn">from</span> <span class="nn">ode_system_FE</span> <span class="kn">import</span> <span class="n">ode_FE</span>
<span class="n">T</span><span class="o">=</span><span class="p">(</span><span class="mi">24</span><span class="o">*</span><span class="mi">60</span><span class="o">*</span><span class="mi">60</span><span class="p">)</span><span class="o">*</span><span class="mi">6</span>                  <span class="c"># simulate 6 days</span>
<span class="n">u</span><span class="p">,</span> <span class="n">t</span> <span class="o">=</span> <span class="n">ode_FE</span><span class="p">(</span><span class="n">rhs</span><span class="p">,</span> <span class="n">U_0</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">T</span><span class="p">)</span>
<span class="n">t1</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">clock</span><span class="p">()</span>
<span class="k">print</span> <span class="s">&#39;CPU time: </span><span class="si">%.1f</span><span class="s">s&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">t1</span> <span class="o">-</span> <span class="n">t0</span><span class="p">)</span>


<span class="c"># Make movie</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="n">os</span><span class="o">.</span><span class="n">system</span><span class="p">(</span><span class="s">&#39;rm tmp_*.png&#39;</span><span class="p">)</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="kn">as</span> <span class="nn">plt</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ion</span><span class="p">()</span>
<span class="n">lines</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">u</span><span class="p">[</span><span class="mi">0</span><span class="p">,:],</span> <span class="n">x</span><span class="p">,</span> <span class="n">U</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
<span class="n">plt</span><span class="o">.</span><span class="n">axis</span><span class="p">([</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">x</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="mi">283</span><span class="o">-</span><span class="mi">30</span><span class="p">,</span> <span class="mi">283</span><span class="o">+</span><span class="mi">30</span><span class="p">])</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s">&#39;x&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s">&#39;u(x,t) and U(x,t)&#39;</span><span class="p">)</span>
<span class="n">counter</span> <span class="o">=</span> <span class="mi">0</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">u</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
    <span class="k">print</span> <span class="n">t</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
    <span class="n">lines</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_ydata</span><span class="p">(</span><span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="p">,:])</span>
    <span class="n">lines</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_ydata</span><span class="p">(</span><span class="n">U</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">t</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">([</span><span class="s">&#39;t=</span><span class="si">%.3f</span><span class="s">&#39;</span> <span class="o">%</span> <span class="n">t</span><span class="p">[</span><span class="n">i</span><span class="p">]])</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">draw</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">i</span> <span class="o">%</span> <span class="mi">10</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span> <span class="c"># plot every x steps</span>
        <span class="c">#plt.savefig(&#39;tmp_%04d.png&#39; % counter)</span>
        <span class="n">counter</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="c">#time.sleep(0.2)</span>
</pre></div>
</div>
<p>Filename: <code class="docutils literal"><span class="pre">ground_temp.py</span></code>.</p>
</div>
<div class="section" id="exercise-65-compare-implicit-methods">
<span id="sec-pde-diff1d-exer-compare-implicit"></span><h3>Exercise 65: Compare implicit methods<a class="headerlink" href="#exercise-65-compare-implicit-methods" title="Permalink to this headline">¶</a></h3>
<p>An equally stable, but more accurate method than the Backward Euler scheme,
is the
so-called 2-step backward scheme, which for an ODE <span class="math">\(u'=f(u,t)\)</span> can
be expressed by</p>
<div class="math">
\[\frac{3u^{n+1} - 4u^{n} + u^{n-1}}{2\Delta t} = f(u^{n+1},t_{n+1})
\thinspace .\]</div>
<p>The Odespy package offers this method as <code class="docutils literal"><span class="pre">odespy.Backward2Step</span></code>.
The purpose of this exercise is to compare three methods and animate
the three solutions:</p>
<ol class="arabic simple">
<li>The Backward Euler method with <span class="math">\(\Delta t =0.001\)</span></li>
<li>The backward 2-step method with <span class="math">\(\Delta t =0.001\)</span></li>
<li>The backward 2-step method with <span class="math">\(\Delta t =0.01\)</span></li>
</ol>
<p>Choose the model problem from the section <a class="reference internal" href="#sec-pde-diff1d-rod"><span class="std std-ref">Application: heat conduction in a rod</span></a>.</p>
<p><strong>Solution.</strong>
Here is the code:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Temperature evolution in a rod,</span>
<span class="sd">computed by a BackwardEuler method and a 2-step</span>
<span class="sd">backward method.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">from</span> <span class="nn">numpy</span> <span class="kn">import</span> <span class="n">linspace</span><span class="p">,</span> <span class="n">zeros</span><span class="p">,</span> <span class="n">linspace</span>

<span class="k">def</span> <span class="nf">rhs</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">t</span><span class="p">):</span>
    <span class="n">N</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">u</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="n">rhs</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">(</span><span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">rhs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">dsdt</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">N</span><span class="p">):</span>
        <span class="n">rhs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">beta</span><span class="o">/</span><span class="n">dx</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">+</span> \
                 <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">t</span><span class="p">)</span>
    <span class="n">rhs</span><span class="p">[</span><span class="n">N</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">beta</span><span class="o">/</span><span class="n">dx</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">u</span><span class="p">[</span><span class="n">N</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">dx</span><span class="o">*</span><span class="n">dudx</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="o">-</span>
                           <span class="mi">2</span><span class="o">*</span><span class="n">u</span><span class="p">[</span><span class="n">N</span><span class="p">])</span> <span class="o">+</span> <span class="n">g</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">N</span><span class="p">],</span> <span class="n">t</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">rhs</span>

<span class="k">def</span> <span class="nf">K</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">t</span><span class="p">):</span>
    <span class="n">N</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">u</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="n">K</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">((</span><span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>
    <span class="n">K</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">N</span><span class="p">):</span>
        <span class="n">K</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">beta</span><span class="o">/</span><span class="n">dx</span><span class="o">**</span><span class="mi">2</span>
        <span class="n">K</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">2</span><span class="o">*</span><span class="n">beta</span><span class="o">/</span><span class="n">dx</span><span class="o">**</span><span class="mi">2</span>
        <span class="n">K</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">beta</span><span class="o">/</span><span class="n">dx</span><span class="o">**</span><span class="mi">2</span>
    <span class="n">K</span><span class="p">[</span><span class="n">N</span><span class="p">,</span><span class="n">N</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">beta</span><span class="o">/</span><span class="n">dx</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="mi">2</span>
    <span class="n">K</span><span class="p">[</span><span class="n">N</span><span class="p">,</span><span class="n">N</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">beta</span><span class="o">/</span><span class="n">dx</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">K</span>

<span class="k">def</span> <span class="nf">dudx</span><span class="p">(</span><span class="n">t</span><span class="p">):</span>
    <span class="k">return</span> <span class="mi">0</span>

<span class="k">def</span> <span class="nf">s</span><span class="p">(</span><span class="n">t</span><span class="p">):</span>
    <span class="k">return</span> <span class="mi">323</span>

<span class="k">def</span> <span class="nf">dsdt</span><span class="p">(</span><span class="n">t</span><span class="p">):</span>
    <span class="k">return</span> <span class="mi">0</span>

<span class="k">def</span> <span class="nf">g</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">t</span><span class="p">):</span>
    <span class="k">return</span> <span class="mi">0</span>


<span class="n">L</span> <span class="o">=</span> <span class="mf">0.5</span>
<span class="n">beta</span> <span class="o">=</span> <span class="mf">8.2E-5</span>
<span class="n">N</span> <span class="o">=</span> <span class="mi">40</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
<span class="n">dx</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="n">u</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">(</span><span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>

<span class="n">U_0</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">(</span><span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
<span class="n">U_0</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">s</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="n">U_0</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">=</span> <span class="mi">283</span>
<span class="n">dt</span> <span class="o">=</span> <span class="n">dx</span><span class="o">**</span><span class="mi">2</span><span class="o">/</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">beta</span><span class="p">)</span>
<span class="k">print</span> <span class="s">&#39;stability limit:&#39;</span><span class="p">,</span> <span class="n">dt</span>
<span class="n">dt</span> <span class="o">=</span> <span class="mi">12</span>

<span class="kn">import</span> <span class="nn">odespy</span>
<span class="n">solver0</span> <span class="o">=</span> <span class="n">odespy</span><span class="o">.</span><span class="n">BackwardEuler</span><span class="p">(</span><span class="n">rhs</span><span class="p">,</span> <span class="n">f_is_linear</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">jac</span><span class="o">=</span><span class="n">K</span><span class="p">)</span>
<span class="n">solver1</span> <span class="o">=</span> <span class="n">odespy</span><span class="o">.</span><span class="n">Backward2Step</span><span class="p">(</span><span class="n">rhs</span><span class="p">,</span> <span class="n">f_is_linear</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">jac</span><span class="o">=</span><span class="n">K</span><span class="p">)</span>
<span class="n">solver2</span> <span class="o">=</span> <span class="n">odespy</span><span class="o">.</span><span class="n">Backward2Step</span><span class="p">(</span><span class="n">rhs</span><span class="p">,</span> <span class="n">f_is_linear</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">jac</span><span class="o">=</span><span class="n">K</span><span class="p">)</span>
<span class="n">solver0</span><span class="o">.</span><span class="n">set_initial_condition</span><span class="p">(</span><span class="n">U_0</span><span class="p">)</span>
<span class="n">solver1</span><span class="o">.</span><span class="n">set_initial_condition</span><span class="p">(</span><span class="n">U_0</span><span class="p">)</span>
<span class="n">solver2</span><span class="o">.</span><span class="n">set_initial_condition</span><span class="p">(</span><span class="n">U_0</span><span class="p">)</span>
<span class="n">T</span> <span class="o">=</span> <span class="mi">1</span><span class="o">*</span><span class="mi">60</span><span class="o">*</span><span class="mi">60</span>
<span class="n">N_t</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">T</span><span class="o">/</span><span class="nb">float</span><span class="p">(</span><span class="n">dt</span><span class="p">)))</span>
<span class="n">time_points</span> <span class="o">=</span> <span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">N_t</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
<span class="n">u0</span><span class="p">,</span> <span class="n">t0</span> <span class="o">=</span> <span class="n">solver0</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">time_points</span><span class="p">)</span>
<span class="n">u1</span><span class="p">,</span> <span class="n">t1</span> <span class="o">=</span> <span class="n">solver1</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">time_points</span><span class="p">)</span>
<span class="c"># Solve with larger time step in the 2-step method</span>
<span class="n">factor</span> <span class="o">=</span> <span class="mi">10</span>
<span class="n">dt</span> <span class="o">=</span> <span class="n">factor</span><span class="o">*</span><span class="n">dt</span>
<span class="n">N_t</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">T</span><span class="o">/</span><span class="nb">float</span><span class="p">(</span><span class="n">dt</span><span class="p">)))</span>
<span class="n">time_points</span> <span class="o">=</span> <span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">N_t</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
<span class="n">u2</span><span class="p">,</span> <span class="n">t2</span> <span class="o">=</span> <span class="n">solver2</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">time_points</span><span class="p">)</span>

<span class="c"># Make movie</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="n">os</span><span class="o">.</span><span class="n">system</span><span class="p">(</span><span class="s">&#39;rm tmp_*.png&#39;</span><span class="p">)</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="kn">as</span> <span class="nn">plt</span>
<span class="kn">import</span> <span class="nn">time</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ion</span><span class="p">()</span>
<span class="n">lines</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">u0</span><span class="p">[</span><span class="mi">0</span><span class="p">,:],</span> <span class="n">x</span><span class="p">,</span> <span class="n">u1</span><span class="p">[</span><span class="mi">0</span><span class="p">,:],</span> <span class="n">x</span><span class="p">,</span> <span class="n">u2</span><span class="p">[</span><span class="mi">0</span><span class="p">,:])</span>
<span class="n">plt</span><span class="o">.</span><span class="n">axis</span><span class="p">([</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">x</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="mi">273</span><span class="p">,</span> <span class="n">s</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">+</span><span class="mi">10</span><span class="p">])</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s">&#39;x&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s">&#39;u(x,t)&#39;</span><span class="p">)</span>
<span class="n">counter</span> <span class="o">=</span> <span class="mi">0</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">t2</span><span class="p">)):</span>
    <span class="k">print</span> <span class="n">t2</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
    <span class="n">lines</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">set_ydata</span><span class="p">(</span><span class="n">u2</span><span class="p">[</span><span class="n">i</span><span class="p">,:])</span>
    <span class="n">lines</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_ydata</span><span class="p">(</span><span class="n">u0</span><span class="p">[</span><span class="n">factor</span><span class="o">*</span><span class="n">i</span><span class="p">,:])</span>
    <span class="n">lines</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_ydata</span><span class="p">(</span><span class="n">u1</span><span class="p">[</span><span class="n">factor</span><span class="o">*</span><span class="n">i</span><span class="p">,:])</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s">&#39;t=</span><span class="si">%.3f</span><span class="s">&#39;</span> <span class="o">%</span> <span class="n">t2</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">([</span><span class="s">&#39;BE&#39;</span><span class="p">,</span> <span class="s">&#39;B2Step&#39;</span><span class="p">,</span> <span class="s">&#39;B2Step 2*dt&#39;</span><span class="p">])</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">draw</span><span class="p">()</span>
    <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mf">0.5</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="s">&#39;tmp_</span><span class="si">%04d</span><span class="s">.png&#39;</span> <span class="o">%</span> <span class="n">counter</span><span class="p">)</span>
    <span class="n">counter</span> <span class="o">+=</span> <span class="mi">1</span>
</pre></div>
</div>
<p>Filename: <code class="docutils literal"><span class="pre">rod_BE_vs_B2Step.py</span></code>.</p>
</div>
<div class="section" id="exercise-66-explore-adaptive-and-implicit-methods">
<span id="sec-pde-diff1d-exer-groundtemp-adapt"></span><h3>Exercise 66: Explore adaptive and implicit methods<a class="headerlink" href="#exercise-66-explore-adaptive-and-implicit-methods" title="Permalink to this headline">¶</a></h3>
<p>We consider the same problem as in <a class="reference internal" href="#sec-pde-diff1d-exer-groundtemp"><span class="std std-ref">Exercise 64: Compute temperature variations in the ground</span></a>.
Now we want to explore the use of adaptive and implicit methods from Odespy
to see if they are more efficient than the Forward Euler method.
Assume that you want the accuracy provided by the Forward Euler method with
its maximum <span class="math">\(\Delta t\)</span> value. Since there exists an analytical solution,
you can compute an error measure that summarizes the error in space and
time over the whole simulation:</p>
<div class="math">
\[E = \sqrt{\Delta x\Delta t\sum_{i}\sum_n (U_i^n - u_i^n)^2}\thinspace .\]</div>
<p>Here, <span class="math">\(U_i^n\)</span> is the exact solution.
Use the Odespy package to run the following implicit and adaptive
solvers:</p>
<ol class="arabic simple">
<li><code class="docutils literal"><span class="pre">BackwardEuler</span></code></li>
<li><code class="docutils literal"><span class="pre">Backward2Step</span></code></li>
<li><code class="docutils literal"><span class="pre">RKFehlberg</span></code></li>
</ol>
<p>Experiment to see if you can use larger time steps than what is required
by the Forward Euler method and get solutions with the same order of accuracy.</p>
<span class="target" id="index-22"></span><p><strong>Hint.</strong>
To avoid oscillations in the solutions when using the RKFehlberg method,
the <code class="docutils literal"><span class="pre">rtol</span></code> and <code class="docutils literal"><span class="pre">atol</span></code> parameters to <code class="docutils literal"><span class="pre">RKFFehlberg</span></code> must be set no
larger than 0.001 and 0.0001, respectively.
You can print out <code class="docutils literal"><span class="pre">solver_RKF.t_all</span></code> to see all the time steps used
by the RKFehlberg solver (if <code class="docutils literal"><span class="pre">solver</span></code> is the <code class="docutils literal"><span class="pre">RKFehlberg</span></code> object).
You can then compare the number of time steps with what is required
by the other methods.</p>
<p><strong>Solution.</strong>
Code:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Temperature vertically down in the ground with Forward Euler,</span>
<span class="sd">Backward Euler, backward 2-step and RKFehlberg .</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">from</span> <span class="nn">numpy</span> <span class="kn">import</span> <span class="n">linspace</span><span class="p">,</span> <span class="n">zeros</span><span class="p">,</span> <span class="n">linspace</span><span class="p">,</span> <span class="n">sin</span><span class="p">,</span> <span class="n">cos</span><span class="p">,</span> <span class="n">pi</span><span class="p">,</span> \
                  <span class="n">exp</span><span class="p">,</span> <span class="n">sqrt</span>
<span class="kn">import</span> <span class="nn">time</span>

<span class="k">def</span> <span class="nf">rhs</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">t</span><span class="p">):</span>
    <span class="n">N</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">u</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="n">rhs</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">(</span><span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">rhs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">dsdt</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">N</span><span class="p">):</span>
        <span class="n">rhs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">beta</span><span class="o">/</span><span class="n">dx</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">+</span> \
                 <span class="n">g</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">t</span><span class="p">)</span>
    <span class="n">i</span> <span class="o">=</span> <span class="n">N</span>
    <span class="n">rhs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">beta</span><span class="o">/</span><span class="n">dx</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">+</span> <span class="n">g</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">N</span><span class="p">],</span> <span class="n">t</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">rhs</span>

<span class="k">def</span> <span class="nf">K</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">t</span><span class="p">):</span>
    <span class="n">N</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">u</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="n">K</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">((</span><span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>
    <span class="n">K</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">N</span><span class="p">):</span>
        <span class="n">K</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">beta</span><span class="o">/</span><span class="n">dx</span><span class="o">**</span><span class="mi">2</span>
        <span class="n">K</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span>   <span class="o">=</span> <span class="o">-</span><span class="mi">2</span><span class="o">*</span><span class="n">beta</span><span class="o">/</span><span class="n">dx</span><span class="o">**</span><span class="mi">2</span>
        <span class="n">K</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">beta</span><span class="o">/</span><span class="n">dx</span><span class="o">**</span><span class="mi">2</span>
    <span class="n">K</span><span class="p">[</span><span class="n">N</span><span class="p">,</span> <span class="n">N</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">beta</span><span class="o">/</span><span class="n">dx</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="mi">2</span>
    <span class="n">K</span><span class="p">[</span><span class="n">N</span><span class="p">,</span> <span class="n">N</span><span class="p">]</span>   <span class="o">=</span> <span class="p">(</span><span class="n">beta</span><span class="o">/</span><span class="n">dx</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">K</span>

<span class="k">def</span> <span class="nf">dudx</span><span class="p">(</span><span class="n">t</span><span class="p">):</span>
    <span class="k">return</span> <span class="mi">0</span>

<span class="k">def</span> <span class="nf">s</span><span class="p">(</span><span class="n">t</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">T0</span> <span class="o">+</span> <span class="n">Ta</span><span class="o">*</span><span class="n">sin</span><span class="p">((</span><span class="mi">2</span><span class="o">*</span><span class="n">pi</span><span class="o">/</span><span class="n">P</span><span class="p">)</span><span class="o">*</span><span class="n">t</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">dsdt</span><span class="p">(</span><span class="n">t</span><span class="p">):</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">Ta</span><span class="o">*</span><span class="mi">2</span><span class="o">*</span><span class="n">pi</span><span class="o">/</span><span class="n">P</span><span class="p">)</span><span class="o">*</span><span class="n">cos</span><span class="p">((</span><span class="mi">2</span><span class="o">*</span><span class="n">pi</span><span class="o">/</span><span class="n">P</span><span class="p">)</span><span class="o">*</span><span class="n">t</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">g</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">t</span><span class="p">):</span>
    <span class="k">return</span> <span class="mi">0</span>

<span class="k">def</span> <span class="nf">U</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">t</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; True temperature.&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">A</span> <span class="o">+</span> <span class="n">B</span><span class="o">*</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">r</span><span class="o">*</span><span class="n">x</span><span class="p">)</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="n">omega</span><span class="o">*</span><span class="n">t</span> <span class="o">-</span> <span class="n">r</span><span class="o">*</span><span class="n">x</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">I</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Initial temp distribution.&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">U</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

<span class="n">T0</span> <span class="o">=</span> <span class="mi">283</span>        <span class="c"># just some choice</span>
<span class="n">Ta</span> <span class="o">=</span> <span class="mi">20</span>         <span class="c"># amplitude of temp osc</span>
<span class="n">P</span> <span class="o">=</span> <span class="mi">24</span><span class="o">*</span><span class="mi">60</span><span class="o">*</span><span class="mi">60</span>    <span class="c"># period, 24 hours</span>
<span class="n">A</span> <span class="o">=</span> <span class="n">T0</span>
<span class="n">B</span> <span class="o">=</span> <span class="n">Ta</span>
<span class="n">omega</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">pi</span><span class="o">/</span><span class="n">P</span>
<span class="n">beta</span> <span class="o">=</span> <span class="mf">1E-6</span>
<span class="n">r</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">omega</span><span class="o">/</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">beta</span><span class="p">))</span>
<span class="n">L</span> <span class="o">=</span> <span class="mi">2</span>           <span class="c"># depth vertically down in the ground</span>
<span class="n">N</span> <span class="o">=</span> <span class="mi">100</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
<span class="n">dx</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="n">u</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">(</span><span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>

<span class="n">U_0</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">(</span><span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
<span class="n">U_0</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">s</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="n">U_0</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">=</span> <span class="n">I</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
<span class="n">FE_stability_limit</span> <span class="o">=</span> <span class="n">dx</span><span class="o">**</span><span class="mi">2</span><span class="o">/</span><span class="nb">float</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">beta</span><span class="p">)</span>
<span class="n">dt</span> <span class="o">=</span> <span class="mi">1</span><span class="o">*</span><span class="n">FE_stability_limit</span>
<span class="k">print</span> <span class="s">&#39;dt/(FE stability limit): </span><span class="si">%.1f</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">dt</span><span class="o">/</span><span class="n">FE_stability_limit</span><span class="p">)</span>
<span class="n">T</span><span class="o">=</span><span class="p">(</span><span class="mi">24</span><span class="o">*</span><span class="mi">60</span><span class="o">*</span><span class="mi">60</span><span class="p">)</span><span class="o">*</span><span class="mi">6</span>   <span class="c"># simulate 6 days</span>

<span class="kn">import</span> <span class="nn">odespy</span>
<span class="n">solver1</span> <span class="o">=</span> <span class="n">odespy</span><span class="o">.</span><span class="n">BackwardEuler</span><span class="p">(</span><span class="n">rhs</span><span class="p">,</span> <span class="n">f_is_linear</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">jac</span><span class="o">=</span><span class="n">K</span><span class="p">)</span>
<span class="n">solver2</span> <span class="o">=</span> <span class="n">odespy</span><span class="o">.</span><span class="n">Backward2Step</span><span class="p">(</span><span class="n">rhs</span><span class="p">,</span> <span class="n">f_is_linear</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">jac</span><span class="o">=</span><span class="n">K</span><span class="p">)</span>
<span class="n">solver3</span> <span class="o">=</span> <span class="n">odespy</span><span class="o">.</span><span class="n">RKFehlberg</span><span class="p">(</span><span class="n">rhs</span><span class="p">,</span> <span class="n">rtol</span><span class="o">=</span><span class="mf">0.001</span><span class="p">,</span> <span class="n">atol</span><span class="o">=</span><span class="mf">0.0001</span><span class="p">)</span>
<span class="n">solver1</span><span class="o">.</span><span class="n">set_initial_condition</span><span class="p">(</span><span class="n">U_0</span><span class="p">)</span>
<span class="n">solver2</span><span class="o">.</span><span class="n">set_initial_condition</span><span class="p">(</span><span class="n">U_0</span><span class="p">)</span>
<span class="n">solver3</span><span class="o">.</span><span class="n">set_initial_condition</span><span class="p">(</span><span class="n">U_0</span><span class="p">)</span>
<span class="n">N_t</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">T</span><span class="o">/</span><span class="nb">float</span><span class="p">(</span><span class="n">dt</span><span class="p">)))</span>
<span class="n">time_points</span> <span class="o">=</span> <span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">N_t</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
<span class="n">u1</span><span class="p">,</span> <span class="n">t1</span> <span class="o">=</span> <span class="n">solver1</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">time_points</span><span class="p">)</span>
<span class="n">u2</span><span class="p">,</span> <span class="n">t2</span> <span class="o">=</span> <span class="n">solver2</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">time_points</span><span class="p">)</span>
<span class="n">u3</span><span class="p">,</span> <span class="n">t3</span> <span class="o">=</span> <span class="n">solver3</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">time_points</span><span class="p">)</span>
<span class="k">print</span> <span class="s">&#39;N_t=</span><span class="si">%d</span><span class="s">, RKF N_t:</span><span class="si">%d</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">N_t</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">solver3</span><span class="o">.</span><span class="n">t_all</span><span class="p">))</span>
<span class="k">print</span> <span class="s">&#39;Average dt for RKF: </span><span class="si">%.2f</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">T</span><span class="o">/</span><span class="nb">float</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">solver3</span><span class="o">.</span><span class="n">t_all</span><span class="p">)))</span>

<span class="k">if</span> <span class="n">dt</span> <span class="o">&lt;=</span> <span class="n">FE_stability_limit</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">ode_system_FE</span> <span class="kn">import</span> <span class="n">ode_FE</span>
    <span class="n">u4</span><span class="p">,</span> <span class="n">t4</span> <span class="o">=</span> <span class="n">ode_FE</span><span class="p">(</span><span class="n">rhs</span><span class="p">,</span> <span class="n">U_0</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">T</span><span class="p">)</span>

<span class="c"># Compute error with each method</span>
<span class="n">E1</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">E2</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">E3</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">E_FE</span> <span class="o">=</span> <span class="mi">0</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)):</span>
    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">time_points</span><span class="p">)):</span>
        <span class="k">if</span> <span class="n">dt</span> <span class="o">&lt;=</span> <span class="n">FE_stability_limit</span><span class="p">:</span>
            <span class="n">E_FE</span> <span class="o">+=</span> <span class="p">(</span><span class="n">U</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">time_points</span><span class="p">[</span><span class="n">n</span><span class="p">])</span> <span class="o">-</span> <span class="n">u4</span><span class="p">[</span><span class="n">n</span><span class="p">,</span><span class="n">i</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span>
        <span class="n">E1</span> <span class="o">+=</span> <span class="p">(</span><span class="n">U</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">time_points</span><span class="p">[</span><span class="n">n</span><span class="p">])</span> <span class="o">-</span> <span class="n">u1</span><span class="p">[</span><span class="n">n</span><span class="p">,</span><span class="n">i</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span>
        <span class="n">E2</span> <span class="o">+=</span> <span class="p">(</span><span class="n">U</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">time_points</span><span class="p">[</span><span class="n">n</span><span class="p">])</span> <span class="o">-</span> <span class="n">u2</span><span class="p">[</span><span class="n">n</span><span class="p">,</span><span class="n">i</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span>
        <span class="n">E3</span> <span class="o">+=</span> <span class="p">(</span><span class="n">U</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">time_points</span><span class="p">[</span><span class="n">n</span><span class="p">])</span> <span class="o">-</span> <span class="n">u3</span><span class="p">[</span><span class="n">n</span><span class="p">,</span><span class="n">i</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span>
<span class="k">if</span> <span class="n">dt</span> <span class="o">&lt;=</span> <span class="n">FE_stability_limit</span><span class="p">:</span>
    <span class="n">E_FE</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">dx</span><span class="o">*</span><span class="n">dt</span><span class="o">*</span><span class="n">E_FE</span><span class="p">)</span>
<span class="n">E1</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">dx</span><span class="o">*</span><span class="n">dt</span><span class="o">*</span><span class="n">E1</span><span class="p">)</span>
<span class="n">E2</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">dx</span><span class="o">*</span><span class="n">dt</span><span class="o">*</span><span class="n">E2</span><span class="p">)</span>
<span class="n">E3</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">dx</span><span class="o">*</span><span class="n">dt</span><span class="o">*</span><span class="n">E3</span><span class="p">)</span>

<span class="c">#print E0  # gives 31.86 with dt on stability limit</span>
<span class="k">if</span> <span class="n">dt</span> <span class="o">&lt;=</span> <span class="n">FE_stability_limit</span><span class="p">:</span>
    <span class="n">ref_error</span> <span class="o">=</span> <span class="n">E_FE</span>
<span class="k">else</span><span class="p">:</span>
    <span class="n">ref_error</span> <span class="o">=</span> <span class="mf">66.31</span>
<span class="k">print</span>  <span class="s">&#39;ref_error:&#39;</span><span class="p">,</span> <span class="n">ref_error</span>

<span class="k">if</span> <span class="n">E1</span> <span class="o">&gt;</span> <span class="p">(</span><span class="n">ref_error</span><span class="o">*</span><span class="mi">10</span><span class="p">):</span>
    <span class="k">print</span> <span class="s">&#39;ref_error: </span><span class="si">%.2f</span><span class="s"> , dt = </span><span class="si">%.4f</span><span class="s"> at stability lim&#39;</span> <span class="o">%</span> \
                          <span class="p">(</span><span class="n">ref_error</span><span class="p">,</span> <span class="n">FE_stability_limit</span><span class="p">)</span>
    <span class="k">print</span> <span class="s">&#39;E1 (with BE) too large: </span><span class="si">%.2f</span><span class="s">, dt = </span><span class="si">%.4f</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">E1</span><span class="p">,</span> <span class="n">dt</span><span class="p">)</span>
<span class="k">elif</span> <span class="n">E2</span> <span class="o">&gt;</span> <span class="p">(</span><span class="n">ref_error</span><span class="o">*</span><span class="mi">10</span><span class="p">):</span>
    <span class="k">print</span> <span class="s">&#39;ref_error: </span><span class="si">%.2f</span><span class="s"> , dt = </span><span class="si">%.4f</span><span class="s"> at stability lim&#39;</span> <span class="o">%</span> \
                          <span class="p">(</span><span class="n">ref_error</span><span class="p">,</span> <span class="n">FE_stability_limit</span><span class="p">)</span>
    <span class="k">print</span> <span class="s">&#39;E2 (with B2Step) too large: </span><span class="si">%.2f</span><span class="s">, dt = </span><span class="si">%.4f</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">E2</span><span class="p">,</span> <span class="n">dt</span><span class="p">)</span>
<span class="k">elif</span> <span class="n">E3</span> <span class="o">&gt;</span> <span class="p">(</span><span class="n">ref_error</span><span class="o">*</span><span class="mi">10</span><span class="p">):</span>
    <span class="k">print</span> <span class="s">&#39;ref_error: </span><span class="si">%.2f</span><span class="s"> , dt = </span><span class="si">%.4f</span><span class="s"> at stability lim&#39;</span> <span class="o">%</span> \
                          <span class="p">(</span><span class="n">ref_error</span><span class="p">,</span> <span class="n">FE_stability_limit</span><span class="p">)</span>
    <span class="k">print</span> <span class="s">&#39;E3 (with RKF) too large: </span><span class="si">%.2f</span><span class="s">, dt = </span><span class="si">%.4f</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">E3</span><span class="p">,</span> <span class="n">dt</span><span class="p">)</span>

<span class="c"># Make movie</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="n">os</span><span class="o">.</span><span class="n">system</span><span class="p">(</span><span class="s">&#39;rm tmp_*.png&#39;</span><span class="p">)</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="kn">as</span> <span class="nn">plt</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ion</span><span class="p">()</span>
<span class="n">u0</span> <span class="o">=</span> <span class="n">U</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="k">if</span> <span class="n">dt</span> <span class="o">&lt;=</span> <span class="n">FE_stability_limit</span><span class="p">:</span>
    <span class="n">lines</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">u0</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">u1</span><span class="p">[</span><span class="mi">0</span><span class="p">,:],</span> <span class="n">x</span><span class="p">,</span> <span class="n">u2</span><span class="p">[</span><span class="mi">0</span><span class="p">,:],</span> <span class="n">x</span><span class="p">,</span> <span class="n">u3</span><span class="p">[</span><span class="mi">0</span><span class="p">,:],</span> <span class="n">x</span><span class="p">,</span> <span class="n">u4</span><span class="p">[</span><span class="mi">0</span><span class="p">,:])</span>
<span class="k">else</span><span class="p">:</span>
    <span class="n">lines</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">u0</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">u1</span><span class="p">[</span><span class="mi">0</span><span class="p">,:],</span> <span class="n">x</span><span class="p">,</span> <span class="n">u2</span><span class="p">[</span><span class="mi">0</span><span class="p">,:],</span> <span class="n">x</span><span class="p">,</span> <span class="n">u3</span><span class="p">[</span><span class="mi">0</span><span class="p">,:])</span>
<span class="n">plt</span><span class="o">.</span><span class="n">axis</span><span class="p">([</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">x</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="mi">283</span><span class="o">-</span><span class="mi">30</span><span class="p">,</span> <span class="mi">283</span><span class="o">+</span><span class="mi">30</span><span class="p">])</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s">&#39;x&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s">&#39;u(x,t)&#39;</span><span class="p">)</span>
<span class="n">counter</span> <span class="o">=</span> <span class="mi">0</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">t1</span><span class="p">)):</span>
    <span class="n">u0</span> <span class="o">=</span> <span class="n">U</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">t1</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
    <span class="n">lines</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_ydata</span><span class="p">(</span><span class="n">u0</span><span class="p">)</span>
    <span class="n">lines</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_ydata</span><span class="p">(</span><span class="n">u1</span><span class="p">[</span><span class="n">i</span><span class="p">,:])</span>
    <span class="n">lines</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">set_ydata</span><span class="p">(</span><span class="n">u2</span><span class="p">[</span><span class="n">i</span><span class="p">,:])</span>
    <span class="n">lines</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">.</span><span class="n">set_ydata</span><span class="p">(</span><span class="n">u3</span><span class="p">[</span><span class="n">i</span><span class="p">,:])</span>
    <span class="k">if</span> <span class="n">dt</span> <span class="o">&lt;=</span> <span class="n">FE_stability_limit</span><span class="p">:</span>
        <span class="n">lines</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span><span class="o">.</span><span class="n">set_ydata</span><span class="p">(</span><span class="n">u4</span><span class="p">[</span><span class="n">i</span><span class="p">,:])</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s">&#39;t=</span><span class="si">%.1f</span><span class="s"> days&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">t1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">/</span><span class="p">(</span><span class="mi">60</span><span class="o">*</span><span class="mi">60</span><span class="o">*</span><span class="mf">24.</span><span class="p">)))</span>
    <span class="k">if</span> <span class="n">dt</span> <span class="o">&lt;=</span> <span class="n">FE_stability_limit</span><span class="p">:</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">([</span><span class="s">&#39;exact&#39;</span><span class="p">,</span> <span class="s">&#39;BE&#39;</span><span class="p">,</span> <span class="s">&#39;B2Step&#39;</span><span class="p">,</span> <span class="s">&#39;RKF&#39;</span><span class="p">,</span> <span class="s">&#39;FE&#39;</span><span class="p">])</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">([</span><span class="s">&#39;exact&#39;</span><span class="p">,</span> <span class="s">&#39;BE&#39;</span><span class="p">,</span> <span class="s">&#39;B2Step&#39;</span><span class="p">,</span> <span class="s">&#39;RKF&#39;</span><span class="p">])</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">draw</span><span class="p">()</span>
    <span class="c">#time.sleep(0.1)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="s">&#39;tmp_</span><span class="si">%04d</span><span class="s">.png&#39;</span> <span class="o">%</span> <span class="n">counter</span><span class="p">)</span>
    <span class="n">counter</span> <span class="o">+=</span> <span class="mi">1</span>
</pre></div>
</div>
<p>From experiments it is clear that RKFehlberg uses many more steps, even
at the Forward Euler stability limit than the other schemes without giving
more accuracy. It seems that the 2-step Backward method is the best one.</p>
<p>Filename: <code class="docutils literal"><span class="pre">ground_temp_adaptive.py</span></code>.</p>
</div>
<div class="section" id="exercise-67-investigate-the-rule">
<span id="sec-pde-diff1d-exer-cn"></span><h3>Exercise 67: Investigate the <span class="math">\(\theta\)</span> rule<a class="headerlink" href="#exercise-67-investigate-the-rule" title="Permalink to this headline">¶</a></h3>
<p><strong>a)</strong>
The Crank-Nicolson method for ODEs is very popular when combined with
diffusion equations. For a linear ODE <span class="math">\(u'=au\)</span> it reads</p>
<div class="math">
\[\frac{u^{n+1}-u^n}{\Delta t} = \frac{1}{2}(au^{n} + au^{n+1})
\thinspace .\]</div>
<p>Apply the Crank-Nicolson method in time to the ODE system for a one-dimensional
diffusion equation. Identify the linear system to be solved.</p>
<p><strong>Solution.</strong>
Our system of ODEs reads</p>
<div class="math">
\[\frac{du_0}{dt} = s'(t),
\nonumber\]</div>
<div class="math">
\[\frac{du_i}{dt} =  \frac{\beta}{\Delta x^2}
(u_{i+1}(t) - 2u_i(t) + u_{i-1}(t)) + f_i(t),\quad i=1,\ldots,N-1,
\nonumber\]</div>
<div class="math">
\[\frac{du_N}{dt} =  \frac{2\beta}{\Delta x^2}
(u_{N-1}(t) - u_N(t)) + f_N(t)\thinspace .
\nonumber\]</div>
<p>To ease reading, we now proceed by writing the variables without showing
explicitly the dependence on time <span class="math">\(t\)</span>. With the Crank-Nicolson method,  we get</p>
<div class="math">
\[\frac{u_0^{n+1} - u_0^n}{\Delta t} = \frac{1}{2}\left(s^n + s^{n+1}\right),
\nonumber\]</div>
<div class="math">
\[\frac{u_i^{n+1} - u_i^n}{\Delta t} = \frac{1}{2}
\biggl(\frac{\beta}{\Delta x^2} (u_{i+1}^n - 2u_i^n + u_{i-1}^n) + f_i^n +\nonumber\]</div>
<div class="math">
\[\quad \frac{\beta}{\Delta x^2} (u_{i+1}^{n+1} - 2u_i^{n+1} + u_{i-1}^{n+1}) + f_i^{n+1}\biggr),\quad i=1,\ldots,N-1,
\nonumber\]</div>
<div class="math">
\[\frac{u_N^{n+1} - u_N^n}{\Delta t} = \frac{1}{2}
\left(\frac{2\beta}{\Delta x^2}(u_{N-1}^n - u_N^n) + f_N^n +
\frac{2\beta}{\Delta x^2}(u_{N-1}^{n+1} - u_N^{n+1}) + f_N^{n+1}\right)\thinspace .
\nonumber\]</div>
<p>Collecting the unknowns on the left hand side, brings us to</p>
<div class="math">
\[u_0^{n+1} = u_0^n + \frac{\Delta t}{2}\left(s^n + s^{n+1}\right),
\nonumber\]</div>
<div class="math">
\[-\frac{\Delta t\beta}{2\Delta x^2}u_{i-1}^{n+1} + (1+\frac{\Delta t\beta}{\Delta x^2})u_i^{n+1} - \frac{\Delta t\beta}{2\Delta x^2}u_{i+1}^{n+1} =
u_i^n + \frac{\Delta t\beta}{2\Delta x^2}(u_{i+1}^n - 2u_i^n + u_{i-1}^n) +\nonumber\]</div>
<div class="math">
\[\quad \frac{\Delta t}{2}(f_i^n + f_i^{n+1}),\quad i=1,\ldots,N-1,
\nonumber\]</div>
<div class="math">
\[-\frac{\Delta t\beta}{\Delta x^2}u_{N-1}^{n+1} + (1+\frac{\Delta t\beta}{\Delta x^2})u_N^{n+1} =
u_N^n + \frac{\Delta t\beta}{\Delta x^2}(u_{N-1}^n - u_N^n) +\nonumber\]</div>
<div class="math">
\[\quad \frac{\Delta t}{2}(f_N^n + f_N^{n+1})\thinspace .
\nonumber\]</div>
<p>This is a system of linear equations <span class="math">\(Au = b\)</span>, where <span class="math">\(A\)</span> is filled with zeros, except for the elements</p>
<div class="math">
\[A_{1,1} = 1\nonumber\]</div>
<div class="math">
\[A_{i,i-1} = -\Delta t \frac{\beta}{\Delta x^2},\quad i=2,\ldots,N-1\nonumber\]</div>
<div class="math">
\[A_{i,i+1} = -\Delta t \frac{\beta}{\Delta x^2},\quad i=2,\ldots,N-1\nonumber\]</div>
<div class="math">
\[A_{i,i} = 1 + \Delta t \frac{\beta}{\Delta x^2},\quad i=2,\ldots,N-1\nonumber\]</div>
<div class="math">
\[A_{N,N-1}  = - \Delta t\frac{\beta}{\Delta x^2}\nonumber\]</div>
<div class="math">
\[A_{N,N} = 1 + \Delta t\frac{\beta}{\Delta x^2}\nonumber\]</div>
<p>and</p>
<div class="math">
\[b_1 = u_0^n + \frac{\Delta t}{2}\left(s^n + s^{n+1}\right)\nonumber\]</div>
<div class="math">
\[b_i = u_i^n +\Delta t \frac{\beta}{2\Delta x^2}\left(u_{i+1}^n - 2u_i^n + u_{i-1}^n\right) + \frac{\Delta t}{2}\left(f_i^n + f_i^{n+1}\right)
,\quad i=2,\ldots,N-1\nonumber\]</div>
<div class="math">
\[b_N = u_N^n + \Delta t\frac{\beta}{\Delta x^2}\left(u_{N-1}^n - u_N^n\right) + \frac{\Delta t}{2}\left(f_N^n + f_N^{n+1}\right)\nonumber\]</div>
<p><strong>b)</strong>
The Backward Euler, Forward Euler, and Crank-Nicolson methods can be given
a unified implementation. For a linear ODE <span class="math">\(u'=au\)</span> this formulation is
known as the <span class="math">\(\theta\)</span> rule:</p>
<div class="math">
\[\frac{u^{n+1}-u^n}{\Delta t} = (1-\theta)au^{n} + \theta au^{n+1}
\thinspace .\]</div>
<p>For <span class="math">\(\theta =0\)</span> we recover the Forward Euler method, <span class="math">\(\theta=1\)</span> gives
the Backward Euler scheme, and <span class="math">\(\theta=1/2\)</span> corresponds to the
Crank-Nicolson method. The approximation error in the <span class="math">\(\theta\)</span> rule is
proportional to <span class="math">\(\Delta t\)</span>, except for <span class="math">\(\theta =1/2\)</span> where it is
proportional to <span class="math">\(\Delta t^2\)</span>. For <span class="math">\(\theta \geq 1/2\)</span> the method is
stable for all <span class="math">\(\Delta t\)</span>.</p>
<p>Apply the <span class="math">\(\theta\)</span> rule to the ODE system for a one-dimensional
diffusion equation. Identify the linear system to be solved.</p>
<p><strong>Solution.</strong>
With the theta rule,  we get</p>
<div class="math">
\[\frac{u_0^{n+1} - u_0^n}{\Delta t} = (1-\theta) s^n + \theta s^{n+1},
\nonumber\]</div>
<div class="math">
\[\frac{u_i^{n+1} - u_i^n}{\Delta t} =
(1-\theta)\left(\frac{\beta}{\Delta x^2} (u_{i+1}^n - 2u_i^n + u_{i-1}^n) + f_i^n\right) +\nonumber\]</div>
<div class="math">
\[\quad \theta \left(\frac{\beta}{\Delta x^2} (u_{i+1}^{n+1} - 2u_i^{n+1} + u_{i-1}^{n+1}) + f_i^{n+1}\right),\quad i=1,\ldots,N-1,
\nonumber\]</div>
<div class="math">
\[\frac{u_N^{n+1} - u_N^n}{\Delta t} =
(1-\theta)\left(\frac{2\beta}{\Delta x^2}(u_{N-1}^n - u_N^n) + f_N^n\right) +
\theta \left(\frac{2\beta}{\Delta x^2}(u_{N-1}^{n+1} - u_N^{n+1}) + f_N^{n+1}\right)\thinspace .
\nonumber\]</div>
<p>Collecting the unknowns on the left hand side gives</p>
<div class="math">
\[u_0^{n+1} = u_0^n + \Delta t\left((1-\theta) s^n + \theta s^{n+1}\right),\nonumber\]</div>
<div class="math">
\[-\theta\frac{\Delta t\beta}{\Delta x^2}u_{i-1}^{n+1} + \left(1+\theta\frac{2\Delta t\beta}{\Delta x^2}u_i^{n+1}\right) -
\theta\frac{\Delta t\beta}{\Delta x^2}u_{i+1}{n+1} = u_i^n +\nonumber\]</div>
<div class="math">
\[\Delta t\left(1-\theta\right)\frac{\beta}{\Delta x^2}\left(u_{i+1}^n - 2u_i^n + u_{i-1}^n\right) + \Delta t\left((1-\theta)f_i^n + \theta f_i^{n+1}\right),\quad i=1,\ldots,N-1,\nonumber\]</div>
<div class="math">
\[-\theta\frac{2\Delta t\beta}{\Delta x^2}u_{N-1}^{n+1} + \left(1+\theta\frac{2\Delta t\beta}{\Delta x^2}u_N^{n+1}\right) = u_N^n +\nonumber\]</div>
<div class="math">
\[\Delta t(1-\theta)\frac{2\beta}{\Delta x^2}\left(u_{N-1}^n - u_N^n\right) + \Delta t\left((1-\theta)f_N^n + \theta f_N^{n+1}\right)\thinspace ,
\nonumber\]</div>
<p>which is a system of linear equations <span class="math">\(Au = b\)</span>, where <span class="math">\(A\)</span> is filled with zeros, except for the elements</p>
<div class="math">
\[A_{1,1} = 1\nonumber\]</div>
<div class="math">
\[A_{i,i-1} = -\theta \Delta t \frac{\beta}{\Delta x^2},\quad i=2,\ldots,N-1\nonumber\]</div>
<div class="math">
\[A_{i,i+1} = -\theta \Delta t \frac{\beta}{\Delta x^2},\quad i=2,\ldots,N-1\nonumber\]</div>
<div class="math">
\[A_{i,i} = 1 + \theta \Delta t \frac{2\beta}{\Delta x^2},\quad i=2,\ldots,N-1\nonumber\]</div>
<div class="math">
\[A_{N,N-1}  = - \theta \Delta t\frac{2\beta}{\Delta x^2}\nonumber\]</div>
<div class="math">
\[A_{N,N} = 1 + \theta \Delta t\frac{2\beta}{\Delta x^2}\nonumber\]</div>
<p>and</p>
<div class="math">
\[b_1 = u_0^n + \Delta t\left((1-\theta)s^n + \theta s^{n+1}\right)\nonumber\]</div>
<div class="math">
\[b_i = u_i^n +\Delta t(1-\theta) \frac{\beta}{\Delta x^2}\left(u_{i+1}^n - 2u_i^n + u_{i-1}^n\right) +
\Delta t\left((1-\theta)f_i^n + \theta f_i^{n+1}\right),\quad i=2,\ldots,N-1\nonumber\]</div>
<div class="math">
\[b_N = u_N^n + \Delta t(1-\theta)\frac{2\beta}{\Delta x^2}\left(u_{N-1}^n - u_N^n\right) +
\Delta t\left((1-\theta)f_N^n + \theta f_N^{n+1}\right)\nonumber\]</div>
<p><strong>c)</strong>
Implement the <span class="math">\(\theta\)</span> rule with aid of the Odespy package. The
relevant object name is <code class="docutils literal"><span class="pre">ThetaRule</span></code>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">solver</span> <span class="o">=</span> <span class="n">odespy</span><span class="o">.</span><span class="n">ThetaRule</span><span class="p">(</span><span class="n">rhs</span><span class="p">,</span> <span class="n">f_is_linear</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">jac</span><span class="o">=</span><span class="n">K</span><span class="p">,</span> <span class="n">theta</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>d)</strong>
Consider the physical application from the section <a class="reference internal" href="#sec-pde-diff1d-rod"><span class="std std-ref">Application: heat conduction in a rod</span></a>. Run this case with the <span class="math">\(\theta\)</span> rule and <span class="math">\(\theta =1/2\)</span> for
the following values of <span class="math">\(\Delta t\)</span>: 0.001, 0.01, 0.05.
Report what you see.</p>
<p><strong>Solution.</strong>
With the two larger time steps we see some non-physical oscillations near the end with constant temperature.
These oscillations die out as the stationary case is approached. With a time step of <span class="math">\(0.001\)</span>, there are no oscillations
at all.</p>
<p>Code:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="sd">&quot;&quot;&quot;Temperature evolution in a rod, computed by a BackwardEuler method.&quot;&quot;&quot;</span>

<span class="kn">from</span> <span class="nn">numpy</span> <span class="kn">import</span> <span class="n">linspace</span><span class="p">,</span> <span class="n">zeros</span><span class="p">,</span> <span class="n">linspace</span>

<span class="k">def</span> <span class="nf">rhs</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">t</span><span class="p">):</span>
    <span class="n">N</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">u</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="n">rhs</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">(</span><span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">rhs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">dsdt</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">N</span><span class="p">):</span>
        <span class="n">rhs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">beta</span><span class="o">/</span><span class="n">dx</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">+</span> \
                 <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">t</span><span class="p">)</span>
    <span class="n">rhs</span><span class="p">[</span><span class="n">N</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">beta</span><span class="o">/</span><span class="n">dx</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">dx</span><span class="o">*</span><span class="n">dudx</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="o">-</span>
                           <span class="mi">2</span><span class="o">*</span><span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">+</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">N</span><span class="p">],</span> <span class="n">t</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">rhs</span>

<span class="k">def</span> <span class="nf">K</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">t</span><span class="p">):</span>
    <span class="n">N</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">u</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="n">K</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">((</span><span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>
    <span class="n">K</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">N</span><span class="p">):</span>
        <span class="n">K</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">beta</span><span class="o">/</span><span class="n">dx</span><span class="o">**</span><span class="mi">2</span>
        <span class="n">K</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">2</span><span class="o">*</span><span class="n">beta</span><span class="o">/</span><span class="n">dx</span><span class="o">**</span><span class="mi">2</span>
        <span class="n">K</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">beta</span><span class="o">/</span><span class="n">dx</span><span class="o">**</span><span class="mi">2</span>
    <span class="n">K</span><span class="p">[</span><span class="n">N</span><span class="p">,</span><span class="n">N</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">beta</span><span class="o">/</span><span class="n">dx</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="mi">2</span>
    <span class="n">K</span><span class="p">[</span><span class="n">N</span><span class="p">,</span><span class="n">N</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">beta</span><span class="o">/</span><span class="n">dx</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">K</span>

<span class="k">def</span> <span class="nf">K_vec</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">t</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Vectorized computation of K.&quot;&quot;&quot;</span>
    <span class="n">N</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">u</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="n">K</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">((</span><span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>
    <span class="n">K</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">K</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="n">N</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">beta</span><span class="o">/</span><span class="n">dx</span><span class="o">**</span><span class="mi">2</span>
    <span class="n">K</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="n">N</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">2</span><span class="o">*</span><span class="n">beta</span><span class="o">/</span><span class="n">dx</span><span class="o">**</span><span class="mi">2</span>
    <span class="n">K</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">beta</span><span class="o">/</span><span class="n">dx</span><span class="o">**</span><span class="mi">2</span>
    <span class="n">K</span><span class="p">[</span><span class="n">N</span><span class="p">,</span><span class="n">N</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">beta</span><span class="o">/</span><span class="n">dx</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="mi">2</span>
    <span class="n">K</span><span class="p">[</span><span class="n">N</span><span class="p">,</span><span class="n">N</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">beta</span><span class="o">/</span><span class="n">dx</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">K</span>

<span class="k">def</span> <span class="nf">dudx</span><span class="p">(</span><span class="n">t</span><span class="p">):</span>
    <span class="k">return</span> <span class="mi">0</span>

<span class="k">def</span> <span class="nf">s</span><span class="p">(</span><span class="n">t</span><span class="p">):</span>
    <span class="k">return</span> <span class="mi">423</span>

<span class="k">def</span> <span class="nf">dsdt</span><span class="p">(</span><span class="n">t</span><span class="p">):</span>
    <span class="k">return</span> <span class="mi">0</span>

<span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">t</span><span class="p">):</span>
    <span class="k">return</span> <span class="mi">0</span>


<span class="n">L</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">beta</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">N</span> <span class="o">=</span> <span class="mi">40</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
<span class="n">dx</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="n">u</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">(</span><span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>

<span class="n">U_0</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">(</span><span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
<span class="n">U_0</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">s</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="n">U_0</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">=</span> <span class="mi">283</span>
<span class="n">dt</span> <span class="o">=</span> <span class="n">dx</span><span class="o">**</span><span class="mi">2</span><span class="o">/</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">beta</span><span class="p">)</span>
<span class="k">print</span> <span class="s">&#39;stability limit:&#39;</span><span class="p">,</span> <span class="n">dt</span>
<span class="n">dt</span> <span class="o">=</span> <span class="mf">0.05</span>
<span class="c">#dt = 0.00034375  # ForwardEuler limit</span>

<span class="kn">import</span> <span class="nn">odespy</span>
<span class="n">solver</span> <span class="o">=</span> <span class="n">odespy</span><span class="o">.</span><span class="n">ThetaRule</span><span class="p">(</span><span class="n">rhs</span><span class="p">,</span> <span class="n">f_is_linear</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">jac</span><span class="o">=</span><span class="n">K</span><span class="p">,</span> <span class="n">theta</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>
<span class="n">solver</span><span class="o">.</span><span class="n">set_initial_condition</span><span class="p">(</span><span class="n">U_0</span><span class="p">)</span>
<span class="n">T</span> <span class="o">=</span> <span class="mf">1.2</span>
<span class="n">N_t</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">T</span><span class="o">/</span><span class="nb">float</span><span class="p">(</span><span class="n">dt</span><span class="p">)))</span>
<span class="n">time_points</span> <span class="o">=</span> <span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">N_t</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
<span class="n">u</span><span class="p">,</span> <span class="n">t</span> <span class="o">=</span> <span class="n">solver</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">time_points</span><span class="p">)</span>

<span class="c"># Make movie</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="n">os</span><span class="o">.</span><span class="n">system</span><span class="p">(</span><span class="s">&#39;rm tmp_*.png&#39;</span><span class="p">)</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="kn">as</span> <span class="nn">plt</span>
<span class="kn">import</span> <span class="nn">time</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ion</span><span class="p">()</span>
<span class="n">y</span> <span class="o">=</span> <span class="n">u</span><span class="p">[</span><span class="mi">0</span><span class="p">,:]</span>
<span class="n">lines</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">axis</span><span class="p">([</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">x</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="mi">273</span><span class="p">,</span> <span class="mf">1.2</span><span class="o">*</span><span class="n">s</span><span class="p">(</span><span class="mi">0</span><span class="p">)])</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s">&#39;x&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s">&#39;u(x,t)&#39;</span><span class="p">)</span>
<span class="n">counter</span> <span class="o">=</span> <span class="mi">0</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">u</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
    <span class="k">print</span> <span class="n">t</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
    <span class="n">lines</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_ydata</span><span class="p">(</span><span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="p">,:])</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">([</span><span class="s">&#39;t=</span><span class="si">%.3f</span><span class="s">&#39;</span> <span class="o">%</span> <span class="n">t</span><span class="p">[</span><span class="n">i</span><span class="p">]])</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">draw</span><span class="p">()</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="s">&#39;tmp_</span><span class="si">%04d</span><span class="s">.png&#39;</span> <span class="o">%</span> <span class="n">counter</span><span class="p">)</span>
    <span class="n">counter</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mf">0.2</span><span class="p">)</span>
</pre></div>
</div>
<p>Filename: <code class="docutils literal"><span class="pre">rod_ThetaRule.py</span></code>.</p>
<div class="section" id="remarks-8">
<h4>Remarks<a class="headerlink" href="#remarks-8" title="Permalink to this headline">¶</a></h4>
<p>Despite the fact that the Crank-Nicolson method, or the <span class="math">\(\theta\)</span> rule with
<span class="math">\(\theta=1/2\)</span>, is theoretically more accurate than the Backward Euler and
Forward Euler schemes, it may exhibit non-physical oscillations as in the
present example if the solution is very steep. The oscillations are
damped in time, and decreases with decreasing <span class="math">\(\Delta t\)</span>. To avoid
oscillations one must have <span class="math">\(\Delta t\)</span> at maximum twice the
stability limit of the Forward Euler method. This is one reason why
the Backward Euler method (or a 2-step backward scheme,
see <a class="reference internal" href="#sec-pde-diff1d-exer-compare-implicit"><span class="std std-ref">Exercise 65: Compare implicit methods</span></a>) are popular
for diffusion equations with abrupt initial conditions.</p>
</div>
</div>
<div class="section" id="exercise-68-compute-the-diffusion-of-a-gaussian-peak">
<span id="sec-pde-diff1d-exer-gaussian"></span><h3>Exercise 68: Compute the diffusion of a Gaussian peak<a class="headerlink" href="#exercise-68-compute-the-diffusion-of-a-gaussian-peak" title="Permalink to this headline">¶</a></h3>
<p>Solve the following diffusion problem:</p>
<div class="math" id="eq-auto49">
\[\tag{153}
\frac{\partial u}{\partial t} = \beta\frac{\partial^2 u}{\partial x^2},
     x\in (-1,1),\ t\in (0,T]\]</div>
<div class="math" id="eq-auto50">
\[\tag{154}
u(x,0) = \frac{1}{\sqrt{2\pi}\sigma}\exp{\left(-\frac{x^2}{2\sigma^2}\right)},
     x\in [-1,1],\]</div>
<div class="math" id="eq-auto51">
\[\tag{155}
\frac{\partial}{\partial x}u(-1,t)  = 0  t\in (0,T],\]</div>
<div class="math" id="eq-auto52">
\[\tag{156}
\frac{\partial}{\partial x}u(1,t)  = 0  t\in (0,T]\thinspace .\]</div>
<p>The initial condition is the famous and widely used <em>Gaussian function</em>
with standard deviation (or &#8220;width&#8221;) <span class="math">\(\sigma\)</span>, which is here taken
to be small, <span class="math">\(\sigma = 0.01\)</span>, such that the initial condition is a peak.
This peak will then diffuse and become lower and wider.
Compute <span class="math">\(u(x,t)\)</span> until <span class="math">\(u\)</span> becomes approximately constant over the domain.</p>
<p><strong>Solution.</strong>
Code:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Initially, u has a Gaussian distribution and we</span>
<span class="sd">follow the distribution over x = [-1,1] until u</span>
<span class="sd">is approximately zero.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">from</span> <span class="nn">numpy</span> <span class="kn">import</span> <span class="n">linspace</span><span class="p">,</span> <span class="n">zeros</span><span class="p">,</span> <span class="n">linspace</span><span class="p">,</span> <span class="n">exp</span><span class="p">,</span> <span class="n">sqrt</span><span class="p">,</span> <span class="n">pi</span>

<span class="k">def</span> <span class="nf">rhs</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">t</span><span class="p">):</span>
    <span class="n">N</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">u</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="n">rhs</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">(</span><span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">rhs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">beta</span><span class="o">/</span><span class="n">dx</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">u</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">u</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">+</span> <span class="n">g</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">t</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">N</span><span class="p">):</span>
        <span class="n">rhs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">beta</span><span class="o">/</span><span class="n">dx</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">+</span> \
                 <span class="n">g</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">t</span><span class="p">)</span>
    <span class="n">rhs</span><span class="p">[</span><span class="n">N</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">beta</span><span class="o">/</span><span class="n">dx</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">u</span><span class="p">[</span><span class="n">N</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">u</span><span class="p">[</span><span class="n">N</span><span class="p">])</span> <span class="o">+</span> <span class="n">g</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">N</span><span class="p">],</span> <span class="n">t</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">rhs</span>

<span class="k">def</span> <span class="nf">K</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">t</span><span class="p">):</span>
    <span class="n">N</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">u</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="n">K</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">((</span><span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>
    <span class="n">K</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">2</span><span class="o">*</span><span class="n">beta</span><span class="o">/</span><span class="n">dx</span><span class="o">**</span><span class="mi">2</span><span class="p">;</span>
    <span class="n">K</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span>  <span class="mi">2</span><span class="o">*</span><span class="n">beta</span><span class="o">/</span><span class="n">dx</span><span class="o">**</span><span class="mi">2</span><span class="p">;</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">N</span><span class="p">):</span>
        <span class="n">K</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">beta</span><span class="o">/</span><span class="n">dx</span><span class="o">**</span><span class="mi">2</span>
        <span class="n">K</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">2</span><span class="o">*</span><span class="n">beta</span><span class="o">/</span><span class="n">dx</span><span class="o">**</span><span class="mi">2</span>
        <span class="n">K</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">beta</span><span class="o">/</span><span class="n">dx</span><span class="o">**</span><span class="mi">2</span>
    <span class="n">K</span><span class="p">[</span><span class="n">N</span><span class="p">,</span><span class="n">N</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">beta</span><span class="o">/</span><span class="n">dx</span><span class="o">**</span><span class="mi">2</span>
    <span class="n">K</span><span class="p">[</span><span class="n">N</span><span class="p">,</span><span class="n">N</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">2</span><span class="o">*</span><span class="n">beta</span><span class="o">/</span><span class="n">dx</span><span class="o">**</span><span class="mi">2</span>
    <span class="k">return</span> <span class="n">K</span>

<span class="k">def</span> <span class="nf">I</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Initial conditions for 1D diffusion&quot;&quot;&quot;</span>
    <span class="c">#return (1.0/(sqrt(2*pi)*sigma)*exp(-(x**2)/(2*sigma**2)))</span>
    <span class="c"># Not clean:</span>
    <span class="c">#return (1.0/(sqrt(2*pi)*sigma)*exp(-(x**2)/(2*sigma**2)))</span>
    <span class="k">return</span> <span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">sigma</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span>

<span class="k">def</span> <span class="nf">g</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">t</span><span class="p">):</span>
    <span class="k">return</span> <span class="mi">0</span>

<span class="n">sigma</span> <span class="o">=</span> <span class="mf">0.2</span>
<span class="n">a</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">pi</span>
<span class="n">beta</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">N</span> <span class="o">=</span> <span class="mi">80</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">linspace</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
<span class="n">dx</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="n">u</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">(</span><span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
<span class="n">U_0</span> <span class="o">=</span> <span class="n">I</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

<span class="n">dt</span> <span class="o">=</span> <span class="n">dx</span><span class="o">**</span><span class="mi">2</span><span class="o">/</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">beta</span><span class="p">)</span>
<span class="k">print</span> <span class="s">&#39;FE stability limit:&#39;</span><span class="p">,</span> <span class="n">dt</span>
<span class="k">print</span> <span class="s">&#39;stability limit for FE alternative:&#39;</span><span class="p">,</span> <span class="n">dt</span>
<span class="c"># gives: dt = 0.0003125</span>
<span class="c">#dt = 0.01      # choose much longer time step</span>
<span class="c">#dt = 100.0</span>

<span class="kn">import</span> <span class="nn">odespy</span>
<span class="n">solver0</span> <span class="o">=</span> <span class="n">odespy</span><span class="o">.</span><span class="n">Backward2Step</span><span class="p">(</span><span class="n">rhs</span><span class="p">,</span> <span class="n">f_is_linear</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">jac</span><span class="o">=</span><span class="n">K</span><span class="p">)</span>
<span class="n">solver0</span> <span class="o">=</span> <span class="n">odespy</span><span class="o">.</span><span class="n">ThetaRule</span><span class="p">(</span><span class="n">rhs</span><span class="p">,</span> <span class="n">f_is_linear</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">jac</span><span class="o">=</span><span class="n">K</span><span class="p">,</span> <span class="n">theta</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="n">solver0</span><span class="o">.</span><span class="n">set_initial_condition</span><span class="p">(</span><span class="n">U_0</span><span class="p">)</span>
<span class="n">T</span> <span class="o">=</span> <span class="mi">10</span>
<span class="n">N_t</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">T</span><span class="o">/</span><span class="nb">float</span><span class="p">(</span><span class="n">dt</span><span class="p">)))</span>
<span class="n">time_points</span> <span class="o">=</span> <span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">N_t</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
<span class="n">u0</span><span class="p">,</span> <span class="n">t0</span> <span class="o">=</span> <span class="n">solver0</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">time_points</span><span class="p">)</span>

<span class="c"># Make movie</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="n">os</span><span class="o">.</span><span class="n">system</span><span class="p">(</span><span class="s">&#39;rm -f tmp_*.png&#39;</span><span class="p">)</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="kn">as</span> <span class="nn">plt</span>
<span class="kn">import</span> <span class="nn">time</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ion</span><span class="p">()</span>
<span class="n">lines</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">u0</span><span class="p">[</span><span class="mi">0</span><span class="p">,:])</span>
<span class="n">plt</span><span class="o">.</span><span class="n">axis</span><span class="p">([</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">x</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="mi">0</span><span class="p">,</span> <span class="mf">1.0</span><span class="o">/</span><span class="p">(</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">pi</span><span class="p">)</span><span class="o">*</span><span class="n">sigma</span><span class="p">)])</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s">&#39;x&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s">&#39;u(x,t)&#39;</span><span class="p">)</span>
<span class="n">counter</span> <span class="o">=</span> <span class="mi">0</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">t0</span><span class="p">)):</span>
    <span class="k">print</span> <span class="n">t0</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">u0</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="nb">round</span><span class="p">(</span><span class="n">N</span><span class="o">/</span><span class="mi">2</span><span class="p">)]</span>  <span class="c"># u approx at middle (dep on N)</span>
    <span class="n">lines</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_ydata</span><span class="p">(</span><span class="n">u0</span><span class="p">[</span><span class="n">i</span><span class="p">,:])</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s">&#39;t=</span><span class="si">%.3f</span><span class="s">&#39;</span> <span class="o">%</span> <span class="n">t0</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">([</span><span class="n">solver0</span><span class="o">.</span><span class="n">__class__</span><span class="o">.</span><span class="n">__name__</span><span class="p">])</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">draw</span><span class="p">()</span>
    <span class="c">#time.sleep(0.2)</span>
    <span class="c">#plt.savefig(&#39;tmp_%04d.png&#39; % counter)</span>
    <span class="c">#counter += 1</span>
<span class="nb">raw_input</span><span class="p">()</span>
</pre></div>
</div>
<p>Filename: <code class="docutils literal"><span class="pre">gaussian_diffusion.py</span></code>.</p>
<div class="section" id="remarks-9">
<h4>Remarks<a class="headerlink" href="#remarks-9" title="Permalink to this headline">¶</a></h4>
<p>Running the simulation with <span class="math">\(\sigma =0.2\)</span> results in a constant solution
<span class="math">\(u\approx 1\)</span> as <span class="math">\(t\rightarrow\infty\)</span>, while one might expect from &#8220;physics
of diffusion&#8221; that the solution should approach zero. The reason is
that we apply Neumann conditions as boundary conditions. One can then
easily show that the area under the <span class="math">\(u\)</span> curve remains constant. Integrating
the PDE gives</p>
<div class="math">
\[\int_{-1}^1 \frac{\partial u}{\partial t}dx = \beta \int_{-1}^1
\frac{\partial d^2 u}{\partial x^2}dx\thinspace .\]</div>
<p>Using the Gauss divergence theorem on the integral on the right-hand
and moving the time-derivative outside the integral on the left-hand
side results in</p>
<div class="math">
\[\frac{\partial}{\partial t} \int_{-1}^1 u(x,t) dx = \beta
\left[\frac{\partial du}{\partial x}\right]_{-1}^1 = 0.\]</div>
<p>(Recall that <span class="math">\(\partial u/\partial x=0\)</span> at the end points.)
The result means that <span class="math">\(\int_{-1}^1 udx\)</span> remains constant during the
simulation. Giving the PDE an interpretation in terms of heat conduction
can easily explain the result: with Neumann conditions no heat can
escape from the domain so the initial heat will just be evenly distributed,
but not leak out, so the temperature cannot go to zero (or the scaled and
translated temperature <span class="math">\(u\)</span>, to be precise). The area under the initial
condition is 1, so with a sufficiently fine mesh, <span class="math">\(u\rightarrow 1\)</span>,
regardless of <span class="math">\(\sigma\)</span>.</p>
</div>
</div>
<div class="section" id="exercise-69-vectorize-a-function-for-computing-the-area-of-a-polygon">
<span id="nd-exer-area-polygon2"></span><h3>Exercise 69: Vectorize a function for computing the area of a polygon<a class="headerlink" href="#exercise-69-vectorize-a-function-for-computing-the-area-of-a-polygon" title="Permalink to this headline">¶</a></h3>
<p>Vectorize the implementation of the function for computing the area of
a polygon in <a class="reference internal" href="._pylight003.html#nd-exer-area-polygon"><span class="std std-ref">Exercise 15: Area of a polygon</span></a>. Make a test function
that compares the scalar implementation in <a class="reference internal" href="._pylight003.html#nd-exer-area-polygon"><span class="std std-ref">Exercise 15: Area of a polygon</span></a>
and the new vectorized implementation for the test cases used
in <a class="reference internal" href="._pylight003.html#nd-exer-area-polygon"><span class="std std-ref">Exercise 15: Area of a polygon</span></a>.</p>
<p><strong>Hint.</strong>
Notice that the formula <span class="math">\(x_1y_2+x_2y_3 + \cdots + x_{n-1}y_n =
\sum_{i=0}^{n-1}x_iy_{i+1}\)</span> is the dot product of two vectors,
<code class="docutils literal"><span class="pre">x[:-1]</span></code> and
<code class="docutils literal"><span class="pre">y[1:]</span></code>,
which can be computed as <code class="docutils literal"><span class="pre">numpy.dot(x[:-1],</span> <span class="pre">y[1:])</span></code>,
or more explicitly as <code class="docutils literal"><span class="pre">numpy.sum(x[:-1]*y[1:])</span></code>.</p>
<p><strong>Solution.</strong>
Code:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Computes the area of a polygon from vertex</span>
<span class="sd">coordinates only. Vectorization is exploited.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">from</span> <span class="nn">polyarea</span> <span class="kn">import</span> <span class="n">polyarea</span>
<span class="kn">from</span> <span class="nn">numpy</span> <span class="kn">import</span> <span class="nb">sum</span><span class="p">,</span> <span class="n">asarray</span>

<span class="k">def</span> <span class="nf">polyarea_vec</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">asarray</span><span class="p">(</span><span class="n">x</span><span class="p">);</span> <span class="n">y</span> <span class="o">=</span> <span class="n">asarray</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>      <span class="c"># since sum requires arrays</span>
    <span class="k">return</span> <span class="mf">0.5</span><span class="o">*</span><span class="nb">abs</span><span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="n">x</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">y</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span> <span class="o">-</span> <span class="nb">sum</span><span class="p">(</span><span class="n">y</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span> <span class="o">+</span> \
                    <span class="n">x</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">y</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">y</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

<span class="k">def</span> <span class="nf">test_polyarea_vec</span><span class="p">():</span>
    <span class="n">tol</span> <span class="o">=</span> <span class="mf">1E-14</span>
    <span class="c"># pentagon</span>
    <span class="n">x1</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
    <span class="n">y1</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>
    <span class="c">#print abs(polyarea(x1, y1) - polyarea_vec(x1, y1))</span>
    <span class="k">assert</span> <span class="nb">abs</span><span class="p">(</span><span class="n">polyarea</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">y1</span><span class="p">)</span> <span class="o">-</span> <span class="n">polyarea_vec</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">y1</span><span class="p">))</span> <span class="o">&lt;</span> <span class="n">tol</span>
    <span class="c"># quadrilateral</span>
    <span class="n">x2</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
    <span class="n">y2</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>
    <span class="c">#print abs(polyarea(x2, y2) - polyarea_vec(x2, y2))</span>
    <span class="k">assert</span> <span class="nb">abs</span><span class="p">(</span><span class="n">polyarea</span><span class="p">(</span><span class="n">x2</span><span class="p">,</span> <span class="n">y2</span><span class="p">)</span> <span class="o">-</span> <span class="n">polyarea_vec</span><span class="p">(</span><span class="n">x2</span><span class="p">,</span> <span class="n">y2</span><span class="p">))</span> <span class="o">&lt;</span> <span class="n">tol</span>
    <span class="c"># triangle</span>
    <span class="n">x3</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
    <span class="n">y3</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>
    <span class="c">#print abs(polyarea(x3, y3) - polyarea_vec(x3, y3))</span>
    <span class="k">assert</span> <span class="nb">abs</span><span class="p">(</span><span class="n">polyarea</span><span class="p">(</span><span class="n">x3</span><span class="p">,</span> <span class="n">y3</span><span class="p">)</span> <span class="o">-</span> <span class="n">polyarea_vec</span><span class="p">(</span><span class="n">x3</span><span class="p">,</span> <span class="n">y3</span><span class="p">))</span> <span class="o">&lt;</span> <span class="n">tol</span>

<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">test_polyarea_vec</span><span class="p">()</span>
</pre></div>
</div>
<p>Filename: <code class="docutils literal"><span class="pre">polyarea_vec.py</span></code>.</p>
</div>
<div class="section" id="exercise-70-explore-symmetry">
<span id="sec-pde-diff1d-exer-gaussian-symm"></span><h3>Exercise 70: Explore symmetry<a class="headerlink" href="#exercise-70-explore-symmetry" title="Permalink to this headline">¶</a></h3>
<p>One can observe (and also mathematically prove)
that the solution <span class="math">\(u(x,t)\)</span> of the problem in <a class="reference internal" href="#sec-pde-diff1d-exer-gaussian"><span class="std std-ref">Exercise 68: Compute the diffusion of a Gaussian peak</span></a> is symmetric around <span class="math">\(x=0\)</span>: <span class="math">\(u(-x,t) = u(x,t)\)</span>.
In such a case, we can split the domain in two and compute <span class="math">\(u\)</span> in only
one half, <span class="math">\([-1,0]\)</span> or <span class="math">\([0,1]\)</span>. At the symmetry line <span class="math">\(x=0\)</span> we have
the symmetry boundary condition <span class="math">\(\partial u/\partial x=0\)</span>.
Reformulate the problem in <a class="reference internal" href="#sec-pde-diff1d-exer-gaussian"><span class="std std-ref">Exercise 68: Compute the diffusion of a Gaussian peak</span></a>
such that we compute only for <span class="math">\(x\in [0,1]\)</span>. Display the solution and
observe that it equals the right part of the solution in
<a class="reference internal" href="#sec-pde-diff1d-exer-gaussian"><span class="std std-ref">Exercise 68: Compute the diffusion of a Gaussian peak</span></a>.</p>
<p><strong>Solution.</strong>
Reformulating gives</p>
<div class="math" id="eq-auto53">
\[\tag{157}
\frac{\partial u}{\partial t} = \beta\frac{\partial^2 u}{\partial x^2},
     x\in (0,1),\ t\in (0,T]\]</div>
<div class="math" id="eq-auto54">
\[\tag{158}
u(x,0) = \frac{1}{\sqrt{2\pi}\sigma}\exp{\left(-\frac{x^2}{2\sigma^2}\right)},
     x\in [0,1],\]</div>
<div class="math" id="eq-auto55">
\[\tag{159}
\frac{\partial}{\partial x}u(0,t)  = 0  t\in (0,T],\]</div>
<div class="math" id="eq-auto56">
\[\tag{160}
\frac{\partial}{\partial x}u(1,t)  = 0  t\in (0,T]\thinspace .\]</div>
<p>Code:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Initially, u has a Gaussian distribution symmetric around x = 0.</span>
<span class="sd">We utilize symmetry here and follow the distribution over</span>
<span class="sd">x = [0,1] until u is approximately zero.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">from</span> <span class="nn">numpy</span> <span class="kn">import</span> <span class="n">linspace</span><span class="p">,</span> <span class="n">zeros</span><span class="p">,</span> <span class="n">linspace</span><span class="p">,</span> <span class="n">exp</span><span class="p">,</span> <span class="n">sqrt</span><span class="p">,</span> <span class="n">pi</span>

<span class="k">def</span> <span class="nf">rhs</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">t</span><span class="p">):</span>
    <span class="n">N</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">u</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="n">rhs</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">(</span><span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">rhs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">beta</span><span class="o">/</span><span class="n">dx</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">u</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">u</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">+</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">t</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">N</span><span class="p">):</span>
        <span class="n">rhs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">beta</span><span class="o">/</span><span class="n">dx</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">+</span> \
                 <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">t</span><span class="p">)</span>
    <span class="n">rhs</span><span class="p">[</span><span class="n">N</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">beta</span><span class="o">/</span><span class="n">dx</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">u</span><span class="p">[</span><span class="n">N</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">u</span><span class="p">[</span><span class="n">N</span><span class="p">])</span> <span class="o">+</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">N</span><span class="p">],</span> <span class="n">t</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">rhs</span>

<span class="k">def</span> <span class="nf">K</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">t</span><span class="p">):</span>
    <span class="n">N</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">u</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="n">K</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">((</span><span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>
    <span class="n">K</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">2</span><span class="o">*</span><span class="n">beta</span><span class="o">/</span><span class="n">dx</span><span class="o">**</span><span class="mi">2</span><span class="p">;</span>
    <span class="n">K</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span>  <span class="mi">2</span><span class="o">*</span><span class="n">beta</span><span class="o">/</span><span class="n">dx</span><span class="o">**</span><span class="mi">2</span><span class="p">;</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">N</span><span class="p">):</span>
        <span class="n">K</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">beta</span><span class="o">/</span><span class="n">dx</span><span class="o">**</span><span class="mi">2</span>
        <span class="n">K</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">2</span><span class="o">*</span><span class="n">beta</span><span class="o">/</span><span class="n">dx</span><span class="o">**</span><span class="mi">2</span>
        <span class="n">K</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">beta</span><span class="o">/</span><span class="n">dx</span><span class="o">**</span><span class="mi">2</span>
    <span class="n">K</span><span class="p">[</span><span class="n">N</span><span class="p">,</span><span class="n">N</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">beta</span><span class="o">/</span><span class="n">dx</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="mi">2</span>
    <span class="n">K</span><span class="p">[</span><span class="n">N</span><span class="p">,</span><span class="n">N</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">beta</span><span class="o">/</span><span class="n">dx</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">K</span>

<span class="k">def</span> <span class="nf">I</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Initial conditions for 1D diffusion&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="p">(</span><span class="mf">1.0</span><span class="o">/</span><span class="p">(</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">pi</span><span class="p">)</span><span class="o">*</span><span class="n">sigma</span><span class="p">)</span><span class="o">*</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">sigma</span><span class="o">**</span><span class="mi">2</span><span class="p">)))</span>

<span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">t</span><span class="p">):</span>
    <span class="k">return</span> <span class="mi">0</span>

<span class="n">sigma</span> <span class="o">=</span> <span class="mf">0.2</span>
<span class="n">sigma</span> <span class="o">=</span> <span class="mf">0.02</span>
<span class="n">a</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">beta</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">N</span> <span class="o">=</span> <span class="mi">40</span>
<span class="n">N</span> <span class="o">=</span> <span class="mi">400</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">linspace</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
<span class="n">dx</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="n">u</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">(</span><span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
<span class="n">U_0</span> <span class="o">=</span> <span class="n">I</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

<span class="n">dt</span> <span class="o">=</span> <span class="n">dx</span><span class="o">**</span><span class="mi">2</span><span class="o">/</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">beta</span><span class="p">)</span>
<span class="k">print</span> <span class="s">&#39;stability limit for alternative FE:&#39;</span><span class="p">,</span> <span class="n">dt</span>
<span class="c"># gives: dt = 0.003125</span>
<span class="n">dt</span> <span class="o">=</span> <span class="mf">0.05</span>       <span class="c"># choose much longer time step</span>

<span class="kn">import</span> <span class="nn">odespy</span>
<span class="n">solver0</span> <span class="o">=</span> <span class="n">odespy</span><span class="o">.</span><span class="n">Backward2Step</span><span class="p">(</span><span class="n">rhs</span><span class="p">,</span> <span class="n">f_is_linear</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">jac</span><span class="o">=</span><span class="n">K</span><span class="p">)</span>
<span class="n">solver0</span><span class="o">.</span><span class="n">set_initial_condition</span><span class="p">(</span><span class="n">U_0</span><span class="p">)</span>
<span class="n">T</span> <span class="o">=</span> <span class="mi">3</span>
<span class="n">N_t</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">T</span><span class="o">/</span><span class="nb">float</span><span class="p">(</span><span class="n">dt</span><span class="p">)))</span>
<span class="n">time_points</span> <span class="o">=</span> <span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">N_t</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
<span class="n">u0</span><span class="p">,</span> <span class="n">t0</span> <span class="o">=</span> <span class="n">solver0</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">time_points</span><span class="p">)</span>

<span class="c"># Make movie</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="n">os</span><span class="o">.</span><span class="n">system</span><span class="p">(</span><span class="s">&#39;rm tmp_*.png&#39;</span><span class="p">)</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="kn">as</span> <span class="nn">plt</span>
<span class="kn">import</span> <span class="nn">time</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ion</span><span class="p">()</span>
<span class="n">lines</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">u0</span><span class="p">[</span><span class="mi">0</span><span class="p">,:])</span>
<span class="n">plt</span><span class="o">.</span><span class="n">axis</span><span class="p">([</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">x</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="mi">0</span><span class="p">,</span> <span class="mf">1.0</span><span class="o">/</span><span class="p">(</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">pi</span><span class="p">)</span><span class="o">*</span><span class="n">sigma</span><span class="p">)])</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s">&#39;x&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s">&#39;u(x,t)&#39;</span><span class="p">)</span>
<span class="n">counter</span> <span class="o">=</span> <span class="mi">0</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">t0</span><span class="p">)):</span>
    <span class="k">print</span> <span class="n">t0</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">u0</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="nb">round</span><span class="p">(</span><span class="n">N</span><span class="o">/</span><span class="mi">2</span><span class="p">)]</span>  <span class="c"># u approx at middle (dep on N)</span>
    <span class="n">lines</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_ydata</span><span class="p">(</span><span class="n">u0</span><span class="p">[</span><span class="n">i</span><span class="p">,:])</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s">&#39;t=</span><span class="si">%.3f</span><span class="s">&#39;</span> <span class="o">%</span> <span class="n">t0</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">([</span><span class="s">&#39;B2Step&#39;</span><span class="p">])</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">draw</span><span class="p">()</span>
    <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mf">0.2</span><span class="p">)</span>
    <span class="c">#plt.savefig(&#39;tmp_%04d.png&#39; % counter)</span>
    <span class="c">#counter += 1</span>
</pre></div>
</div>
<p>Filename: <code class="docutils literal"><span class="pre">symmetric_gaussian_diffusion.py</span></code>.</p>
<div class="section" id="remarks-10">
<h4>Remarks<a class="headerlink" href="#remarks-10" title="Permalink to this headline">¶</a></h4>
<p>In 2D and 3D problems, where the CPU time to compute a solution of PDE
can be hours and days, it is very important to utilize symmetry as
we do above to reduce the size of the problem.</p>
<p>Also note the remarks in <a class="reference internal" href="#sec-pde-diff1d-exer-gaussian"><span class="std std-ref">Exercise 68: Compute the diffusion of a Gaussian peak</span></a>
about the constant area under the <span class="math">\(u(x,t)\)</span> curve: here, the area
is 0.5 and <span class="math">\(u\rightarrow 0.5\)</span> as <span class="math">\(t\rightarrow 0.5\)</span> (if the mesh
is sufficiently fine - one will get convergence to
smaller values for small <span class="math">\(\sigma\)</span> if the mesh is not fine enough to
properly resolve a thin-shaped initial condition).</p>
</div>
</div>
<div class="section" id="exercise-71-compute-solutions-as">
<span id="sec-pde-diff1d-exer-stationary"></span><h3>Exercise 71: Compute solutions as <span class="math">\(t\rightarrow\infty\)</span><a class="headerlink" href="#exercise-71-compute-solutions-as" title="Permalink to this headline">¶</a></h3>
<span class="target" id="index-23"></span><p id="index-24">Many diffusion problems reach a stationary time-independent solution
as <span class="math">\(t\rightarrow\infty\)</span>. The model problem from the section <a class="reference internal" href="#sec-pde-diff1d-rod"><span class="std std-ref">Application: heat conduction in a rod</span></a>
is one example where <span class="math">\(u(x,t)=s(t)=\hbox{const}\)</span> for <span class="math">\(t\rightarrow\infty\)</span>.
When <span class="math">\(u\)</span> does not depend on time, the diffusion equation reduces to</p>
<div class="math">
\[-\beta u''(x) = f(x),\]</div>
<p>in one dimension, and</p>
<div class="math">
\[-\beta \nabla^2 u = f(x),\]</div>
<p>in 2D and 3D. This is the famous <em>Poisson</em> equation, or if <span class="math">\(f=0\)</span>, it is
known as the <em>Laplace</em> equation.
In this limit <span class="math">\(t\rightarrow\infty\)</span>, there is no need for an initial
condition, but the boundary conditions are the same as for the diffusion
equation.</p>
<p>We now consider a one-dimensional problem</p>
<div class="math" id="eq-sec-pde-diff1d-exer-stationary-2ptbvp">
\[\tag{161}
-u''(x) = 0,\ x\in (0,L),\quad u(0)=C, \ u'(L)=0,\]</div>
<p>which is known as a <em>two-point boundary value problem</em>. This is nothing
but the stationary limit of the diffusion problem in
the section <a class="reference internal" href="#sec-pde-diff1d-rod"><span class="std std-ref">Application: heat conduction in a rod</span></a>. How can we solve such a stationary
problem <a class="reference internal" href="#eq-sec-pde-diff1d-exer-stationary-2ptbvp"><span class="std std-ref">(161)</span></a>?
The simplest strategy, when we already have a solver for
the corresponding time-dependent problem, is to use that solver and
simulate until <span class="math">\(t\rightarrow\infty\)</span>, which in practice means that
<span class="math">\(u(x,t)\)</span> no longer changes in time (within some tolerance).</p>
<p>A nice feature of implicit methods like the Backward Euler scheme
is that one can take <em>one very long time step</em> to &#8220;infinity&#8221; and
produce the solution of <a class="reference internal" href="#eq-sec-pde-diff1d-exer-stationary-2ptbvp"><span class="std std-ref">(161)</span></a>.</p>
<p><strong>a)</strong>
Let <a class="reference internal" href="#eq-sec-pde-diff1d-exer-stationary-2ptbvp"><span class="std std-ref">(161)</span></a> be valid at mesh
points <span class="math">\(x_i\)</span> in space, discretize <span class="math">\(u''\)</span> by a finite difference, and
set up a system of equations for the point values <span class="math">\(u_i\)</span>,$i =0,ldots,N$,
where <span class="math">\(u_i\)</span> is the approximation at mesh point <span class="math">\(x_i\)</span>.</p>
<p><strong>Solution.</strong>
With the standard approximation introduced for the second derivative, we
get for the inner points that</p>
<div class="math">
\[-\frac{1}{\Delta x^2}(u_{i+1} - 2u_i + u_{i-1}) = 0,\quad i=1,\ldots,N-1,\nonumber\]</div>
<p>i.e.,</p>
<div class="math">
\[u_{i+1} - 2u_i + u_{i-1} = 0,\quad i=1,\ldots,N-1.\nonumber\]</div>
<p>In addition, for the end with a constant temperature, we have that <span class="math">\(u_0 = C\)</span>.
At the other boundary, we may introduce a central difference approximation
to the first derivative and find that</p>
<div class="math">
\[\frac{u_{N+1} - u_{N-1}}{2\Delta x} \approx 0,\nonumber\]</div>
<p>i.e.,</p>
<div class="math">
\[u_{N+1} = u_{N-1}.\nonumber\]</div>
<p>Introducing this equality in the equation above applied for <span class="math">\(i = N\)</span>,
gives</p>
<div class="math">
\[u_{N-1} - 2u_{N} + u_{N-1},\nonumber\]</div>
<p>i.e.,</p>
<div class="math">
\[u_{N} = u_{N-1}.\nonumber\]</div>
<p>Summarizing for all the mesh points, we have the equations</p>
<div class="math">
\[u_0 = C,\nonumber\]</div>
<div class="math">
\[u_{i+1} - 2u_i + u_{i-1} = 0,\quad i=1,\ldots,N-1,\nonumber\]</div>
<div class="math">
\[u_N = u_{N-1}\nonumber\thinspace ,\]</div>
<p>which is a system of linear equations in the unknowns <span class="math">\(u_i\)</span>, <span class="math">\(i=0,\ldots,N\)</span>.</p>
<p><strong>b)</strong>
Show that if <span class="math">\(\Delta t\rightarrow\infty\)</span> in <a class="reference internal" href="#eq-sec-pde-diff1d-ode1-0-be"><span class="std std-ref">(135)</span></a> - <a class="reference internal" href="#eq-sec-pde-diff1d-ode1-n-be"><span class="std std-ref">(137)</span></a>,
it leads to the same equations as in a).</p>
<p><strong>Solution.</strong>
From <a class="reference internal" href="#eq-sec-pde-diff1d-ode1-0-be"><span class="std std-ref">(135)</span></a> - <a class="reference internal" href="#eq-sec-pde-diff1d-ode1-n-be"><span class="std std-ref">(137)</span></a>,
letting <span class="math">\(\Delta t\rightarrow\infty\)</span>, we see that the left hand sides go to zero, i.e.</p>
<div class="math">
\[0 = s'(t), \nonumber\]</div>
<div class="math">
\[0 =  \frac{\beta}{\Delta x^2}(u_{i+1}^{n+1}(t) - 2u_i^{n+1}(t) + u_{i-1}^{n+1}(t)) + f_i(t),
\quad i=1,\ldots,N-1,\nonumber\]</div>
<div class="math">
\[0 =  \frac{2\beta}{\Delta x^2}(u_{N-1}^{n+1}(t) - u_N^{n+1}(t)) + f_i(t)\thinspace .\nonumber\]</div>
<p>Our <span class="math">\(s(t) = C\)</span>, which is consistent with the first one of these three equations. The <span class="math">\(\beta\)</span> factor
in the two other equations disappear by division and <span class="math">\(f_i(t) = 0\)</span>. Since the time index <span class="math">\(n+1\)</span> has no importance
now that <span class="math">\(\Delta t\rightarrow\infty\)</span>, we see that the equations just derived, are, in fact, just the same as the ones in a).</p>
<p><strong>c)</strong>
Demonstrate, by running a program,
that you can take one large time step with the Backward Euler
scheme and compute the solution of <a class="reference internal" href="#eq-sec-pde-diff1d-exer-stationary-2ptbvp"><span class="std std-ref">(161)</span></a>.
The solution is very boring since it is constant: <span class="math">\(u(x)=C\)</span>.</p>
<p><strong>Solution.</strong>
Code:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="sd">&quot;&quot;&quot;Compute final and stationary temperature distribution</span>
<span class="sd">in a rod by a BackwardEuler method.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">from</span> <span class="nn">numpy</span> <span class="kn">import</span> <span class="n">linspace</span><span class="p">,</span> <span class="n">zeros</span><span class="p">,</span> <span class="n">linspace</span>

<span class="k">def</span> <span class="nf">rhs</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">t</span><span class="p">):</span>
    <span class="n">N</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">u</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="n">rhs</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">(</span><span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">rhs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">dsdt</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">N</span><span class="p">):</span>
        <span class="n">rhs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">beta</span><span class="o">/</span><span class="n">dx</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">+</span> \
                 <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">t</span><span class="p">)</span>
    <span class="n">rhs</span><span class="p">[</span><span class="n">N</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">beta</span><span class="o">/</span><span class="n">dx</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">dx</span><span class="o">*</span><span class="n">dudx</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="o">-</span>
                           <span class="mi">2</span><span class="o">*</span><span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">+</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">N</span><span class="p">],</span> <span class="n">t</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">rhs</span>

<span class="k">def</span> <span class="nf">K</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">t</span><span class="p">):</span>
    <span class="n">N</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">u</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="n">K</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">((</span><span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>
    <span class="n">K</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">N</span><span class="p">):</span>
        <span class="n">K</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">beta</span><span class="o">/</span><span class="n">dx</span><span class="o">**</span><span class="mi">2</span>
        <span class="n">K</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">2</span><span class="o">*</span><span class="n">beta</span><span class="o">/</span><span class="n">dx</span><span class="o">**</span><span class="mi">2</span>
        <span class="n">K</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">beta</span><span class="o">/</span><span class="n">dx</span><span class="o">**</span><span class="mi">2</span>
    <span class="n">K</span><span class="p">[</span><span class="n">N</span><span class="p">,</span><span class="n">N</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">beta</span><span class="o">/</span><span class="n">dx</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="mi">2</span>
    <span class="n">K</span><span class="p">[</span><span class="n">N</span><span class="p">,</span><span class="n">N</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">beta</span><span class="o">/</span><span class="n">dx</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">K</span>

<span class="k">def</span> <span class="nf">dudx</span><span class="p">(</span><span class="n">t</span><span class="p">):</span>
    <span class="k">return</span> <span class="mi">0</span>

<span class="k">def</span> <span class="nf">s</span><span class="p">(</span><span class="n">t</span><span class="p">):</span>
    <span class="k">return</span> <span class="mi">423</span>

<span class="k">def</span> <span class="nf">dsdt</span><span class="p">(</span><span class="n">t</span><span class="p">):</span>
    <span class="k">return</span> <span class="mi">0</span>

<span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">t</span><span class="p">):</span>
    <span class="k">return</span> <span class="mi">0</span>

<span class="n">L</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">beta</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">N</span> <span class="o">=</span> <span class="mi">40</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
<span class="n">dx</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="n">u</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">(</span><span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>

<span class="n">U_0</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">(</span><span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
<span class="n">U_0</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">s</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="n">U_0</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">=</span> <span class="mi">300</span>
<span class="n">dt</span> <span class="o">=</span> <span class="mi">60</span>                 <span class="c"># choose one large timestep</span>

<span class="kn">import</span> <span class="nn">odespy</span>
<span class="n">solver</span> <span class="o">=</span> <span class="n">odespy</span><span class="o">.</span><span class="n">BackwardEuler</span><span class="p">(</span><span class="n">rhs</span><span class="p">,</span> <span class="n">f_is_linear</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">jac</span><span class="o">=</span><span class="n">K</span><span class="p">)</span>
<span class="n">solver</span><span class="o">.</span><span class="n">set_initial_condition</span><span class="p">(</span><span class="n">U_0</span><span class="p">)</span>
<span class="c">#T = 1.2</span>
<span class="n">T</span> <span class="o">=</span> <span class="n">dt</span>
<span class="n">N_t</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">T</span><span class="o">/</span><span class="nb">float</span><span class="p">(</span><span class="n">dt</span><span class="p">)))</span>
<span class="n">time_points</span> <span class="o">=</span> <span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">N_t</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
<span class="n">u</span><span class="p">,</span> <span class="n">t</span> <span class="o">=</span> <span class="n">solver</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">time_points</span><span class="p">)</span>

<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="kn">as</span> <span class="nn">plt</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">u</span><span class="p">[</span><span class="n">N_t</span><span class="p">,:])</span>
<span class="n">plt</span><span class="o">.</span><span class="n">axis</span><span class="p">([</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">x</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="mi">273</span><span class="p">,</span> <span class="mf">1.2</span><span class="o">*</span><span class="n">s</span><span class="p">(</span><span class="mi">0</span><span class="p">)])</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<p>Filename: <code class="docutils literal"><span class="pre">rod_stationary.py</span></code>.</p>
<div class="section" id="remarks-11">
<h4>Remarks<a class="headerlink" href="#remarks-11" title="Permalink to this headline">¶</a></h4>
<p>If the interest is in the stationary limit of a diffusion equation,
one can either solve the associated Laplace or Poisson equation directly,
or use a Backward Euler scheme for the time-dependent diffusion equation
with a very long time step. Using a Forward Euler scheme with small time
steps is typically inappropriate in such situations because the
solution changes more and more slowly, but the time step must still be
kept small, and it takes &#8220;forever&#8221; to approach the stationary state.
This is yet another example why one needs implicit methods like the
Backward Euler scheme.</p>
</div>
</div>
<div class="section" id="exercise-72-solve-a-two-point-boundary-value-problem">
<span id="sec-pde-diff1d-exer-stationary2"></span><h3>Exercise 72: Solve a two-point boundary value problem<a class="headerlink" href="#exercise-72-solve-a-two-point-boundary-value-problem" title="Permalink to this headline">¶</a></h3>
<p>Solve the following two-point boundary-value problem</p>
<div class="math">
\[u''(x) = 2,\ x\in (0,1),\quad u(0)=0,\ u(1)=1\thinspace .\]</div>
<p><strong>Hint.</strong>
Do <a class="reference internal" href="#sec-pde-diff1d-exer-stationary"><span class="std std-ref">Exercise 71: Compute solutions as </span></a>. Modify the
boundary condition in the code so it incorporates a known value
for <span class="math">\(u(1)\)</span>.</p>
<p><strong>Solution.</strong>
Code:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Solve 2-point BVP.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">from</span> <span class="nn">numpy</span> <span class="kn">import</span> <span class="n">linspace</span><span class="p">,</span> <span class="n">zeros</span><span class="p">,</span> <span class="n">linspace</span>

<span class="k">def</span> <span class="nf">rhs</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">t</span><span class="p">):</span>
    <span class="n">N</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">u</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="n">rhs</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">(</span><span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">rhs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">ds1dt</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">N</span><span class="p">):</span>
        <span class="n">rhs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">beta</span><span class="o">/</span><span class="n">dx</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">+</span> \
                 <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">t</span><span class="p">)</span>
    <span class="n">rhs</span><span class="p">[</span><span class="n">N</span><span class="p">]</span> <span class="o">=</span> <span class="n">ds2dt</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">rhs</span>

<span class="k">def</span> <span class="nf">K</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">t</span><span class="p">):</span>
    <span class="n">N</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">u</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="n">K</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">((</span><span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>
    <span class="n">K</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">N</span><span class="p">):</span>
        <span class="n">K</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">beta</span><span class="o">/</span><span class="n">dx</span><span class="o">**</span><span class="mi">2</span>
        <span class="n">K</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">2</span><span class="o">*</span><span class="n">beta</span><span class="o">/</span><span class="n">dx</span><span class="o">**</span><span class="mi">2</span>
        <span class="n">K</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">beta</span><span class="o">/</span><span class="n">dx</span><span class="o">**</span><span class="mi">2</span>
    <span class="n">K</span><span class="p">[</span><span class="n">N</span><span class="p">,</span><span class="n">N</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">K</span><span class="p">[</span><span class="n">N</span><span class="p">,</span><span class="n">N</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">return</span> <span class="n">K</span>

<span class="k">def</span> <span class="nf">dudx</span><span class="p">(</span><span class="n">t</span><span class="p">):</span>
    <span class="k">return</span> <span class="mi">0</span>

<span class="k">def</span> <span class="nf">s1</span><span class="p">(</span><span class="n">t</span><span class="p">):</span>
    <span class="k">return</span> <span class="mi">0</span>

<span class="k">def</span> <span class="nf">ds1dt</span><span class="p">(</span><span class="n">t</span><span class="p">):</span>
    <span class="k">return</span> <span class="mi">0</span>

<span class="k">def</span> <span class="nf">s2</span><span class="p">(</span><span class="n">t</span><span class="p">):</span>
    <span class="k">return</span> <span class="mi">1</span>

<span class="k">def</span> <span class="nf">ds2dt</span><span class="p">(</span><span class="n">t</span><span class="p">):</span>
    <span class="k">return</span> <span class="mi">0</span>

<span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">t</span><span class="p">):</span>
    <span class="k">return</span> <span class="o">-</span><span class="mi">2</span>

<span class="n">L</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">beta</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">N</span> <span class="o">=</span> <span class="mi">40</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
<span class="n">dx</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="n">u</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">(</span><span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>

<span class="n">U_0</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">(</span><span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
<span class="n">U_0</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">s1</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="n">U_0</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.5</span>
<span class="n">U_0</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">s2</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="n">dt</span> <span class="o">=</span> <span class="mi">10</span>                 <span class="c"># choose one large timestep</span>

<span class="kn">import</span> <span class="nn">odespy</span>
<span class="n">solver</span> <span class="o">=</span> <span class="n">odespy</span><span class="o">.</span><span class="n">BackwardEuler</span><span class="p">(</span><span class="n">rhs</span><span class="p">,</span> <span class="n">f_is_linear</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">jac</span><span class="o">=</span><span class="n">K</span><span class="p">)</span>
<span class="n">solver</span><span class="o">.</span><span class="n">set_initial_condition</span><span class="p">(</span><span class="n">U_0</span><span class="p">)</span>
<span class="c">#T = 1.2</span>
<span class="n">T</span> <span class="o">=</span> <span class="n">dt</span>
<span class="n">N_t</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">T</span><span class="o">/</span><span class="nb">float</span><span class="p">(</span><span class="n">dt</span><span class="p">)))</span>
<span class="n">time_points</span> <span class="o">=</span> <span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">N_t</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
<span class="n">u</span><span class="p">,</span> <span class="n">t</span> <span class="o">=</span> <span class="n">solver</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">time_points</span><span class="p">)</span>

<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="kn">as</span> <span class="nn">plt</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">u</span><span class="p">[</span><span class="n">N_t</span><span class="p">,:],</span> <span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">([</span><span class="s">&#39;numerical&#39;</span><span class="p">,</span> <span class="s">&#39;exact&#39;</span><span class="p">])</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<p>Filename: <code class="docutils literal"><span class="pre">2ptBVP.py</span></code>.</p>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <center>
            <p class="logo"><a href="http://cbc.simula.no/" title="Go to Center for Biomedical Computing">
              <img class="logo" src="_static/cbc_logo.png" alt="Logo"/>
            </a></p>
            </center>
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Solving partial differential equations</a><ul>
<li><a class="reference internal" href="#finite-difference-methods">Finite difference methods</a><ul>
<li><a class="reference internal" href="#reduction-of-a-pde-to-a-system-of-odes">Reduction of a PDE to a system of ODEs</a></li>
<li><a class="reference internal" href="#construction-of-a-test-problem-with-known-discrete-solution">Construction of a test problem with known discrete solution</a></li>
<li><a class="reference internal" href="#implementation-forward-euler-method">Implementation: Forward Euler method</a></li>
<li><a class="reference internal" href="#application-heat-conduction-in-a-rod">Application: heat conduction in a rod</a></li>
<li><a class="reference internal" href="#vectorization-2">Vectorization</a></li>
<li><a class="reference internal" href="#using-odespy-to-solve-the-system-of-odes">Using Odespy to solve the system of ODEs</a></li>
<li><a class="reference internal" href="#implicit-methods">Implicit methods</a></li>
</ul>
</li>
<li><a class="reference internal" href="#exercises-5">Exercises</a><ul>
<li><a class="reference internal" href="#exercise-63-simulate-a-diffusion-equation-by-hand">Exercise 63: Simulate a diffusion equation by hand</a></li>
<li><a class="reference internal" href="#exercise-64-compute-temperature-variations-in-the-ground">Exercise 64: Compute temperature variations in the ground</a></li>
<li><a class="reference internal" href="#exercise-65-compare-implicit-methods">Exercise 65: Compare implicit methods</a></li>
<li><a class="reference internal" href="#exercise-66-explore-adaptive-and-implicit-methods">Exercise 66: Explore adaptive and implicit methods</a></li>
<li><a class="reference internal" href="#exercise-67-investigate-the-rule">Exercise 67: Investigate the <span class="math">\(\theta\)</span> rule</a><ul>
<li><a class="reference internal" href="#remarks-8">Remarks</a></li>
</ul>
</li>
<li><a class="reference internal" href="#exercise-68-compute-the-diffusion-of-a-gaussian-peak">Exercise 68: Compute the diffusion of a Gaussian peak</a><ul>
<li><a class="reference internal" href="#remarks-9">Remarks</a></li>
</ul>
</li>
<li><a class="reference internal" href="#exercise-69-vectorize-a-function-for-computing-the-area-of-a-polygon">Exercise 69: Vectorize a function for computing the area of a polygon</a></li>
<li><a class="reference internal" href="#exercise-70-explore-symmetry">Exercise 70: Explore symmetry</a><ul>
<li><a class="reference internal" href="#remarks-10">Remarks</a></li>
</ul>
</li>
<li><a class="reference internal" href="#exercise-71-compute-solutions-as">Exercise 71: Compute solutions as <span class="math">\(t\rightarrow\infty\)</span></a><ul>
<li><a class="reference internal" href="#remarks-11">Remarks</a></li>
</ul>
</li>
<li><a class="reference internal" href="#exercise-72-solve-a-two-point-boundary-value-problem">Exercise 72: Solve a two-point boundary value problem</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="._pylight005.html"
                        title="previous chapter">Solving ordinary differential equations</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="._pylight007.html"
                        title="next chapter">Solving nonlinear algebraic equations</a></p>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/._pylight006.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="._pylight007.html" title="Solving nonlinear algebraic equations"
             >next</a> |</li>
        <li class="right" >
          <a href="._pylight005.html" title="Solving ordinary differential equations"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">Programming for Computations (Python version)</a> &raquo;</li> 
      </ul>
    </div>
<div class="wrapper">
  <div class="footer">
    <a href="http://cbc.simula.no"><img src="_static/cbc_banner.png" width="100%"><a>
    <br />
    <br />
      &copy;2016, Svein Linge and Hans Petter Langtangen.
  </div>
</div>

  </body>
</html>